{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@apollo/server/src/cachePolicy.ts"],"sourcesContent":["import type { CacheHint, CachePolicy } from '@apollo/cache-control-types';\n\nexport function newCachePolicy(): CachePolicy {\n  return {\n    maxAge: undefined,\n    scope: undefined,\n    restrict(hint: CacheHint) {\n      if (\n        hint.maxAge !== undefined &&\n        (this.maxAge === undefined || hint.maxAge < this.maxAge)\n      ) {\n        this.maxAge = hint.maxAge;\n      }\n      if (hint.scope !== undefined && this.scope !== 'PRIVATE') {\n        this.scope = hint.scope;\n      }\n    },\n    replace(hint: CacheHint) {\n      if (hint.maxAge !== undefined) {\n        this.maxAge = hint.maxAge;\n      }\n      if (hint.scope !== undefined) {\n        this.scope = hint.scope;\n      }\n    },\n    policyIfCacheable() {\n      if (this.maxAge === undefined || this.maxAge === 0) {\n        return null;\n      }\n      return { maxAge: this.maxAge, scope: this.scope ?? 'PUBLIC' };\n    },\n  };\n}\n"],"names":[],"mappings":";;;;;AAEA,SAAgB;IACd,OAAO;QACL,QAAQ;QACR,OAAO;QACP,UAAS,IAAe;YACtB,IACE,KAAK,MAAM,KAAK,aAChB,CAAC,IAAI,CAAC,MAAM,KAAK,aAAa,KAAK,MAAM,GAAG,IAAI,CAAC,MAAM,GACvD;gBACA,IAAI,CAAC,MAAM,GAAG,KAAK,MAAM;YAC3B;YACA,IAAI,KAAK,KAAK,KAAK,aAAa,IAAI,CAAC,KAAK,KAAK,WAAW;gBACxD,IAAI,CAAC,KAAK,GAAG,KAAK,KAAK;YACzB;QACF;QACA,SAAQ,IAAe;YACrB,IAAI,KAAK,MAAM,KAAK,WAAW;gBAC7B,IAAI,CAAC,MAAM,GAAG,KAAK,MAAM;YAC3B;YACA,IAAI,KAAK,KAAK,KAAK,WAAW;gBAC5B,IAAI,CAAC,KAAK,GAAG,KAAK,KAAK;YACzB;QACF;QACA;YACE,IAAI,IAAI,CAAC,MAAM,KAAK,aAAa,IAAI,CAAC,MAAM,KAAK,GAAG;gBAClD,OAAO;YACT;YACA,OAAO;gBAAE,QAAQ,IAAI,CAAC,MAAM;gBAAE,OAAO,IAAI,CAAC,KAAK,IAAI;YAAQ;QAC7D;;AAEJ;AA9BA,QAAA,cAAA,GAAA"}},
    {"offset": {"line": 41, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 45, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@apollo/server/src/determineApolloConfig.ts"],"sourcesContent":["import { createHash } from '@apollo/utils.createhash';\nimport type { ApolloConfig, ApolloConfigInput } from './externalTypes/index.js';\nimport type { Logger } from '@apollo/utils.logger';\n\n// This function combines the `apollo` constructor argument and some environment\n// variables to come up with a full ApolloConfig.\nexport function determineApolloConfig(\n  input: ApolloConfigInput | undefined,\n  logger: Logger,\n): ApolloConfig {\n  const apolloConfig: ApolloConfig = {};\n\n  const {\n    APOLLO_KEY,\n    APOLLO_GRAPH_REF,\n    APOLLO_GRAPH_ID,\n    APOLLO_GRAPH_VARIANT,\n  } = process.env;\n\n  // Determine key.\n  if (input?.key) {\n    apolloConfig.key = input.key.trim();\n  } else if (APOLLO_KEY) {\n    apolloConfig.key = APOLLO_KEY.trim();\n  }\n  if ((input?.key ?? APOLLO_KEY) !== apolloConfig.key) {\n    logger.warn(\n      'The provided API key has unexpected leading or trailing whitespace. ' +\n        'Apollo Server will trim the key value before use.',\n    );\n  }\n\n  // Assert API key is a valid header value, since it's going to be used as one\n  // throughout.\n  if (apolloConfig.key) {\n    assertValidHeaderValue(apolloConfig.key);\n  }\n\n  // Determine key hash.\n  if (apolloConfig.key) {\n    apolloConfig.keyHash = createHash('sha512')\n      .update(apolloConfig.key)\n      .digest('hex');\n  }\n\n  // Determine graph ref, if provided together.\n  if (input?.graphRef) {\n    apolloConfig.graphRef = input.graphRef;\n  } else if (APOLLO_GRAPH_REF) {\n    apolloConfig.graphRef = APOLLO_GRAPH_REF;\n  }\n\n  // See if graph ID and variant were provided separately.\n  const graphId = input?.graphId ?? APOLLO_GRAPH_ID;\n  const graphVariant = input?.graphVariant ?? APOLLO_GRAPH_VARIANT;\n\n  if (apolloConfig.graphRef) {\n    if (graphId) {\n      throw new Error(\n        'Cannot specify both graph ref and graph ID. Please use ' +\n          '`apollo.graphRef` or `APOLLO_GRAPH_REF` without also setting the graph ID.',\n      );\n    }\n    if (graphVariant) {\n      throw new Error(\n        'Cannot specify both graph ref and graph variant. Please use ' +\n          '`apollo.graphRef` or `APOLLO_GRAPH_REF` without also setting the graph variant.',\n      );\n    }\n  } else if (graphId) {\n    // Graph ref is not specified, but the ID is. We can construct the ref\n    // from the ID and variant. Note that after this, we stop tracking the ID\n    // and variant, because Apollo Server 3 does not assume that all graph refs\n    // can be decomposed into ID and variant (except in the op reg plugin).\n    apolloConfig.graphRef = graphVariant\n      ? `${graphId}@${graphVariant}`\n      : graphId;\n  }\n\n  return apolloConfig;\n}\n\nfunction assertValidHeaderValue(value: string) {\n  // Ref: node-fetch@2.x `Headers` validation\n  // https://github.com/node-fetch/node-fetch/blob/9b9d45881e5ca68757077726b3c0ecf8fdca1f29/src/headers.js#L18\n  const invalidHeaderCharRegex = /[^\\t\\x20-\\x7e\\x80-\\xff]/g;\n  if (invalidHeaderCharRegex.test(value)) {\n    const invalidChars = value.match(invalidHeaderCharRegex)!;\n    throw new Error(\n      `The API key provided to Apollo Server contains characters which are invalid as HTTP header values. The following characters found in the key are invalid: ${invalidChars.join(\n        ', ',\n      )}. Valid header values may only contain ASCII visible characters. If you think there is an issue with your key, please contact Apollo support.`,\n    );\n  }\n}\n"],"names":[],"mappings":";;;;;AAAA,MAAA;AAMA,SAAgB,sBACd,KAAoC,EACpC,MAAc;IAEd,MAAM,eAA6B,CAAA;IAEnC,MAAM,EACJ,UAAU,EACV,gBAAgB,EAChB,eAAe,EACf,oBAAoB,EACrB,GAAG,QAAQ,GAAG;IAGf,IAAI,OAAO,KAAK;QACd,aAAa,GAAG,GAAG,MAAM,GAAG,CAAC,IAAI;IACnC,OAAO,IAAI,YAAY;QACrB,aAAa,GAAG,GAAG,WAAW,IAAI;IACpC;IACA,IAAI,CAAC,OAAO,OAAO,UAAU,MAAM,aAAa,GAAG,EAAE;QACnD,OAAO,IAAI,CACT,yEACE;IAEN;IAIA,IAAI,aAAa,GAAG,EAAE;QACpB,uBAAuB,aAAa,GAAG;IACzC;IAGA,IAAI,aAAa,GAAG,EAAE;QACpB,aAAa,OAAO,GAAG,CAAA,GAAA,mBAAA,UAAU,EAAC,UAC/B,MAAM,CAAC,aAAa,GAAG,EACvB,MAAM,CAAC;IACZ;IAGA,IAAI,OAAO,UAAU;QACnB,aAAa,QAAQ,GAAG,MAAM,QAAQ;IACxC,OAAO,IAAI,kBAAkB;QAC3B,aAAa,QAAQ,GAAG;IAC1B;IAGA,MAAM,UAAU,OAAO,WAAW;IAClC,MAAM,eAAe,OAAO,gBAAgB;IAE5C,IAAI,aAAa,QAAQ,EAAE;QACzB,IAAI,SAAS;YACX,MAAM,IAAI,MACR,4DACE;QAEN;QACA,IAAI,cAAc;YAChB,MAAM,IAAI,MACR,iEACE;QAEN;IACF,OAAO,IAAI,SAAS;QAKlB,aAAa,QAAQ,GAAG,eACpB,CAAA,EAAG,QAAO,CAAA,EAAI,aAAY,CAAE,GAC5B;IACN;IAEA,OAAO;AACT;AA1EA,QAAA,qBAAA,GAAA;AA4EA,SAAS,uBAAuB,KAAa;IAG3C,MAAM,yBAAyB;IAC/B,IAAI,uBAAuB,IAAI,CAAC,QAAQ;QACtC,MAAM,eAAe,MAAM,KAAK,CAAC;QACjC,MAAM,IAAI,MACR,CAAA,0JAAA,EAA6J,aAAa,IAAI,CAC5K,MACD,6IAAA,CAA+I;IAEpJ;AACF"}},
    {"offset": {"line": 95, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 99, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@apollo/server/src/errors/index.ts"],"sourcesContent":["import { GraphQLError } from 'graphql';\n\nexport enum ApolloServerErrorCode {\n  INTERNAL_SERVER_ERROR = 'INTERNAL_SERVER_ERROR',\n  GRAPHQL_PARSE_FAILED = 'GRAPHQL_PARSE_FAILED',\n  GRAPHQL_VALIDATION_FAILED = 'GRAPHQL_VALIDATION_FAILED',\n  PERSISTED_QUERY_NOT_FOUND = 'PERSISTED_QUERY_NOT_FOUND',\n  PERSISTED_QUERY_NOT_SUPPORTED = 'PERSISTED_QUERY_NOT_SUPPORTED',\n  BAD_USER_INPUT = 'BAD_USER_INPUT',\n  OPERATION_RESOLUTION_FAILURE = 'OPERATION_RESOLUTION_FAILURE',\n  BAD_REQUEST = 'BAD_REQUEST',\n}\n\nexport enum ApolloServerValidationErrorCode {\n  INTROSPECTION_DISABLED = 'INTROSPECTION_DISABLED',\n}\n\n/**\n * unwrapResolverError is a useful helper function for `formatError` hooks.\n * Errors thrown in resolvers are wrapped by graphql-js in a GraphQLError that\n * adds context such as the `path` to the field in the operation. If you'd like\n * to look directly at the original error thrown in the resolver (with whatever\n * data is on that error object, but without fields like `path`), you can use\n * this function. Note that other GraphQLErrors that contain `originalError`\n * (like parse errors) are not unwrapped by this function.\n */\nexport function unwrapResolverError(error: unknown): unknown {\n  if (error instanceof GraphQLError && error.path && error.originalError) {\n    return error.originalError;\n  }\n  return error;\n}\n"],"names":[],"mappings":";;;;;AAAA,MAAA;AAEA,IAAY;AAAZ,CAAA,SAAY,qBAAqB;IAC/B,qBAAA,CAAA,wBAAA,GAAA;IACA,qBAAA,CAAA,uBAAA,GAAA;IACA,qBAAA,CAAA,4BAAA,GAAA;IACA,qBAAA,CAAA,4BAAA,GAAA;IACA,qBAAA,CAAA,gCAAA,GAAA;IACA,qBAAA,CAAA,iBAAA,GAAA;IACA,qBAAA,CAAA,+BAAA,GAAA;IACA,qBAAA,CAAA,cAAA,GAAA;AACF,CAAC,EATW,yBAAqB,CAAA,QAAA,qBAAA,GAArB,wBAAqB,CAAA,CAAA;AAWjC,IAAY;AAAZ,CAAA,SAAY,+BAA+B;IACzC,+BAAA,CAAA,yBAAA,GAAA;AACF,CAAC,EAFW,mCAA+B,CAAA,QAAA,+BAAA,GAA/B,kCAA+B,CAAA,CAAA;AAa3C,SAAgB,oBAAoB,KAAc;IAChD,IAAI,iBAAiB,UAAA,YAAY,IAAI,MAAM,IAAI,IAAI,MAAM,aAAa,EAAE;QACtE,OAAO,MAAM,aAAa;IAC5B;IACA,OAAO;AACT;AALA,QAAA,mBAAA,GAAA"}},
    {"offset": {"line": 127, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 131, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@apollo/server/src/utils/HeaderMap.ts"],"sourcesContent":["export class HeaderMap extends Map<string, string> {\n  // In order for TypeScript to prevent a standard `Map` from being compatible\n  // with a `HeaderMap`, we need some additional property on the class.\n  // @ts-ignore (this is just unused)\n  private __identity = Symbol('HeaderMap');\n\n  override set(key: string, value: string): this {\n    return super.set(key.toLowerCase(), value);\n  }\n\n  override get(key: string) {\n    return super.get(key.toLowerCase());\n  }\n\n  override delete(key: string) {\n    return super.delete(key.toLowerCase());\n  }\n\n  override has(key: string) {\n    return super.has(key.toLowerCase());\n  }\n}\n"],"names":[],"mappings":";;;;;AAAA,MAAa,kBAAkB;IAA/B,aAAA;;QAIU,IAAA,CAAA,UAAU,GAAG,OAAO;IAiB9B;IAfW,IAAI,GAAW,EAAE,KAAa,EAAA;QACrC,OAAO,KAAK,CAAC,IAAI,IAAI,WAAW,IAAI;IACtC;IAES,IAAI,GAAW,EAAA;QACtB,OAAO,KAAK,CAAC,IAAI,IAAI,WAAW;IAClC;IAES,OAAO,GAAW,EAAA;QACzB,OAAO,KAAK,CAAC,OAAO,IAAI,WAAW;IACrC;IAES,IAAI,GAAW,EAAA;QACtB,OAAO,KAAK,CAAC,IAAI,IAAI,WAAW;IAClC;;AApBF,QAAA,SAAA,GAAA"}},
    {"offset": {"line": 155, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 159, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@apollo/server/src/internalErrorClasses.ts"],"sourcesContent":["import { GraphQLError, type GraphQLErrorOptions } from 'graphql';\nimport { ApolloServerErrorCode } from './errors/index.js';\nimport { newHTTPGraphQLHead } from './runHttpQuery.js';\nimport { HeaderMap } from './utils/HeaderMap.js';\n\n// These error classes are not part of Apollo Server's external API; the\n// ApolloServerErrorCode enum is (exported from `@apollo/server/errors`).\n\nclass GraphQLErrorWithCode extends GraphQLError {\n  constructor(\n    message: string,\n    code: ApolloServerErrorCode,\n    options?: GraphQLErrorOptions,\n  ) {\n    super(message, {\n      ...options,\n      extensions: { ...options?.extensions, code },\n    });\n    this.name = this.constructor.name;\n  }\n}\n\nexport class SyntaxError extends GraphQLErrorWithCode {\n  constructor(graphqlError: GraphQLError) {\n    super(graphqlError.message, ApolloServerErrorCode.GRAPHQL_PARSE_FAILED, {\n      source: graphqlError.source,\n      positions: graphqlError.positions,\n      extensions: { http: newHTTPGraphQLHead(400), ...graphqlError.extensions },\n      originalError: graphqlError,\n    });\n  }\n}\n\nexport class ValidationError extends GraphQLErrorWithCode {\n  constructor(graphqlError: GraphQLError) {\n    super(\n      graphqlError.message,\n      ApolloServerErrorCode.GRAPHQL_VALIDATION_FAILED,\n      {\n        nodes: graphqlError.nodes,\n        extensions: {\n          http: newHTTPGraphQLHead(400),\n          ...graphqlError.extensions,\n        },\n        originalError: graphqlError.originalError ?? graphqlError,\n      },\n    );\n  }\n}\n\n// Persisted query errors (especially \"not found\") need to be uncached, because\n// hopefully we're about to fill in the APQ cache and the same request will\n// succeed next time. We also want a 200 response to avoid any error handling\n// that may mask the contents of an error response. (Otherwise, the default\n// status code for a response with `errors` but no `data` (even null) is 400.)\nconst getPersistedQueryErrorHttp = () => ({\n  status: 200,\n  headers: new HeaderMap([\n    ['cache-control', 'private, no-cache, must-revalidate'],\n  ]),\n});\n\nexport class PersistedQueryNotFoundError extends GraphQLErrorWithCode {\n  constructor() {\n    super(\n      'PersistedQueryNotFound',\n      ApolloServerErrorCode.PERSISTED_QUERY_NOT_FOUND,\n      { extensions: { http: getPersistedQueryErrorHttp() } },\n    );\n  }\n}\n\nexport class PersistedQueryNotSupportedError extends GraphQLErrorWithCode {\n  constructor() {\n    super(\n      'PersistedQueryNotSupported',\n      ApolloServerErrorCode.PERSISTED_QUERY_NOT_SUPPORTED,\n      // Not super clear why we need this to be uncached (makes sense for\n      // PersistedQueryNotFoundError, because there we're about to fill the\n      // cache and make the next copy of the same request succeed) but we've\n      // been doing it for years so :shrug:\n      { extensions: { http: getPersistedQueryErrorHttp() } },\n    );\n  }\n}\n\nexport class UserInputError extends GraphQLErrorWithCode {\n  constructor(graphqlError: GraphQLError) {\n    super(graphqlError.message, ApolloServerErrorCode.BAD_USER_INPUT, {\n      nodes: graphqlError.nodes,\n      originalError: graphqlError.originalError ?? graphqlError,\n      extensions: graphqlError.extensions,\n    });\n  }\n}\n\nexport class OperationResolutionError extends GraphQLErrorWithCode {\n  constructor(graphqlError: GraphQLError) {\n    super(\n      graphqlError.message,\n      ApolloServerErrorCode.OPERATION_RESOLUTION_FAILURE,\n      {\n        nodes: graphqlError.nodes,\n        originalError: graphqlError.originalError ?? graphqlError,\n        extensions: {\n          http: newHTTPGraphQLHead(400),\n          ...graphqlError.extensions,\n        },\n      },\n    );\n  }\n}\n\nexport class BadRequestError extends GraphQLErrorWithCode {\n  constructor(message: string, options?: GraphQLErrorOptions) {\n    super(message, ApolloServerErrorCode.BAD_REQUEST, {\n      ...options,\n      // Default to 400 status code, but caller can override. (If caller just\n      // wants to override headers... well, they can't, sorry.)\n      extensions: { http: newHTTPGraphQLHead(400), ...options?.extensions },\n    });\n  }\n}\n"],"names":[],"mappings":";;;;;AAAA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AAKA,MAAM,6BAA6B,UAAA,YAAY;IAC7C,YACE,OAAe,EACf,IAA2B,EAC3B,OAA6B,CAAA;QAE7B,KAAK,CAAC,SAAS;YACb,GAAG,OAAO;YACV,YAAY;gBAAE,GAAG,SAAS,UAAU;gBAAE;YAAI;;QAE5C,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,WAAW,CAAC,IAAI;IACnC;;AAGF,MAAa,oBAAoB;IAC/B,YAAY,YAA0B,CAAA;QACpC,KAAK,CAAC,aAAa,OAAO,EAAE,WAAA,qBAAqB,CAAC,oBAAoB,EAAE;YACtE,QAAQ,aAAa,MAAM;YAC3B,WAAW,aAAa,SAAS;YACjC,YAAY;gBAAE,MAAM,CAAA,GAAA,kBAAA,kBAAkB,EAAC;gBAAM,GAAG,aAAa,UAAU;YAAA;YACvE,eAAe;;IAEnB;;AARF,QAAA,WAAA,GAAA;AAWA,MAAa,wBAAwB;IACnC,YAAY,YAA0B,CAAA;QACpC,KAAK,CACH,aAAa,OAAO,EACpB,WAAA,qBAAqB,CAAC,yBAAyB,EAC/C;YACE,OAAO,aAAa,KAAK;YACzB,YAAY;gBACV,MAAM,CAAA,GAAA,kBAAA,kBAAkB,EAAC;gBACzB,GAAG,aAAa,UAAU;;YAE5B,eAAe,aAAa,aAAa,IAAI;;IAGnD;;AAdF,QAAA,eAAA,GAAA;AAsBA,MAAM,6BAA6B,IAAM,CAAC;QACxC,QAAQ;QACR,SAAS,IAAI,eAAA,SAAS,CAAC;YACrB;gBAAC;gBAAiB;aAAqC;SACxD;KACF;AAED,MAAa,oCAAoC;IAC/C,aAAA;QACE,KAAK,CACH,0BACA,WAAA,qBAAqB,CAAC,yBAAyB,EAC/C;YAAE,YAAY;gBAAE,MAAM;YAA4B;QAAE;IAExD;;AAPF,QAAA,2BAAA,GAAA;AAUA,MAAa,wCAAwC;IACnD,aAAA;QACE,KAAK,CACH,8BACA,WAAA,qBAAqB,CAAC,6BAA6B,EAKnD;YAAE,YAAY;gBAAE,MAAM;YAA4B;QAAE;IAExD;;AAXF,QAAA,+BAAA,GAAA;AAcA,MAAa,uBAAuB;IAClC,YAAY,YAA0B,CAAA;QACpC,KAAK,CAAC,aAAa,OAAO,EAAE,WAAA,qBAAqB,CAAC,cAAc,EAAE;YAChE,OAAO,aAAa,KAAK;YACzB,eAAe,aAAa,aAAa,IAAI;YAC7C,YAAY,aAAa,UAAU;;IAEvC;;AAPF,QAAA,cAAA,GAAA;AAUA,MAAa,iCAAiC;IAC5C,YAAY,YAA0B,CAAA;QACpC,KAAK,CACH,aAAa,OAAO,EACpB,WAAA,qBAAqB,CAAC,4BAA4B,EAClD;YACE,OAAO,aAAa,KAAK;YACzB,eAAe,aAAa,aAAa,IAAI;YAC7C,YAAY;gBACV,MAAM,CAAA,GAAA,kBAAA,kBAAkB,EAAC;gBACzB,GAAG,aAAa,UAAU;;;IAIlC;;AAdF,QAAA,wBAAA,GAAA;AAiBA,MAAa,wBAAwB;IACnC,YAAY,OAAe,EAAE,OAA6B,CAAA;QACxD,KAAK,CAAC,SAAS,WAAA,qBAAqB,CAAC,WAAW,EAAE;YAChD,GAAG,OAAO;YAGV,YAAY;gBAAE,MAAM,CAAA,GAAA,kBAAA,kBAAkB,EAAC;gBAAM,GAAG,SAAS,UAAU;YAAA;;IAEvE;;AARF,QAAA,eAAA,GAAA"}},
    {"offset": {"line": 271, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 275, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@apollo/server/src/runHttpQuery.ts"],"sourcesContent":["import type {\n  BaseContext,\n  GraphQLExperimentalFormattedIncrementalResult,\n  GraphQLExperimentalFormattedInitialIncrementalExecutionResult,\n  GraphQLExperimentalFormattedSubsequentIncrementalExecutionResult,\n  GraphQLRequest,\n  HTTPGraphQLHead,\n  HTTPGraphQLRequest,\n  HTTPGraphQLResponse,\n} from './externalTypes/index.js';\nimport {\n  type ApolloServer,\n  type ApolloServerInternals,\n  chooseContentTypeForSingleResultResponse,\n  internalExecuteOperation,\n  MEDIA_TYPES,\n  type SchemaDerivedData,\n} from './ApolloServer.js';\nimport { type FormattedExecutionResult, Kind } from 'graphql';\nimport { BadRequestError } from './internalErrorClasses.js';\nimport Negotiator from 'negotiator';\nimport { HeaderMap } from './utils/HeaderMap.js';\n\nfunction fieldIfString(\n  o: Record<string, unknown>,\n  fieldName: string,\n): string | undefined {\n  const value = o[fieldName];\n  if (typeof value === 'string') {\n    return value;\n  }\n  return undefined;\n}\n\nfunction searchParamIfSpecifiedOnce(\n  searchParams: URLSearchParams,\n  paramName: string,\n) {\n  const values = searchParams.getAll(paramName);\n  switch (values.length) {\n    case 0:\n      return undefined;\n    case 1:\n      return values[0];\n    default:\n      throw new BadRequestError(\n        `The '${paramName}' search parameter may only be specified once.`,\n      );\n  }\n}\n\nfunction jsonParsedSearchParamIfSpecifiedOnce(\n  searchParams: URLSearchParams,\n  fieldName: string,\n): Record<string, unknown> | undefined {\n  const value = searchParamIfSpecifiedOnce(searchParams, fieldName);\n  if (value === undefined) {\n    return undefined;\n  }\n  let hopefullyRecord;\n  try {\n    hopefullyRecord = JSON.parse(value);\n  } catch {\n    throw new BadRequestError(\n      `The ${fieldName} search parameter contains invalid JSON.`,\n    );\n  }\n  if (!isStringRecord(hopefullyRecord)) {\n    throw new BadRequestError(\n      `The ${fieldName} search parameter should contain a JSON-encoded object.`,\n    );\n  }\n  return hopefullyRecord;\n}\n\nfunction fieldIfRecord(\n  o: Record<string, unknown>,\n  fieldName: string,\n): Record<string, unknown> | undefined {\n  const value = o[fieldName];\n  if (isStringRecord(value)) {\n    return value;\n  }\n  return undefined;\n}\n\nfunction isStringRecord(o: unknown): o is Record<string, unknown> {\n  return (\n    !!o && typeof o === 'object' && !Buffer.isBuffer(o) && !Array.isArray(o)\n  );\n}\n\nfunction isNonEmptyStringRecord(o: unknown): o is Record<string, unknown> {\n  return isStringRecord(o) && Object.keys(o).length > 0;\n}\n\nfunction ensureQueryIsStringOrMissing(query: unknown) {\n  if (!query || typeof query === 'string') {\n    return;\n  }\n  // Check for a common error first.\n  if ((query as any).kind === Kind.DOCUMENT) {\n    throw new BadRequestError(\n      \"GraphQL queries must be strings. It looks like you're sending the \" +\n        'internal graphql-js representation of a parsed query in your ' +\n        'request instead of a request in the GraphQL query language. You ' +\n        'can convert an AST to a string using the `print` function from ' +\n        '`graphql`, or use a client like `apollo-client` which converts ' +\n        'the internal representation to a string for you.',\n    );\n  } else {\n    throw new BadRequestError('GraphQL queries must be strings.');\n  }\n}\n\nexport async function runHttpQuery<TContext extends BaseContext>({\n  server,\n  httpRequest,\n  contextValue,\n  schemaDerivedData,\n  internals,\n  sharedResponseHTTPGraphQLHead,\n}: {\n  server: ApolloServer<TContext>;\n  httpRequest: HTTPGraphQLRequest;\n  contextValue: TContext;\n  schemaDerivedData: SchemaDerivedData;\n  internals: ApolloServerInternals<TContext>;\n  sharedResponseHTTPGraphQLHead: HTTPGraphQLHead | null;\n}): Promise<HTTPGraphQLResponse> {\n  let graphQLRequest: GraphQLRequest;\n\n  switch (httpRequest.method) {\n    case 'POST': {\n      if (!isNonEmptyStringRecord(httpRequest.body)) {\n        throw new BadRequestError(\n          'POST body missing, invalid Content-Type, or JSON object has no keys.',\n        );\n      }\n\n      ensureQueryIsStringOrMissing(httpRequest.body.query);\n\n      if (typeof httpRequest.body.variables === 'string') {\n        throw new BadRequestError(\n          '`variables` in a POST body should be provided as an object, not a recursively JSON-encoded string.',\n        );\n      }\n\n      if (typeof httpRequest.body.extensions === 'string') {\n        throw new BadRequestError(\n          '`extensions` in a POST body should be provided as an object, not a recursively JSON-encoded string.',\n        );\n      }\n\n      if (\n        'extensions' in httpRequest.body &&\n        httpRequest.body.extensions !== null &&\n        !isStringRecord(httpRequest.body.extensions)\n      ) {\n        throw new BadRequestError(\n          '`extensions` in a POST body must be an object if provided.',\n        );\n      }\n\n      if (\n        'variables' in httpRequest.body &&\n        httpRequest.body.variables !== null &&\n        !isStringRecord(httpRequest.body.variables)\n      ) {\n        throw new BadRequestError(\n          '`variables` in a POST body must be an object if provided.',\n        );\n      }\n\n      if (\n        'operationName' in httpRequest.body &&\n        httpRequest.body.operationName !== null &&\n        typeof httpRequest.body.operationName !== 'string'\n      ) {\n        throw new BadRequestError(\n          '`operationName` in a POST body must be a string if provided.',\n        );\n      }\n\n      graphQLRequest = {\n        query: fieldIfString(httpRequest.body, 'query'),\n        operationName: fieldIfString(httpRequest.body, 'operationName'),\n        variables: fieldIfRecord(httpRequest.body, 'variables'),\n        extensions: fieldIfRecord(httpRequest.body, 'extensions'),\n        http: httpRequest,\n      };\n\n      break;\n    }\n\n    case 'GET': {\n      const searchParams = new URLSearchParams(httpRequest.search);\n\n      graphQLRequest = {\n        query: searchParamIfSpecifiedOnce(searchParams, 'query'),\n        operationName: searchParamIfSpecifiedOnce(\n          searchParams,\n          'operationName',\n        ),\n        variables: jsonParsedSearchParamIfSpecifiedOnce(\n          searchParams,\n          'variables',\n        ),\n        extensions: jsonParsedSearchParamIfSpecifiedOnce(\n          searchParams,\n          'extensions',\n        ),\n        http: httpRequest,\n      };\n\n      break;\n    }\n    default:\n      throw new BadRequestError(\n        'Apollo Server supports only GET/POST requests.',\n        {\n          extensions: {\n            http: {\n              status: 405,\n              headers: new HeaderMap([['allow', 'GET, POST']]),\n            },\n          },\n        },\n      );\n  }\n\n  const graphQLResponse = await internalExecuteOperation(\n    {\n      server,\n      graphQLRequest,\n      internals,\n      schemaDerivedData,\n      sharedResponseHTTPGraphQLHead,\n    },\n    { contextValue },\n  );\n\n  if (graphQLResponse.body.kind === 'single') {\n    if (!graphQLResponse.http.headers.get('content-type')) {\n      // If we haven't already set the content-type (via a plugin or something),\n      // decide which content-type to use based on the accept header.\n      const contentType = chooseContentTypeForSingleResultResponse(httpRequest);\n      if (contentType === null) {\n        throw new BadRequestError(\n          `An 'accept' header was provided for this request which does not accept ` +\n            `${MEDIA_TYPES.APPLICATION_JSON} or ${MEDIA_TYPES.APPLICATION_GRAPHQL_RESPONSE_JSON}`,\n          // Use 406 Not Accepted\n          { extensions: { http: { status: 406 } } },\n        );\n      }\n      graphQLResponse.http.headers.set('content-type', contentType);\n    }\n\n    return {\n      ...graphQLResponse.http,\n      body: {\n        kind: 'complete',\n        string: await internals.stringifyResult(\n          orderExecutionResultFields(graphQLResponse.body.singleResult),\n        ),\n      },\n    };\n  }\n\n  // Note that incremental delivery is not yet part of the official GraphQL\n  // spec. We are implementing a proposed version of the spec, and require\n  // clients to explicitly state `deferSpec=20220824`. Once incremental delivery\n  // has been added to the GraphQL spec, we will support `accept` headers\n  // without `deferSpec` as well (perhaps with slightly different behavior if\n  // anything has changed).\n  const acceptHeader = httpRequest.headers.get('accept');\n  if (\n    !(\n      acceptHeader &&\n      new Negotiator({\n        headers: { accept: httpRequest.headers.get('accept') },\n      }).mediaType([\n        // mediaType() will return the first one that matches, so if the client\n        // doesn't include the deferSpec parameter it will match this one here,\n        // which isn't good enough.\n        MEDIA_TYPES.MULTIPART_MIXED_NO_DEFER_SPEC,\n        MEDIA_TYPES.MULTIPART_MIXED_EXPERIMENTAL,\n      ]) === MEDIA_TYPES.MULTIPART_MIXED_EXPERIMENTAL\n    )\n  ) {\n    // The client ran an operation that would yield multiple parts, but didn't\n    // specify `accept: multipart/mixed`. We return an error.\n    throw new BadRequestError(\n      'Apollo server received an operation that uses incremental delivery ' +\n        '(@defer or @stream), but the client does not accept multipart/mixed ' +\n        'HTTP responses. To enable incremental delivery support, add the HTTP ' +\n        \"header 'Accept: multipart/mixed; deferSpec=20220824'.\",\n      // Use 406 Not Accepted\n      { extensions: { http: { status: 406 } } },\n    );\n  }\n\n  graphQLResponse.http.headers.set(\n    'content-type',\n    'multipart/mixed; boundary=\"-\"; deferSpec=20220824',\n  );\n  return {\n    ...graphQLResponse.http,\n    body: {\n      kind: 'chunked',\n      asyncIterator: writeMultipartBody(\n        graphQLResponse.body.initialResult,\n        graphQLResponse.body.subsequentResults,\n      ),\n    },\n  };\n}\n\nasync function* writeMultipartBody(\n  initialResult: GraphQLExperimentalFormattedInitialIncrementalExecutionResult,\n  subsequentResults: AsyncIterable<GraphQLExperimentalFormattedSubsequentIncrementalExecutionResult>,\n): AsyncGenerator<string> {\n  // Note: we assume in this function that every result other than the last has\n  // hasNext=true and the last has hasNext=false. That is, we choose which kind\n  // of delimiter to place at the end of each block based on the contents of the\n  // message, not the structure of the async iterator. This makes sense because\n  // we want to write the delimiter as soon as each block is done (so the client\n  // can parse it immediately) but we may not know whether a general async\n  // iterator is finished until we do async work.\n\n  yield `\\r\\n---\\r\\ncontent-type: application/json; charset=utf-8\\r\\n\\r\\n${JSON.stringify(\n    orderInitialIncrementalExecutionResultFields(initialResult),\n  )}\\r\\n---${initialResult.hasNext ? '' : '--'}\\r\\n`;\n\n  for await (const result of subsequentResults) {\n    yield `content-type: application/json; charset=utf-8\\r\\n\\r\\n${JSON.stringify(\n      orderSubsequentIncrementalExecutionResultFields(result),\n    )}\\r\\n---${result.hasNext ? '' : '--'}\\r\\n`;\n  }\n}\n\n// See https://github.com/facebook/graphql/pull/384 for why\n// errors comes first.\nfunction orderExecutionResultFields(\n  result: FormattedExecutionResult,\n): FormattedExecutionResult {\n  return {\n    errors: result.errors,\n    data: result.data,\n    extensions: result.extensions,\n  };\n}\nfunction orderInitialIncrementalExecutionResultFields(\n  result: GraphQLExperimentalFormattedInitialIncrementalExecutionResult,\n): GraphQLExperimentalFormattedInitialIncrementalExecutionResult {\n  return {\n    hasNext: result.hasNext,\n    errors: result.errors,\n    data: result.data,\n    incremental: orderIncrementalResultFields(result.incremental),\n    extensions: result.extensions,\n  };\n}\nfunction orderSubsequentIncrementalExecutionResultFields(\n  result: GraphQLExperimentalFormattedSubsequentIncrementalExecutionResult,\n): GraphQLExperimentalFormattedSubsequentIncrementalExecutionResult {\n  return {\n    hasNext: result.hasNext,\n    incremental: orderIncrementalResultFields(result.incremental),\n    extensions: result.extensions,\n  };\n}\n\nfunction orderIncrementalResultFields(\n  incremental?: readonly GraphQLExperimentalFormattedIncrementalResult[],\n): undefined | GraphQLExperimentalFormattedIncrementalResult[] {\n  return incremental?.map((i: any) => ({\n    hasNext: i.hasNext,\n    errors: i.errors,\n    path: i.path,\n    label: i.label,\n    data: i.data,\n    items: i.items,\n    extensions: i.extensions,\n  }));\n}\n\n// The result of a curl does not appear well in the terminal, so we add an extra new line\nexport function prettyJSONStringify(value: FormattedExecutionResult) {\n  return JSON.stringify(value) + '\\n';\n}\n\nexport function newHTTPGraphQLHead(status?: number): HTTPGraphQLHead {\n  return {\n    status,\n    headers: new HeaderMap(),\n  };\n}\n\n// Updates `target` with status code and headers from `source`. For now let's\n// consider it undefined what happens if both have a status code set or both set\n// the same header.\nexport function mergeHTTPGraphQLHead(\n  target: HTTPGraphQLHead,\n  source: HTTPGraphQLHead,\n) {\n  if (source.status) {\n    target.status = source.status;\n  }\n  if (source.headers) {\n    for (const [name, value] of source.headers) {\n      // If source.headers contains non-lowercase header names, this will\n      // catch that case as long as target.headers is a HeaderMap.\n      target.headers.set(name, value);\n    }\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 527, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 531, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@apollo/server/src/errorNormalize.ts"],"sourcesContent":["// The functions in this file are not part of Apollo Server's external API.\n\nimport {\n  GraphQLError,\n  type GraphQLErrorExtensions,\n  type GraphQLFormattedError,\n} from 'graphql';\nimport { ApolloServerErrorCode } from './errors/index.js';\nimport type { HTTPGraphQLHead } from './externalTypes/http.js';\nimport { mergeHTTPGraphQLHead, newHTTPGraphQLHead } from './runHttpQuery.js';\nimport { HeaderMap } from './utils/HeaderMap.js';\n\n// This function accepts any value that were thrown and convert it to GraphQLFormattedError.\n// It also add default extensions.code and copy stack trace onto an extension if requested.\n// Additionally, it returns an `HTTPGraphQLHead` created from combining the values of any\n// `HTTPGraphqlHead` objects found on `extensions.http` (the behavior when multiple errors\n// set a status code or set the same header should be treated as undefined); these extensions\n// are removed from the formatted error.\n//\n// This function should not throw.\nexport function normalizeAndFormatErrors(\n  errors: ReadonlyArray<unknown>,\n  options: {\n    formatError?: (\n      formattedError: GraphQLFormattedError,\n      error: unknown,\n    ) => GraphQLFormattedError;\n    includeStacktraceInErrorResponses?: boolean;\n  } = {},\n): {\n  formattedErrors: Array<GraphQLFormattedError>;\n  httpFromErrors: HTTPGraphQLHead;\n} {\n  const formatError = options.formatError ?? ((error) => error);\n  const httpFromErrors = newHTTPGraphQLHead();\n\n  return {\n    httpFromErrors,\n    formattedErrors: errors.map((error) => {\n      try {\n        return formatError(enrichError(error), error);\n      } catch (formattingError) {\n        if (options.includeStacktraceInErrorResponses) {\n          // includeStacktraceInErrorResponses is used in development\n          // so it will be helpful to show errors thrown by formatError hooks in that mode\n          return enrichError(formattingError);\n        } else {\n          // obscure error\n          return {\n            message: 'Internal server error',\n            extensions: { code: ApolloServerErrorCode.INTERNAL_SERVER_ERROR },\n          };\n        }\n      }\n    }),\n  };\n\n  function enrichError(maybeError: unknown): GraphQLFormattedError {\n    const graphqlError = ensureGraphQLError(maybeError);\n\n    const extensions: GraphQLErrorExtensions = {\n      ...graphqlError.extensions,\n      code:\n        graphqlError.extensions.code ??\n        ApolloServerErrorCode.INTERNAL_SERVER_ERROR,\n    };\n\n    if (isPartialHTTPGraphQLHead(extensions.http)) {\n      mergeHTTPGraphQLHead(httpFromErrors, {\n        headers: new HeaderMap(),\n        ...extensions.http,\n      });\n      delete extensions.http;\n    }\n\n    if (options.includeStacktraceInErrorResponses) {\n      // Note that if ensureGraphQLError created graphqlError from an\n      // originalError, graphqlError.stack will be the same as\n      // originalError.stack due to some special code in the GraphQLError\n      // constructor.\n      extensions.stacktrace = graphqlError.stack?.split('\\n');\n    }\n\n    return { ...graphqlError.toJSON(), extensions };\n  }\n}\n\nexport function ensureError(maybeError: unknown): Error {\n  return maybeError instanceof Error\n    ? maybeError\n    : new GraphQLError('Unexpected error value: ' + String(maybeError));\n}\n\nexport function ensureGraphQLError(\n  maybeError: unknown,\n  messagePrefixIfNotGraphQLError: string = '',\n): GraphQLError {\n  const error: Error = ensureError(maybeError);\n\n  return error instanceof GraphQLError\n    ? error\n    : new GraphQLError(messagePrefixIfNotGraphQLError + error.message, {\n        originalError: error,\n      });\n}\n\nfunction isPartialHTTPGraphQLHead(x: unknown): x is Partial<HTTPGraphQLHead> {\n  return (\n    !!x &&\n    typeof x === 'object' &&\n    (!('status' in x) || typeof (x as any).status === 'number') &&\n    (!('headers' in x) || (x as any).headers instanceof Map)\n  );\n}\n"],"names":[],"mappings":";;;;;AAEA,MAAA;AAKA,MAAA;AAEA,MAAA;AACA,MAAA;AAUA,SAAgB,yBACd,MAA8B,EAC9B,UAMI,CAAA,CAAE;IAKN,MAAM,cAAc,QAAQ,WAAW,IAAI,CAAC,CAAC,QAAU,KAAK;IAC5D,MAAM,iBAAiB,CAAA,GAAA,kBAAA,kBAAkB;IAEzC,OAAO;QACL;QACA,iBAAiB,OAAO,GAAG,CAAC,CAAC;YAC3B,IAAI;gBACF,OAAO,YAAY,YAAY,QAAQ;YACzC,EAAE,OAAO,iBAAiB;gBACxB,IAAI,QAAQ,iCAAiC,EAAE;oBAG7C,OAAO,YAAY;gBACrB,OAAO;oBAEL,OAAO;wBACL,SAAS;wBACT,YAAY;4BAAE,MAAM,WAAA,qBAAqB,CAAC,qBAAqB;wBAAA;;gBAEnE;YACF;QACF;;IAGF,SAAS,YAAY,UAAmB;QACtC,MAAM,eAAe,mBAAmB;QAExC,MAAM,aAAqC;YACzC,GAAG,aAAa,UAAU;YAC1B,MACE,aAAa,UAAU,CAAC,IAAI,IAC5B,WAAA,qBAAqB,CAAC,qBAAqB;;QAG/C,IAAI,yBAAyB,WAAW,IAAI,GAAG;YAC7C,CAAA,GAAA,kBAAA,oBAAoB,EAAC,gBAAgB;gBACnC,SAAS,IAAI,eAAA,SAAS;gBACtB,GAAG,WAAW,IAAI;;YAEpB,OAAO,WAAW,IAAI;QACxB;QAEA,IAAI,QAAQ,iCAAiC,EAAE;YAK7C,WAAW,UAAU,GAAG,aAAa,KAAK,EAAE,MAAM;QACpD;QAEA,OAAO;YAAE,GAAG,aAAa,MAAM,EAAE;YAAE;QAAU;IAC/C;AACF;AAjEA,QAAA,wBAAA,GAAA;AAmEA,SAAgB,YAAY,UAAmB;IAC7C,OAAO,sBAAsB,QACzB,aACA,IAAI,UAAA,YAAY,CAAC,6BAA6B,OAAO;AAC3D;AAJA,QAAA,WAAA,GAAA;AAMA,SAAgB,mBACd,UAAmB,EACnB,iCAAyC,EAAE;IAE3C,MAAM,QAAe,YAAY;IAEjC,OAAO,iBAAiB,UAAA,YAAY,GAChC,QACA,IAAI,UAAA,YAAY,CAAC,iCAAiC,MAAM,OAAO,EAAE;QAC/D,eAAe;;AAEvB;AAXA,QAAA,kBAAA,GAAA;AAaA,SAAS,yBAAyB,CAAU;IAC1C,OACE,CAAC,CAAC,KACF,OAAO,MAAM,YACb,CAAC,CAAC,CAAC,YAAY,CAAC,KAAK,OAAQ,EAAU,MAAM,KAAK,QAAQ,KAC1D,CAAC,CAAC,CAAC,aAAa,CAAC,KAAM,EAAU,OAAO,YAAY,GAAG;AAE3D"}},
    {"offset": {"line": 599, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 603, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@apollo/server/src/httpBatching.ts"],"sourcesContent":["import type {\n  BaseContext,\n  HTTPGraphQLRequest,\n  HTTPGraphQLResponse,\n} from './externalTypes/index.js';\nimport type {\n  ApolloServer,\n  ApolloServerInternals,\n  SchemaDerivedData,\n} from './ApolloServer';\nimport { newHTTPGraphQLHead, runHttpQuery } from './runHttpQuery.js';\nimport { BadRequestError } from './internalErrorClasses.js';\n\nasync function runBatchedHttpQuery<TContext extends BaseContext>({\n  server,\n  batchRequest,\n  body,\n  contextValue,\n  schemaDerivedData,\n  internals,\n}: {\n  server: ApolloServer<TContext>;\n  batchRequest: HTTPGraphQLRequest;\n  body: unknown[];\n  contextValue: TContext;\n  schemaDerivedData: SchemaDerivedData;\n  internals: ApolloServerInternals<TContext>;\n}): Promise<HTTPGraphQLResponse> {\n  if (body.length === 0) {\n    throw new BadRequestError('No operations found in request.');\n  }\n\n  // This single HTTPGraphQLHead is shared across all the operations in the\n  // batch. This means that any changes to response headers or status code from\n  // one operation can be immediately seen by other operations. Plugins that set\n  // response headers or status code can then choose to combine the data they\n  // are setting with data that may already be there from another operation as\n  // they choose.\n  const sharedResponseHTTPGraphQLHead = newHTTPGraphQLHead();\n  const responseBodies = await Promise.all(\n    body.map(async (bodyPiece: unknown) => {\n      const singleRequest: HTTPGraphQLRequest = {\n        ...batchRequest,\n        body: bodyPiece,\n      };\n\n      const response = await runHttpQuery({\n        server,\n        httpRequest: singleRequest,\n        contextValue,\n        schemaDerivedData,\n        internals,\n        sharedResponseHTTPGraphQLHead,\n      });\n\n      if (response.body.kind === 'chunked') {\n        throw Error(\n          'Incremental delivery is not implemented for batch requests',\n        );\n      }\n      return response.body.string;\n    }),\n  );\n  return {\n    ...sharedResponseHTTPGraphQLHead,\n    body: { kind: 'complete', string: `[${responseBodies.join(',')}]` },\n  };\n}\n\nexport async function runPotentiallyBatchedHttpQuery<\n  TContext extends BaseContext,\n>(\n  server: ApolloServer<TContext>,\n  httpGraphQLRequest: HTTPGraphQLRequest,\n  contextValue: TContext,\n  schemaDerivedData: SchemaDerivedData,\n  internals: ApolloServerInternals<TContext>,\n): Promise<HTTPGraphQLResponse> {\n  if (\n    !(\n      httpGraphQLRequest.method === 'POST' &&\n      Array.isArray(httpGraphQLRequest.body)\n    )\n  ) {\n    return await runHttpQuery({\n      server,\n      httpRequest: httpGraphQLRequest,\n      contextValue,\n      schemaDerivedData,\n      internals,\n      sharedResponseHTTPGraphQLHead: null,\n    });\n  }\n  if (internals.allowBatchedHttpRequests) {\n    return await runBatchedHttpQuery({\n      server,\n      batchRequest: httpGraphQLRequest,\n      body: httpGraphQLRequest.body as unknown[],\n      contextValue,\n      schemaDerivedData,\n      internals,\n    });\n  }\n  throw new BadRequestError('Operation batching disabled.');\n}\n"],"names":[],"mappings":";;;;;AAUA,MAAA;AACA,MAAA;AAEA,eAAe,oBAAkD,EAC/D,MAAM,EACN,YAAY,EACZ,IAAI,EACJ,YAAY,EACZ,iBAAiB,EACjB,SAAS,EAQV;IACC,IAAI,KAAK,MAAM,KAAK,GAAG;QACrB,MAAM,IAAI,0BAAA,eAAe,CAAC;IAC5B;IAQA,MAAM,gCAAgC,CAAA,GAAA,kBAAA,kBAAkB;IACxD,MAAM,iBAAiB,MAAM,QAAQ,GAAG,CACtC,KAAK,GAAG,CAAC,OAAO;QACd,MAAM,gBAAoC;YACxC,GAAG,YAAY;YACf,MAAM;;QAGR,MAAM,WAAW,MAAM,CAAA,GAAA,kBAAA,YAAY,EAAC;YAClC;YACA,aAAa;YACb;YACA;YACA;YACA;;QAGF,IAAI,SAAS,IAAI,CAAC,IAAI,KAAK,WAAW;YACpC,MAAM,MACJ;QAEJ;QACA,OAAO,SAAS,IAAI,CAAC,MAAM;IAC7B;IAEF,OAAO;QACL,GAAG,6BAA6B;QAChC,MAAM;YAAE,MAAM;YAAY,QAAQ,CAAA,CAAA,EAAI,eAAe,IAAI,CAAC,KAAI,CAAA,CAAG;QAAA;;AAErE;AAEO,eAAe,+BAGpB,MAA8B,EAC9B,kBAAsC,EACtC,YAAsB,EACtB,iBAAoC,EACpC,SAA0C;IAE1C,IACE,CAAC,CACC,mBAAmB,MAAM,KAAK,UAC9B,MAAM,OAAO,CAAC,mBAAmB,IAAI,CAAC,GAExC;QACA,OAAO,MAAM,CAAA,GAAA,kBAAA,YAAY,EAAC;YACxB;YACA,aAAa;YACb;YACA;YACA;YACA,+BAA+B;;IAEnC;IACA,IAAI,UAAU,wBAAwB,EAAE;QACtC,OAAO,MAAM,oBAAoB;YAC/B;YACA,cAAc;YACd,MAAM,mBAAmB,IAAiB;YAC1C;YACA;YACA;;IAEJ;IACA,MAAM,IAAI,0BAAA,eAAe,CAAC;AAC5B;AAnCA,QAAA,8BAAA,GAAA"}},
    {"offset": {"line": 665, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 669, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@apollo/server/src/internalPlugin.ts"],"sourcesContent":["import type { BaseContext, ApolloServerPlugin } from './externalTypes/index.js';\n\n// This file's exports should not be exported from the overall\n// @apollo/server module.\n\n// The internal plugins implement this interface which\n// ApolloServer.ensurePluginInstantiation uses to figure out if the plugins have\n// already been installed (or explicitly disabled via the matching Disable\n// plugins).\nexport interface InternalApolloServerPlugin<TContext extends BaseContext>\n  extends ApolloServerPlugin<TContext> {\n  // Used to identify a few specific plugins that are instantiated\n  // by default if not explicitly used or disabled.\n  __internal_plugin_id__: InternalPluginId;\n  __is_disabled_plugin__: boolean;\n}\n\n// Helper function for writing internal plugins which lets you write an object\n// that is type-checked as InternalApolloServerPlugin but is still only of type\n// ApolloServerPlugin (as appropriate for externally-exported plugin-returning\n// functions).\nexport function internalPlugin<TContext extends BaseContext>(\n  p: InternalApolloServerPlugin<TContext>,\n): ApolloServerPlugin<TContext> {\n  return p;\n}\n\nexport type InternalPluginId =\n  | 'CacheControl'\n  | 'LandingPageDisabled'\n  | 'SchemaReporting'\n  | 'InlineTrace'\n  | 'UsageReporting';\n\nexport function pluginIsInternal<TContext extends BaseContext>(\n  plugin: ApolloServerPlugin<TContext>,\n): plugin is InternalApolloServerPlugin<TContext> {\n  // We could call the function and compare it to the list above, but this seems\n  // good enough.\n  return '__internal_plugin_id__' in plugin;\n}\n"],"names":[],"mappings":";;;;;AAqBA,SAAgB,eACd,CAAuC;IAEvC,OAAO;AACT;AAJA,QAAA,cAAA,GAAA;AAaA,SAAgB,iBACd,MAAoC;IAIpC,OAAO,4BAA4B;AACrC;AANA,QAAA,gBAAA,GAAA"}},
    {"offset": {"line": 682, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 686, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@apollo/server/src/preventCsrf.ts"],"sourcesContent":["import MIMEType from 'whatwg-mimetype';\nimport { BadRequestError } from './internalErrorClasses.js';\nimport type { HeaderMap } from './utils/HeaderMap.js';\n\n// Our recommended set of CSRF prevention headers. Operations that do not\n// provide a content-type such as `application/json` (in practice, this\n// means GET operations) must include at least one of these headers.\n// Apollo Client Web's default behavior is to always sends a\n// `content-type` even for `GET`, and Apollo iOS and Apollo Kotlin always\n// send `x-apollo-operation-name`. So if you set\n// `csrfPreventionRequestHeaders: true` then any `GET` operation from these\n// three client projects and any `POST` operation at all should work\n// successfully; if you need `GET`s from another kind of client to work,\n// just add `apollo-require-preflight: true` to their requests.\nexport const recommendedCsrfPreventionRequestHeaders = [\n  'x-apollo-operation-name',\n  'apollo-require-preflight',\n];\n\n// See https://fetch.spec.whatwg.org/#cors-safelisted-request-header\nconst NON_PREFLIGHTED_CONTENT_TYPES = [\n  'application/x-www-form-urlencoded',\n  'multipart/form-data',\n  'text/plain',\n];\n\n// We don't want random websites to be able to execute actual GraphQL operations\n// from a user's browser unless our CORS policy supports it. It's not good\n// enough just to ensure that the browser can't read the response from the\n// operation; we also want to prevent CSRF, where the attacker can cause side\n// effects with an operation or can measure the timing of a read operation. Our\n// goal is to ensure that we don't run the context function or execute the\n// GraphQL operation until the browser has evaluated the CORS policy, which\n// means we want all operations to be pre-flighted. We can do that by only\n// processing operations that have at least one header set that appears to be\n// manually set by the JS code rather than by the browser automatically.\n//\n// POST requests generally have a content-type `application/json`, which is\n// sufficient to trigger preflighting. So we take extra care with requests that\n// specify no content-type or that specify one of the three non-preflighted\n// content types. For those operations, we require (if this feature is enabled)\n// one of a set of specific headers to be set. By ensuring that every operation\n// either has a custom content-type or sets one of these headers, we know we\n// won't execute operations at the request of origins who our CORS policy will\n// block.\nexport function preventCsrf(\n  headers: HeaderMap,\n  csrfPreventionRequestHeaders: string[],\n) {\n  const contentType = headers.get('content-type');\n\n  // We have to worry about CSRF if it looks like this may have been a\n  // non-preflighted request. If we see a content-type header that is not one of\n  // the three CORS-safelisted MIME types (see\n  // https://fetch.spec.whatwg.org/#cors-safelisted-request-header) then we know\n  // it was preflighted and we don't have to worry.\n  if (contentType !== undefined) {\n    const contentTypeParsed = MIMEType.parse(contentType);\n    if (contentTypeParsed === null) {\n      // If we got null, then parsing the content-type failed... which is\n      // actually *ok* because that would lead to a preflight. (For example, the\n      // header is empty, or doesn't have a slash, or has bad characters.) The\n      // scary CSRF case is only if there's *not* an error. So it is actually\n      // fine for us to just `return` here. (That said, it would also be\n      // reasonable to reject such requests with provided yet unparsable\n      // Content-Type here.)\n      return;\n    }\n    if (!NON_PREFLIGHTED_CONTENT_TYPES.includes(contentTypeParsed.essence)) {\n      // We managed to parse a MIME type that was not one of the\n      // CORS-safelisted ones. (Probably application/json!) That means that if\n      // the client is a browser, the browser must have applied CORS\n      // preflighting and we don't have to worry about CSRF.\n      return;\n    }\n  }\n\n  // Either there was no content-type, or the content-type parsed properly as\n  // one of the three CORS-safelisted values. Let's look for another header that\n  // (if this was a browser) must have been set by the user's code and would\n  // have caused a preflight.\n  if (\n    csrfPreventionRequestHeaders.some((header) => {\n      const value = headers.get(header);\n      return value !== undefined && value.length > 0;\n    })\n  ) {\n    return;\n  }\n\n  throw new BadRequestError(\n    `This operation has been blocked as a potential Cross-Site Request Forgery ` +\n      `(CSRF). Please either specify a 'content-type' header (with a type that ` +\n      `is not one of ${NON_PREFLIGHTED_CONTENT_TYPES.join(', ')}) or provide ` +\n      `a non-empty value for one of the following headers: ${csrfPreventionRequestHeaders.join(\n        ', ',\n      )}\\n`,\n  );\n}\n"],"names":[],"mappings":";;;;;;;;;;AAAA,MAAA,oBAAA;AACA,MAAA;AAaa,QAAA,uCAAuC,GAAG;IACrD;IACA;CACD;AAGD,MAAM,gCAAgC;IACpC;IACA;IACA;CACD;AAqBD,SAAgB,YACd,OAAkB,EAClB,4BAAsC;IAEtC,MAAM,cAAc,QAAQ,GAAG,CAAC;IAOhC,IAAI,gBAAgB,WAAW;QAC7B,MAAM,oBAAoB,kBAAA,OAAQ,CAAC,KAAK,CAAC;QACzC,IAAI,sBAAsB,MAAM;YAQ9B;QACF;QACA,IAAI,CAAC,8BAA8B,QAAQ,CAAC,kBAAkB,OAAO,GAAG;YAKtE;QACF;IACF;IAMA,IACE,6BAA6B,IAAI,CAAC,CAAC;QACjC,MAAM,QAAQ,QAAQ,GAAG,CAAC;QAC1B,OAAO,UAAU,aAAa,MAAM,MAAM,GAAG;IAC/C,IACA;QACA;IACF;IAEA,MAAM,IAAI,0BAAA,eAAe,CACvB,CAAA,0EAAA,CAA4E,GAC1E,CAAA,wEAAA,CAA0E,GAC1E,CAAA,cAAA,EAAiB,8BAA8B,IAAI,CAAC,MAAK,aAAA,CAAe,GACxE,CAAA,oDAAA,EAAuD,6BAA6B,IAAI,CACtF,MACD,EAAA,CAAI;AAEX;AArDA,QAAA,WAAA,GAAA"}},
    {"offset": {"line": 727, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 731, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@apollo/server/src/utils/schemaInstrumentation.ts"],"sourcesContent":["import {\n  type GraphQLSchema,\n  type GraphQLField,\n  getNamedType,\n  GraphQLObjectType,\n  type GraphQLFieldResolver,\n  defaultFieldResolver,\n} from 'graphql';\nimport type {\n  BaseContext,\n  GraphQLRequestExecutionListener,\n} from '../externalTypes/index.js';\n\nexport const symbolExecutionDispatcherWillResolveField = Symbol(\n  'apolloServerExecutionDispatcherWillResolveField',\n);\nexport const symbolUserFieldResolver = Symbol('apolloServerUserFieldResolver');\nconst symbolPluginsEnabled = Symbol('apolloServerPluginsEnabled');\n\nexport function enablePluginsForSchemaResolvers<TContext extends BaseContext>(\n  schema: GraphQLSchema & { [symbolPluginsEnabled]?: boolean },\n) {\n  if (pluginsEnabledForSchemaResolvers(schema)) {\n    return schema;\n  }\n  Object.defineProperty(schema, symbolPluginsEnabled, {\n    value: true,\n  });\n\n  const typeMap = schema.getTypeMap();\n  Object.values(typeMap).forEach((type) => {\n    if (\n      !getNamedType(type).name.startsWith('__') &&\n      type instanceof GraphQLObjectType\n    ) {\n      const fields = type.getFields();\n      Object.values(fields).forEach((field) => {\n        wrapField<TContext>(field);\n      });\n    }\n  });\n\n  return schema;\n}\n\nexport function pluginsEnabledForSchemaResolvers(\n  schema: GraphQLSchema & { [symbolPluginsEnabled]?: boolean },\n): boolean {\n  return !!schema[symbolPluginsEnabled];\n}\n\nfunction wrapField<TContext extends BaseContext>(\n  field: GraphQLField<any, any>,\n): void {\n  const originalFieldResolve = field.resolve;\n\n  field.resolve = (source, args, contextValue, info) => {\n    const willResolveField = contextValue?.[\n      symbolExecutionDispatcherWillResolveField\n    ] as\n      | GraphQLRequestExecutionListener<TContext>['willResolveField']\n      | undefined;\n\n    const userFieldResolver = contextValue?.[symbolUserFieldResolver] as\n      | GraphQLFieldResolver<any, any>\n      | undefined;\n\n    // The technique for implementing a  \"did resolve field\" is accomplished by\n    // returning a function from the `willResolveField` handler.  While there\n    // may be several callbacks, depending on the number of plugins which have\n    // implemented a `willResolveField` hook, this hook will call them all\n    // as dictated by the dispatcher.  We will call this when object\n    // resolution is complete.\n    const didResolveField =\n      typeof willResolveField === 'function' &&\n      willResolveField({ source, args, contextValue, info });\n\n    const fieldResolver =\n      originalFieldResolve || userFieldResolver || defaultFieldResolver;\n\n    try {\n      const result = fieldResolver(source, args, contextValue, info);\n\n      // Call the stack's handlers either immediately (if result is not a\n      // Promise) or once the Promise is done. Then return that same\n      // maybe-Promise value.\n      if (typeof didResolveField === 'function') {\n        whenResultIsFinished(result, didResolveField);\n      }\n      return result;\n    } catch (error) {\n      // Normally it's a bad sign to see an error both handled and\n      // re-thrown. But it is useful to allow extensions to track errors while\n      // still handling them in the normal GraphQL way.\n      if (typeof didResolveField === 'function') {\n        didResolveField(error as Error);\n      }\n      throw error;\n    }\n  };\n}\n\nfunction isPromise(x: any): boolean {\n  return x && typeof x.then === 'function';\n}\n\n// Given result (which may be a Promise or an array some of whose elements are\n// promises) Promises, set up 'callback' to be invoked when result is fully\n// resolved. (Unfortunately, this does not perfectly handle every possible\n// return value shape, such as arrays of arrays of Promises.)\nexport function whenResultIsFinished(\n  result: any,\n  callback: (err: Error | null, result?: any) => void,\n) {\n  if (isPromise(result)) {\n    result.then(\n      (r: any) => whenResultIsFinished(r, callback),\n      (err: Error) => callback(err),\n    );\n  } else if (Array.isArray(result)) {\n    if (result.some(isPromise)) {\n      Promise.all(result).then(\n        (r: any) => callback(null, r),\n        (err: Error) => callback(err),\n      );\n    } else {\n      callback(null, result);\n    }\n  } else {\n    callback(null, result);\n  }\n}\n"],"names":[],"mappings":";;;;;AAAA,MAAA;AAaa,QAAA,yCAAyC,GAAG,OACvD;AAEW,QAAA,uBAAuB,GAAG,OAAO;AAC9C,MAAM,uBAAuB,OAAO;AAEpC,SAAgB,gCACd,MAA4D;IAE5D,IAAI,iCAAiC,SAAS;QAC5C,OAAO;IACT;IACA,OAAO,cAAc,CAAC,QAAQ,sBAAsB;QAClD,OAAO;;IAGT,MAAM,UAAU,OAAO,UAAU;IACjC,OAAO,MAAM,CAAC,SAAS,OAAO,CAAC,CAAC;QAC9B,IACE,CAAC,CAAA,GAAA,UAAA,YAAY,EAAC,MAAM,IAAI,CAAC,UAAU,CAAC,SACpC,gBAAgB,UAAA,iBAAiB,EACjC;YACA,MAAM,SAAS,KAAK,SAAS;YAC7B,OAAO,MAAM,CAAC,QAAQ,OAAO,CAAC,CAAC;gBAC7B,UAAoB;YACtB;QACF;IACF;IAEA,OAAO;AACT;AAxBA,QAAA,+BAAA,GAAA;AA0BA,SAAgB,iCACd,MAA4D;IAE5D,OAAO,CAAC,CAAC,MAAM,CAAC,qBAAqB;AACvC;AAJA,QAAA,gCAAA,GAAA;AAMA,SAAS,UACP,KAA6B;IAE7B,MAAM,uBAAuB,MAAM,OAAO;IAE1C,MAAM,OAAO,GAAG,CAAC,QAAQ,MAAM,cAAc;QAC3C,MAAM,mBAAmB,cAAc,CACrC,QAAA,yCAAyC,CAG9B;QAEb,MAAM,oBAAoB,cAAc,CAAC,QAAA,uBAAuB,CAEnD;QAQb,MAAM,kBACJ,OAAO,qBAAqB,cAC5B,iBAAiB;YAAE;YAAQ;YAAM;YAAc;QAAI;QAErD,MAAM,gBACJ,wBAAwB,qBAAqB,UAAA,oBAAoB;QAEnE,IAAI;YACF,MAAM,SAAS,cAAc,QAAQ,MAAM,cAAc;YAKzD,IAAI,OAAO,oBAAoB,YAAY;gBACzC,qBAAqB,QAAQ;YAC/B;YACA,OAAO;QACT,EAAE,OAAO,OAAO;YAId,IAAI,OAAO,oBAAoB,YAAY;gBACzC,gBAAgB;YAClB;YACA,MAAM;QACR;IACF;AACF;AAEA,SAAS,UAAU,CAAM;IACvB,OAAO,KAAK,OAAO,EAAE,IAAI,KAAK;AAChC;AAMA,SAAgB,qBACd,MAAW,EACX,QAAmD;IAEnD,IAAI,UAAU,SAAS;QACrB,OAAO,IAAI,CACT,CAAC,IAAW,qBAAqB,GAAG,WACpC,CAAC,MAAe,SAAS;IAE7B,OAAO,IAAI,MAAM,OAAO,CAAC,SAAS;QAChC,IAAI,OAAO,IAAI,CAAC,YAAY;YAC1B,QAAQ,GAAG,CAAC,QAAQ,IAAI,CACtB,CAAC,IAAW,SAAS,MAAM,IAC3B,CAAC,MAAe,SAAS;QAE7B,OAAO;YACL,SAAS,MAAM;QACjB;IACF,OAAO;QACL,SAAS,MAAM;IACjB;AACF;AArBA,QAAA,oBAAA,GAAA"}},
    {"offset": {"line": 806, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 810, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@apollo/server/src/utils/isDefined.ts"],"sourcesContent":["export function isDefined<T>(t: T | undefined | null | void): t is T {\n  return t != null;\n}\n"],"names":[],"mappings":";;;;;AAAA,SAAgB,UAAa,CAA8B;IACzD,OAAO,KAAK;AACd;AAFA,QAAA,SAAA,GAAA"}},
    {"offset": {"line": 819, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 823, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@apollo/server/src/utils/invokeHooks.ts"],"sourcesContent":["import { isDefined } from './isDefined.js';\n\ntype AsyncDidEndHook<TArgs extends any[]> = (...args: TArgs) => Promise<void>;\ntype SyncDidEndHook<TArgs extends any[]> = (...args: TArgs) => void;\n\nexport async function invokeDidStartHook<T, TEndHookArgs extends unknown[]>(\n  targets: T[],\n  hook: (t: T) => Promise<AsyncDidEndHook<TEndHookArgs> | undefined | void>,\n): Promise<AsyncDidEndHook<TEndHookArgs>> {\n  const didEndHooks = (\n    await Promise.all(targets.map((target) => hook(target)))\n  ).filter(isDefined);\n\n  didEndHooks.reverse();\n\n  return async (...args: TEndHookArgs) => {\n    for (const didEndHook of didEndHooks) {\n      didEndHook(...args);\n    }\n  };\n}\n\n// Almost all hooks are async, but as a special case, willResolveField is sync\n// due to performance concerns.\nexport function invokeSyncDidStartHook<T, TEndHookArgs extends unknown[]>(\n  targets: T[],\n  hook: (t: T) => SyncDidEndHook<TEndHookArgs> | undefined | void,\n): SyncDidEndHook<TEndHookArgs> {\n  const didEndHooks: SyncDidEndHook<TEndHookArgs>[] = targets\n    .map((target) => hook(target))\n    .filter(isDefined);\n\n  didEndHooks.reverse();\n\n  return (...args: TEndHookArgs) => {\n    for (const didEndHook of didEndHooks) {\n      didEndHook(...args);\n    }\n  };\n}\n\nexport async function invokeHooksUntilDefinedAndNonNull<T, TOut>(\n  targets: T[],\n  hook: (t: T) => Promise<TOut | null | undefined>,\n): Promise<TOut | null> {\n  for (const target of targets) {\n    const value = await hook(target);\n    if (value != null) {\n      return value;\n    }\n  }\n  return null;\n}\n"],"names":[],"mappings":";;;;;AAAA,MAAA;AAKO,eAAe,mBACpB,OAAY,EACZ,IAAyE;IAEzE,MAAM,cAAc,CAClB,MAAM,QAAQ,GAAG,CAAC,QAAQ,GAAG,CAAC,CAAC,SAAW,KAAK,SAAS,EACxD,MAAM,CAAC,eAAA,SAAS;IAElB,YAAY,OAAO;IAEnB,OAAO,OAAO,GAAG;QACf,KAAK,MAAM,cAAc,YAAa;YACpC,cAAc;QAChB;IACF;AACF;AAfA,QAAA,kBAAA,GAAA;AAmBA,SAAgB,uBACd,OAAY,EACZ,IAA+D;IAE/D,MAAM,cAA8C,QACjD,GAAG,CAAC,CAAC,SAAW,KAAK,SACrB,MAAM,CAAC,eAAA,SAAS;IAEnB,YAAY,OAAO;IAEnB,OAAO,CAAC,GAAG;QACT,KAAK,MAAM,cAAc,YAAa;YACpC,cAAc;QAChB;IACF;AACF;AAfA,QAAA,sBAAA,GAAA;AAiBO,eAAe,kCACpB,OAAY,EACZ,IAAgD;IAEhD,KAAK,MAAM,UAAU,QAAS;QAC5B,MAAM,QAAQ,MAAM,KAAK;QACzB,IAAI,SAAS,MAAM;YACjB,OAAO;QACT;IACF;IACA,OAAO;AACT;AAXA,QAAA,iCAAA,GAAA"}},
    {"offset": {"line": 859, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 863, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@apollo/server/src/utils/makeGatewayGraphQLRequestContext.ts"],"sourcesContent":["import type {\n  GatewayGraphQLRequest,\n  GatewayGraphQLRequestContext,\n  GatewayGraphQLResponse,\n  GatewaySchemaHash,\n} from '@apollo/server-gateway-interface';\nimport type { FetcherHeaders } from '@apollo/utils.fetcher';\nimport type { ApolloServer, ApolloServerInternals } from '../ApolloServer';\nimport type {\n  BaseContext,\n  GraphQLRequestContextExecutionDidStart,\n} from '../externalTypes';\nimport type { HeaderMap } from './HeaderMap';\n\n// Apollo Gateway's API included `GraphQLRequestContext` from AS2/AS3.\n// Specifically, a request context is passed to the main executor method, which\n// it then exposes to user-configurable `GraphQLDataSource`s.\n// `GraphQLRequestContext` has changed in incompatible ways in AS4; for example,\n// we represent HTTP messages using our own data structures rather than Fetches,\n// and some fields have been removed because they relate to features that don't\n// exist any more.\n//\n// In general, the future of Apollo's development is in Apollo Router, not\n// Gateway. So rather than have a big transition where a new version of Gateway\n// supports AS4's GraphQLRequestContext instead of AS3's, we simply teach AS4\n// how to produce AS3-style GraphQLRequestContext objects specifically for use\n// by Gateway. We have changed Gateway to get its TS type definitions from a new\n// package rather than from AS3 itself, so that Gateway no longer needs to\n// depend on Apollo Server.\n//\n// This function turn an AS4 GraphQLRequestContext into a\n// GatewayGraphQLRequestContext (which is basically an AS3\n// GraphQLRequestContext).\n//\n// You might think that *after* invoking the executor, we would then need to\n// propagate any changes made by the gateway back onto the \"real\"\n// GraphQLRequestContext. It turns out that for each bit of data on the request\n// context, this is either unnecessary or impossible. (We don't need to support\n// use cases where people break type safe, eg by changing the values of readonly\n// fields.) Here's why:\n//\n// Many fields on GatewayGraphQLRequestContext are declared readonly and their\n// values are taken directly from the real GraphQLRequestContext. This means\n// that gateways should not change the field's value, and any mutations of the\n// object stored in the field (say, calling\n// `requestContext.overallCachePolicy.restrict`, as RemoteGraphQLDataSource\n// does) already take effect.\n//\n//  The only two fields not declared as readonly are `logger` and `debug`.\n//\n// Technically, a gateway implementation could set `requestContext.logger` to a\n// different Logger without breaking the TypeScript declarations. In AS4 we\n// don't actually have a requestContext.logger; we have `readonly\n// requestContext.server` and `readonly server.logger`. So there's not an easy\n// way for us to carry out this change: AS4 just doesn't let gateway or plugins\n// override the server's logger (and generally doesn't allow the logger to\n// change after the server is created), which seems like a simpler model. If it\n// turns out there is a real use case for the gateway to be able to change the\n// overall logger for the request as seen by plugins, we can fix that later.\n//\n// Similarly, it's not clear what the intended use case of mutating `debug` in\n// gateway would be. `debug` has now mostly changed into\n// `includeStacktraceInErrorResponses`. So perhaps this could be used to let you\n// decide whether or not to include the stacktrace on a per-operation basis...\n// but you can also use `formatError` or `didEncounterErrors` for this perhaps?\n// In any case, AS4 doesn't track `includeStacktraceInErrorResponses` on a\n// per-operation basis; if we find a use case for this we can add it later.\n//\n// So we'll just ignore changes to `logger` and `debug`.\n//\n// Next, there's `request`. We don't know of a use case for mutating the\n// *request* at execution time. If there was a real use case, we could add a\n// function that copies pieces back from the gateway `request` to the AS4\n// request, but we're not bothering to yet.\n//\n// Finally, there's `response`. Sure, the executor *could* mutate `response`.\n// But the main thing the executor is doing is *returning* a response, which\n// then semi-overwrites `requestContext.response` anyway. So it doesn't seem\n// like we need to support `executor` *also* overwriting response. Yet again, we\n// can fix this if it turns out it's necessary. (That said, the executor could\n// in theory write HTTP response headers or status, so we make sure to hook them\n// up directly to the appropriate data in the real GraphQLRequestContext.)\n//\n// So all in all, it looks like it's OK for this to be a \"one-way\" conversion.\nexport function makeGatewayGraphQLRequestContext<TContext extends BaseContext>(\n  as4RequestContext: GraphQLRequestContextExecutionDidStart<TContext>,\n  server: ApolloServer<TContext>,\n  internals: ApolloServerInternals<TContext>,\n): GatewayGraphQLRequestContext {\n  const request: GatewayGraphQLRequest = {};\n  if ('query' in as4RequestContext.request) {\n    request.query = as4RequestContext.request.query;\n  }\n  if ('operationName' in as4RequestContext.request) {\n    request.operationName = as4RequestContext.request.operationName;\n  }\n  if ('variables' in as4RequestContext.request) {\n    request.variables = as4RequestContext.request.variables;\n  }\n  if ('extensions' in as4RequestContext.request) {\n    request.extensions = as4RequestContext.request.extensions;\n  }\n  if (as4RequestContext.request.http) {\n    const as4http = as4RequestContext.request.http;\n    const needQuestion =\n      as4http.search !== '' && !as4http.search.startsWith('?');\n    request.http = {\n      method: as4http.method,\n      // As of AS4, we no longer attempt to track complete URLs (just the search\n      // parameters used in GET requests). So we have to fake them for Gateway.\n      url: `https://unknown-url.invalid/${needQuestion ? '?' : ''}${\n        as4http.search\n      }`,\n      headers: new FetcherHeadersForHeaderMap(as4http.headers),\n    };\n  }\n\n  const response: GatewayGraphQLResponse = {\n    http: {\n      headers: new FetcherHeadersForHeaderMap(\n        as4RequestContext.response.http.headers,\n      ),\n      get status() {\n        return as4RequestContext.response.http.status;\n      },\n      set status(newStatus) {\n        as4RequestContext.response.http.status = newStatus;\n      },\n    },\n    // We leave off `body` because it hasn't been set yet.\n  };\n\n  return {\n    request,\n    response,\n    logger: server.logger,\n    schema: as4RequestContext.schema,\n    // For the sake of typechecking, we still provide this field, but we don't\n    // calculate it. If somebody really needs it in their gateway\n    // implementation, they're welcome to copy\n    // https://github.com/apollographql/apollo-server/blob/3f218e78/packages/apollo-server-core/src/utils/schemaHash.ts\n    // into their code.\n    schemaHash:\n      'schemaHash no longer exists in Apollo Server 4' as GatewaySchemaHash,\n    context: as4RequestContext.contextValue,\n    cache: server.cache,\n    queryHash: as4RequestContext.queryHash,\n    document: as4RequestContext.document,\n    source: as4RequestContext.source,\n    operationName: as4RequestContext.operationName,\n    operation: as4RequestContext.operation,\n    errors: as4RequestContext.errors,\n    metrics: as4RequestContext.metrics,\n    debug: internals.includeStacktraceInErrorResponses,\n    overallCachePolicy: as4RequestContext.overallCachePolicy,\n    requestIsBatched: as4RequestContext.requestIsBatched,\n  };\n}\n\n// An implementation of the W3C-style headers class used by Gateway (and AS3),\n// backed by AS4's HeaderMap. Changes are written directly to the HeaderMap, so\n// any concurrent writes to the underlying HeaderMap (eg from a plugin) can be\n// seen immediately by the gateway and vice versa.\nclass FetcherHeadersForHeaderMap implements FetcherHeaders {\n  constructor(private map: HeaderMap) {}\n  append(name: string, value: string) {\n    if (this.map.has(name)) {\n      this.map.set(name, this.map.get(name) + ', ' + value);\n    } else {\n      this.map.set(name, value);\n    }\n  }\n  delete(name: string) {\n    this.map.delete(name);\n  }\n  get(name: string): string | null {\n    return this.map.get(name) ?? null;\n  }\n  has(name: string): boolean {\n    return this.map.has(name);\n  }\n  set(name: string, value: string) {\n    this.map.set(name, value);\n  }\n  entries(): Iterator<[string, string]> {\n    return this.map.entries();\n  }\n  keys(): Iterator<string> {\n    return this.map.keys();\n  }\n  values(): Iterator<string> {\n    return this.map.values();\n  }\n  [Symbol.iterator](): Iterator<[string, string]> {\n    return this.map.entries();\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 959, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 963, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@apollo/server/src/incrementalDeliveryPolyfill.ts"],"sourcesContent":["import {\n  execute,\n  type ExecutionArgs,\n  type ExecutionResult,\n  type GraphQLError,\n} from 'graphql';\n\n// This file \"polyfills\" graphql@17's experimentalExecuteIncrementally (by\n// returning a function that does not understand incremental directives if\n// you're using graphql@16). The types defined in this file are largely copied\n// from graphql-js.\n\ninterface ObjMap<T> {\n  [key: string]: T;\n}\nexport interface GraphQLExperimentalInitialIncrementalExecutionResult<\n  TData = ObjMap<unknown>,\n  TExtensions = ObjMap<unknown>,\n> extends ExecutionResult<TData, TExtensions> {\n  hasNext: boolean;\n  incremental?: ReadonlyArray<\n    GraphQLExperimentalIncrementalResult<TData, TExtensions>\n  >;\n  extensions?: TExtensions;\n}\n\nexport interface GraphQLExperimentalSubsequentIncrementalExecutionResult<\n  TData = ObjMap<unknown>,\n  TExtensions = ObjMap<unknown>,\n> {\n  hasNext: boolean;\n  incremental?: ReadonlyArray<\n    GraphQLExperimentalIncrementalResult<TData, TExtensions>\n  >;\n  extensions?: TExtensions;\n}\n\ntype GraphQLExperimentalIncrementalResult<\n  TData = ObjMap<unknown>,\n  TExtensions = ObjMap<unknown>,\n> =\n  | GraphQLExperimentalIncrementalDeferResult<TData, TExtensions>\n  | GraphQLExperimentalIncrementalStreamResult<TData, TExtensions>;\n\ninterface GraphQLExperimentalIncrementalDeferResult<\n  TData = ObjMap<unknown>,\n  TExtensions = ObjMap<unknown>,\n> extends ExecutionResult<TData, TExtensions> {\n  path?: ReadonlyArray<string | number>;\n  label?: string;\n}\n\ninterface GraphQLExperimentalIncrementalStreamResult<\n  TData = Array<unknown>,\n  TExtensions = ObjMap<unknown>,\n> {\n  errors?: ReadonlyArray<GraphQLError>;\n  items?: TData | null;\n  path?: ReadonlyArray<string | number>;\n  label?: string;\n  extensions?: TExtensions;\n}\n\nexport interface GraphQLExperimentalIncrementalExecutionResults<\n  TData = ObjMap<unknown>,\n  TExtensions = ObjMap<unknown>,\n> {\n  initialResult: GraphQLExperimentalInitialIncrementalExecutionResult<\n    TData,\n    TExtensions\n  >;\n  subsequentResults: AsyncGenerator<\n    GraphQLExperimentalSubsequentIncrementalExecutionResult<TData, TExtensions>,\n    void,\n    void\n  >;\n}\n\ntype PromiseOrValue<T> = Promise<T> | T;\n\n// This starts as undefined and is set to a function or null by running\n// tryToLoadGraphQL17(). If graphql-js 17 is installed, it is set to the\n// experimentalExecuteIncrementally function from that package; otherwise it is\n// set to null.\nlet graphqlExperimentalExecuteIncrementally:\n  | ((\n      args: ExecutionArgs,\n    ) => PromiseOrValue<\n      ExecutionResult | GraphQLExperimentalIncrementalExecutionResults\n    >)\n  | null\n  | undefined = undefined;\n\nasync function tryToLoadGraphQL17() {\n  if (graphqlExperimentalExecuteIncrementally !== undefined) {\n    return;\n  }\n  const graphql = await import('graphql');\n  if ('experimentalExecuteIncrementally' in graphql) {\n    graphqlExperimentalExecuteIncrementally = (graphql as any)\n      .experimentalExecuteIncrementally;\n  } else {\n    graphqlExperimentalExecuteIncrementally = null;\n  }\n}\n\nexport async function executeIncrementally(\n  args: ExecutionArgs,\n): Promise<ExecutionResult | GraphQLExperimentalIncrementalExecutionResults> {\n  await tryToLoadGraphQL17();\n  if (graphqlExperimentalExecuteIncrementally) {\n    return graphqlExperimentalExecuteIncrementally(args);\n  }\n  return execute(args);\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,MAAA;AAoFA,IAAI,0CAOY;AAEhB,eAAe;IACb,IAAI,4CAA4C,WAAW;QACzD;IACF;IACA,MAAM,UAAU,MAAA,QAAA,OAAA,GAAA,IAAA,CAAA,IAAA;IAChB,IAAI,sCAAsC,SAAS;QACjD,0CAA2C,QACxC,gCAAgC;IACrC,OAAO;QACL,0CAA0C;IAC5C;AACF;AAEO,eAAe,qBACpB,IAAmB;IAEnB,MAAM;IACN,IAAI,yCAAyC;QAC3C,OAAO,wCAAwC;IACjD;IACA,OAAO,CAAA,GAAA,UAAA,OAAO,EAAC;AACjB;AARA,QAAA,oBAAA,GAAA"}},
    {"offset": {"line": 1022, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1026, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@apollo/server/src/requestPipeline.ts"],"sourcesContent":["import { createHash } from '@apollo/utils.createhash';\nimport {\n  specifiedRules,\n  getOperationAST,\n  GraphQLError,\n  validate,\n  parse,\n  Kind,\n  type ExecutionResult,\n} from 'graphql';\nimport {\n  symbolExecutionDispatcherWillResolveField,\n  enablePluginsForSchemaResolvers,\n  symbolUserFieldResolver,\n} from './utils/schemaInstrumentation.js';\nimport {\n  PersistedQueryNotSupportedError,\n  PersistedQueryNotFoundError,\n  UserInputError,\n  BadRequestError,\n  ValidationError,\n  SyntaxError,\n  OperationResolutionError,\n} from './internalErrorClasses.js';\nimport {\n  ensureError,\n  normalizeAndFormatErrors,\n  ensureGraphQLError,\n} from './errorNormalize.js';\nimport type {\n  GraphQLRequestContext,\n  GraphQLRequestContextDidResolveSource,\n  GraphQLRequestContextExecutionDidStart,\n  GraphQLRequestContextResponseForOperation,\n  GraphQLRequestContextDidResolveOperation,\n  GraphQLRequestContextParsingDidStart,\n  GraphQLRequestContextValidationDidStart,\n  GraphQLRequestContextWillSendResponse,\n  GraphQLRequestContextDidEncounterErrors,\n  GraphQLRequestExecutionListener,\n  BaseContext,\n  GraphQLResponse,\n  GraphQLExperimentalFormattedSubsequentIncrementalExecutionResult,\n} from './externalTypes/index.js';\n\nimport {\n  invokeDidStartHook,\n  invokeHooksUntilDefinedAndNonNull,\n  invokeSyncDidStartHook,\n} from './utils/invokeHooks.js';\n\nimport { makeGatewayGraphQLRequestContext } from './utils/makeGatewayGraphQLRequestContext.js';\n\nimport { mergeHTTPGraphQLHead, newHTTPGraphQLHead } from './runHttpQuery.js';\nimport type {\n  ApolloServer,\n  ApolloServerInternals,\n  SchemaDerivedData,\n} from './ApolloServer.js';\nimport { isDefined } from './utils/isDefined.js';\nimport type {\n  GraphQLRequestContextDidEncounterSubsequentErrors,\n  GraphQLRequestContextWillSendSubsequentPayload,\n} from './externalTypes/requestPipeline.js';\nimport {\n  executeIncrementally,\n  type GraphQLExperimentalInitialIncrementalExecutionResult,\n  type GraphQLExperimentalSubsequentIncrementalExecutionResult,\n} from './incrementalDeliveryPolyfill.js';\nimport { HeaderMap } from './utils/HeaderMap.js';\n\nexport const APQ_CACHE_PREFIX = 'apq:';\n\nfunction computeQueryHash(query: string) {\n  return createHash('sha256').update(query).digest('hex');\n}\n\ntype Mutable<T> = { -readonly [P in keyof T]: T[P] };\n\nfunction isBadUserInputGraphQLError(error: GraphQLError): boolean {\n  return (\n    error.nodes?.length === 1 &&\n    error.nodes[0].kind === Kind.VARIABLE_DEFINITION &&\n    (error.message.startsWith(\n      `Variable \"$${error.nodes[0].variable.name.value}\" got invalid value `,\n    ) ||\n      error.message.startsWith(\n        `Variable \"$${error.nodes[0].variable.name.value}\" of required type `,\n      ) ||\n      error.message.startsWith(\n        `Variable \"$${error.nodes[0].variable.name.value}\" of non-null type `,\n      ))\n  );\n}\n\n// This is \"semi-formatted\" because the initial result has not yet been\n// formatted but the subsequent results \"have been\" --- in the sense that they\n// are an async iterable that will format them as they come in.\ntype SemiFormattedExecuteIncrementallyResults =\n  | {\n      singleResult: ExecutionResult;\n    }\n  | {\n      initialResult: GraphQLExperimentalInitialIncrementalExecutionResult;\n      subsequentResults: AsyncIterable<GraphQLExperimentalFormattedSubsequentIncrementalExecutionResult>;\n    };\n\nexport async function processGraphQLRequest<TContext extends BaseContext>(\n  schemaDerivedData: SchemaDerivedData,\n  server: ApolloServer<TContext>,\n  internals: ApolloServerInternals<TContext>,\n  requestContext: Mutable<GraphQLRequestContext<TContext>>,\n): Promise<GraphQLResponse> {\n  const requestListeners = (\n    await Promise.all(\n      internals.plugins.map((p) => p.requestDidStart?.(requestContext)),\n    )\n  ).filter(isDefined);\n\n  const request = requestContext.request;\n\n  let { query, extensions } = request;\n\n  let queryHash: string;\n\n  requestContext.metrics.persistedQueryHit = false;\n  requestContext.metrics.persistedQueryRegister = false;\n\n  if (extensions?.persistedQuery) {\n    // It looks like we've received a persisted query. Check if we\n    // support them.\n    if (!internals.persistedQueries) {\n      return await sendErrorResponse([new PersistedQueryNotSupportedError()]);\n    } else if (extensions.persistedQuery.version !== 1) {\n      return await sendErrorResponse([\n        new GraphQLError('Unsupported persisted query version', {\n          extensions: { http: newHTTPGraphQLHead(400) },\n        }),\n      ]);\n    }\n\n    queryHash = extensions.persistedQuery.sha256Hash;\n\n    if (query === undefined) {\n      query = await internals.persistedQueries.cache.get(queryHash);\n      if (query) {\n        requestContext.metrics.persistedQueryHit = true;\n      } else {\n        return await sendErrorResponse([new PersistedQueryNotFoundError()]);\n      }\n    } else {\n      const computedQueryHash = computeQueryHash(query);\n\n      // The provided hash must exactly match the SHA-256 hash of\n      // the query string. This prevents hash hijacking, where a\n      // new and potentially malicious query is associated with\n      // an existing hash.\n      if (queryHash !== computedQueryHash) {\n        return await sendErrorResponse([\n          new GraphQLError('provided sha does not match query', {\n            extensions: { http: newHTTPGraphQLHead(400) },\n          }),\n        ]);\n      }\n\n      // We won't write to the persisted query cache until later.\n      // Deferring the writing gives plugins the ability to \"win\" from use of\n      // the cache, but also have their say in whether or not the cache is\n      // written to (by interrupting the request with an error).\n      requestContext.metrics.persistedQueryRegister = true;\n    }\n  } else if (query) {\n    queryHash = computeQueryHash(query);\n  } else {\n    return await sendErrorResponse([\n      new BadRequestError(\n        'GraphQL operations must contain a non-empty `query` or a `persistedQuery` extension.',\n      ),\n    ]);\n  }\n\n  requestContext.queryHash = queryHash;\n  requestContext.source = query;\n\n  // Let the plugins know that we now have a STRING of what we hope will\n  // parse and validate into a document we can execute on.  Unless we have\n  // retrieved this from our APQ cache, there's no guarantee that it is\n  // syntactically correct, so this string should not be trusted as a valid\n  // document until after it's parsed and validated.\n  await Promise.all(\n    requestListeners.map(\n      (l) =>\n        l.didResolveSource?.(\n          requestContext as GraphQLRequestContextDidResolveSource<TContext>,\n        ),\n    ),\n  );\n\n  // If we're configured with a document store (by default, we are), we'll\n  // utilize the operation's hash to lookup the AST from the previously\n  // parsed-and-validated operation.  Failure to retrieve anything from the\n  // cache just means we're committed to doing the parsing and validation.\n  if (schemaDerivedData.documentStore) {\n    try {\n      requestContext.document = await schemaDerivedData.documentStore.get(\n        schemaDerivedData.documentStoreKeyPrefix + queryHash,\n      );\n    } catch (err: unknown) {\n      server.logger.warn(\n        'An error occurred while attempting to read from the documentStore. ' +\n          ensureError(err).message,\n      );\n    }\n  }\n\n  // If we still don't have a document, we'll need to parse and validate it.\n  // With success, we'll attempt to save it into the store for future use.\n  if (!requestContext.document) {\n    const parsingDidEnd = await invokeDidStartHook(\n      requestListeners,\n      async (l) =>\n        l.parsingDidStart?.(\n          requestContext as GraphQLRequestContextParsingDidStart<TContext>,\n        ),\n    );\n\n    try {\n      requestContext.document = parse(query, internals.parseOptions);\n    } catch (syntaxMaybeError: unknown) {\n      const error = ensureError(syntaxMaybeError);\n      await parsingDidEnd(error);\n      return await sendErrorResponse([\n        new SyntaxError(ensureGraphQLError(error)),\n      ]);\n    }\n    await parsingDidEnd();\n\n    if (internals.dangerouslyDisableValidation !== true) {\n      const validationDidEnd = await invokeDidStartHook(\n        requestListeners,\n        async (l) =>\n          l.validationDidStart?.(\n            requestContext as GraphQLRequestContextValidationDidStart<TContext>,\n          ),\n      );\n\n      const validationErrors = validate(\n        schemaDerivedData.schema,\n        requestContext.document,\n        [...specifiedRules, ...internals.validationRules],\n      );\n\n      if (validationErrors.length === 0) {\n        await validationDidEnd();\n      } else {\n        await validationDidEnd(validationErrors);\n        return await sendErrorResponse(\n          validationErrors.map((error) => new ValidationError(error)),\n        );\n      }\n    }\n\n    if (schemaDerivedData.documentStore) {\n      // The underlying cache store behind the `documentStore` returns a\n      // `Promise` which is resolved (or rejected), eventually, based on the\n      // success or failure (respectively) of the cache save attempt.  While\n      // it's certainly possible to `await` this `Promise`, we don't care about\n      // whether or not it's successful at this point.  We'll instead proceed\n      // to serve the rest of the request and just hope that this works out.\n      // If it doesn't work, the next request will have another opportunity to\n      // try again.  Errors will surface as warnings, as appropriate.\n      //\n      // While it shouldn't normally be necessary to wrap this `Promise` in a\n      // `Promise.resolve` invocation, it seems that the underlying cache store\n      // is returning a non-native `Promise` (e.g. Bluebird, etc.).\n      Promise.resolve(\n        schemaDerivedData.documentStore.set(\n          schemaDerivedData.documentStoreKeyPrefix + queryHash,\n          requestContext.document,\n        ),\n      ).catch((err) =>\n        server.logger.warn(\n          'Could not store validated document. ' + err?.message || err,\n        ),\n      );\n    }\n  }\n\n  // TODO: If we want to guarantee an operation has been set when invoking\n  // `willExecuteOperation` and executionDidStart`, we need to throw an\n  // error here and not leave this to `buildExecutionContext` in\n  // `graphql-js`.\n  const operation = getOperationAST(\n    requestContext.document,\n    request.operationName,\n  );\n\n  requestContext.operation = operation || undefined;\n  // We'll set `operationName` to `null` for anonymous operations.\n  requestContext.operationName = operation?.name?.value || null;\n\n  // Special case: GET operations should only be queries (not mutations). We\n  // want to throw a particular HTTP error in that case. (This matters because\n  // it's generally how HTTP requests should work, and additionally it makes us\n  // less vulnerable to mutations running over CSRF, if you turn off our CSRF\n  // prevention feature.)\n  if (\n    request.http?.method === 'GET' &&\n    operation?.operation &&\n    operation.operation !== 'query'\n  ) {\n    return await sendErrorResponse([\n      new BadRequestError(\n        `GET requests only support query operations, not ${operation.operation} operations`,\n        {\n          extensions: {\n            http: { status: 405, headers: new HeaderMap([['allow', 'POST']]) },\n          },\n        },\n      ),\n    ]);\n  }\n\n  try {\n    await Promise.all(\n      requestListeners.map(\n        (l) =>\n          l.didResolveOperation?.(\n            requestContext as GraphQLRequestContextDidResolveOperation<TContext>,\n          ),\n      ),\n    );\n  } catch (err: unknown) {\n    // Note that we explicitly document throwing `GraphQLError`s from\n    // `didResolveOperation` as a good way to do validation that depends on the\n    // validated operation and the request context. (It will have status 500 by\n    // default.)\n    return await sendErrorResponse([ensureGraphQLError(err)]);\n  }\n\n  // Now that we've gone through the pre-execution phases of the request\n  // pipeline, and given plugins appropriate ability to object (by throwing\n  // an error) and not actually write, we'll write to the cache if it was\n  // determined earlier in the request pipeline that we should do so.\n  if (\n    requestContext.metrics.persistedQueryRegister &&\n    internals.persistedQueries\n  ) {\n    // While it shouldn't normally be necessary to wrap this `Promise` in a\n    // `Promise.resolve` invocation, it seems that the underlying cache store\n    // is returning a non-native `Promise` (e.g. Bluebird, etc.).\n    const ttl = internals.persistedQueries?.ttl;\n    Promise.resolve(\n      internals.persistedQueries.cache.set(\n        queryHash,\n        query,\n        // Explicitly checking for `undefined` which means \"not set\" vs 0 or\n        // null which means \"no TTL\".\n        ttl !== undefined\n          ? { ttl: internals.persistedQueries?.ttl }\n          : undefined,\n      ),\n    ).catch(server.logger.warn);\n  }\n\n  const responseFromPlugin = await invokeHooksUntilDefinedAndNonNull(\n    requestListeners,\n    async (l) =>\n      await l.responseForOperation?.(\n        requestContext as GraphQLRequestContextResponseForOperation<TContext>,\n      ),\n  );\n  if (responseFromPlugin !== null) {\n    requestContext.response.body = responseFromPlugin.body;\n    mergeHTTPGraphQLHead(requestContext.response.http, responseFromPlugin.http);\n  } else {\n    const executionListeners = (\n      await Promise.all(\n        requestListeners.map(\n          (l) =>\n            l.executionDidStart?.(\n              requestContext as GraphQLRequestContextExecutionDidStart<TContext>,\n            ),\n        ),\n      )\n    ).filter(isDefined);\n    executionListeners.reverse();\n\n    if (executionListeners.some((l) => l.willResolveField)) {\n      // Create a callback that will trigger the execution dispatcher's\n      // `willResolveField` hook.  We will attach this to the context on a\n      // symbol so it can be invoked by our `wrapField` method during execution.\n      const invokeWillResolveField: GraphQLRequestExecutionListener<TContext>['willResolveField'] =\n        (...args) =>\n          invokeSyncDidStartHook(\n            executionListeners,\n            (l) => l.willResolveField?.(...args),\n          );\n\n      Object.defineProperty(\n        requestContext.contextValue,\n        symbolExecutionDispatcherWillResolveField,\n        { value: invokeWillResolveField },\n      );\n\n      // If the user has provided a custom field resolver, we will attach\n      // it to the context so we can still invoke it after we've wrapped the\n      // fields with `wrapField` within `enablePluginsForSchemaResolvers` of\n      // the `schemaInstrumentation` module.\n      if (internals.fieldResolver) {\n        Object.defineProperty(\n          requestContext.contextValue,\n          symbolUserFieldResolver,\n          {\n            value: internals.fieldResolver,\n          },\n        );\n      }\n\n      // If the schema is already enabled, this is a no-op.  Otherwise, the\n      // schema will be augmented so it is able to invoke willResolveField. Note\n      // that if we never see a plugin with willResolveField then we will never\n      // need to instrument the schema, which might be a small performance gain.\n      // (For example, this can happen if you pass `fieldLevelInstrumentation:\n      // () => false` to the usage reporting plugin and disable the cache\n      // control plugin. We can consider changing the cache control plugin to\n      // have a \"static cache control only\" mode that doesn't use\n      // willResolveField too if this proves to be helpful in practice.)\n      enablePluginsForSchemaResolvers(schemaDerivedData.schema);\n    }\n\n    try {\n      const fullResult = await execute(\n        requestContext as GraphQLRequestContextExecutionDidStart<TContext>,\n      );\n      const result =\n        'singleResult' in fullResult\n          ? fullResult.singleResult\n          : fullResult.initialResult;\n\n      // If we don't have an operation, there's no reason to go further. We know\n      // `result` will consist of one error (returned by `graphql-js`'s\n      // `buildExecutionContext`).\n      if (!requestContext.operation) {\n        if (!result.errors?.length) {\n          throw new Error(\n            'Unexpected error: Apollo Server did not resolve an operation but execute did not return errors',\n          );\n        }\n        throw new OperationResolutionError(result.errors[0]);\n      }\n\n      // The first thing that execution does is coerce the request's variables\n      // to the types declared in the operation, which can lead to errors if\n      // they are of the wrong type. It also makes sure that all non-null\n      // variables are required and get non-null values. If any of these things\n      // lead to errors, we change them into UserInputError so that their code\n      // doesn't end up being INTERNAL_SERVER_ERROR, since these are client\n      // errors. (But if the error already has a code, perhaps because the\n      // original error was thrown from a custom scalar parseValue, we leave it\n      // alone. We check that here instead of as part of\n      // isBadUserInputGraphQLError since perhaps that function will one day be\n      // changed to something we can get directly from graphql-js, but the\n      // `code` check is AS-specific.)\n      //\n      // This is hacky! Hopefully graphql-js will give us a way to separate\n      // variable resolution from execution later; see\n      // https://github.com/graphql/graphql-js/issues/3169\n      const resultErrors = result.errors?.map((e) => {\n        if (isBadUserInputGraphQLError(e) && e.extensions?.code == null) {\n          return new UserInputError(e);\n        }\n        return e;\n      });\n\n      if (resultErrors) {\n        await didEncounterErrors(resultErrors);\n      }\n\n      const { formattedErrors, httpFromErrors } = resultErrors\n        ? formatErrors(resultErrors)\n        : { formattedErrors: undefined, httpFromErrors: newHTTPGraphQLHead() };\n\n      // TODO(AS5) This becomes the default behavior and the\n      // `status400ForVariableCoercionErrors` configuration option is removed /\n      // ignored.\n      if (\n        internals.status400ForVariableCoercionErrors &&\n        resultErrors?.length &&\n        result.data === undefined &&\n        !httpFromErrors.status\n      ) {\n        httpFromErrors.status = 400;\n      }\n\n      mergeHTTPGraphQLHead(requestContext.response.http, httpFromErrors);\n\n      if ('singleResult' in fullResult) {\n        requestContext.response.body = {\n          kind: 'single',\n          singleResult: {\n            ...result,\n            errors: formattedErrors,\n          },\n        };\n      } else {\n        requestContext.response.body = {\n          kind: 'incremental',\n          initialResult: {\n            ...fullResult.initialResult,\n            errors: formattedErrors,\n          },\n          subsequentResults: fullResult.subsequentResults,\n        };\n      }\n    } catch (executionMaybeError: unknown) {\n      const executionError = ensureError(executionMaybeError);\n      await Promise.all(\n        executionListeners.map((l) => l.executionDidEnd?.(executionError)),\n      );\n\n      return await sendErrorResponse([ensureGraphQLError(executionError)]);\n    }\n\n    await Promise.all(executionListeners.map((l) => l.executionDidEnd?.()));\n  }\n\n  await invokeWillSendResponse();\n  if (!requestContext.response.body) {\n    throw Error('got to end of processGraphQLRequest without setting body?');\n  }\n  return requestContext.response as GraphQLResponse; // cast checked on previous line\n\n  async function execute(\n    requestContext: GraphQLRequestContextExecutionDidStart<TContext>,\n  ): Promise<SemiFormattedExecuteIncrementallyResults> {\n    const { request, document } = requestContext;\n\n    if (internals.__testing_incrementalExecutionResults) {\n      return internals.__testing_incrementalExecutionResults;\n    } else if (internals.gatewayExecutor) {\n      const result = await internals.gatewayExecutor(\n        makeGatewayGraphQLRequestContext(requestContext, server, internals),\n      );\n      return { singleResult: result };\n    } else {\n      const resultOrResults = await executeIncrementally({\n        schema: schemaDerivedData.schema,\n        document,\n        rootValue:\n          typeof internals.rootValue === 'function'\n            ? internals.rootValue(document)\n            : internals.rootValue,\n        contextValue: requestContext.contextValue,\n        variableValues: request.variables,\n        operationName: request.operationName,\n        fieldResolver: internals.fieldResolver,\n      });\n      if ('initialResult' in resultOrResults) {\n        return {\n          initialResult: resultOrResults.initialResult,\n          subsequentResults: formatErrorsInSubsequentResults(\n            resultOrResults.subsequentResults,\n          ),\n        };\n      } else {\n        return { singleResult: resultOrResults };\n      }\n    }\n  }\n\n  async function* formatErrorsInSubsequentResults(\n    results: AsyncIterable<GraphQLExperimentalSubsequentIncrementalExecutionResult>,\n  ): AsyncIterable<GraphQLExperimentalFormattedSubsequentIncrementalExecutionResult> {\n    for await (const result of results) {\n      const payload: GraphQLExperimentalFormattedSubsequentIncrementalExecutionResult =\n        result.incremental\n          ? {\n              ...result,\n              incremental: await seriesAsyncMap(\n                result.incremental,\n                async (incrementalResult) => {\n                  const { errors } = incrementalResult;\n                  if (errors) {\n                    await Promise.all(\n                      requestListeners.map(\n                        (l) =>\n                          l.didEncounterSubsequentErrors?.(\n                            requestContext as GraphQLRequestContextDidEncounterSubsequentErrors<TContext>,\n                            errors,\n                          ),\n                      ),\n                    );\n\n                    return {\n                      ...incrementalResult,\n                      // Note that any `http` extensions in errors have no\n                      // effect, because we've already sent the status code\n                      // and response headers.\n                      errors: formatErrors(errors).formattedErrors,\n                    };\n                  }\n                  return incrementalResult;\n                },\n              ),\n            }\n          : result;\n\n      // Invoke hook, which is allowed to mutate payload if it really wants to.\n      await Promise.all(\n        requestListeners.map(\n          (l) =>\n            l.willSendSubsequentPayload?.(\n              requestContext as GraphQLRequestContextWillSendSubsequentPayload<TContext>,\n              payload,\n            ),\n        ),\n      );\n\n      yield payload;\n    }\n  }\n\n  async function invokeWillSendResponse() {\n    await Promise.all(\n      requestListeners.map(\n        (l) =>\n          l.willSendResponse?.(\n            requestContext as GraphQLRequestContextWillSendResponse<TContext>,\n          ),\n      ),\n    );\n  }\n\n  // Note that we ensure that all calls to didEncounterErrors are followed by\n  // calls to willSendResponse. (The usage reporting plugin depends on this.)\n  async function didEncounterErrors(errors: ReadonlyArray<GraphQLError>) {\n    requestContext.errors = errors;\n\n    return await Promise.all(\n      requestListeners.map(\n        (l) =>\n          l.didEncounterErrors?.(\n            requestContext as GraphQLRequestContextDidEncounterErrors<TContext>,\n          ),\n      ),\n    );\n  }\n\n  // This function \"sends\" a response that contains errors and no data (not even\n  // `data: null`) because the pipeline does not make it to a successful\n  // `execute` call. (It is *not* called for execution that happens to return\n  // some errors.) In this case \"send\" means \"update requestContext.response and\n  // invoke willSendResponse hooks\".\n  //\n  // If any errors have `extensions.http` set, it sets the response's status code\n  // and errors from them.\n  //\n  // Then, if the HTTP status code is not yet set, it sets it to 500.\n  async function sendErrorResponse(\n    errors: ReadonlyArray<GraphQLError>,\n  ): Promise<GraphQLResponse> {\n    await didEncounterErrors(errors);\n\n    const { formattedErrors, httpFromErrors } = formatErrors(errors);\n\n    requestContext.response.body = {\n      kind: 'single',\n      singleResult: {\n        errors: formattedErrors,\n      },\n    };\n\n    mergeHTTPGraphQLHead(requestContext.response.http, httpFromErrors);\n\n    if (!requestContext.response.http.status) {\n      requestContext.response.http.status = 500;\n    }\n\n    await invokeWillSendResponse();\n\n    // cast safe because we assigned to `body` above\n    return requestContext.response as GraphQLResponse;\n  }\n\n  function formatErrors(\n    errors: ReadonlyArray<GraphQLError>,\n  ): ReturnType<typeof normalizeAndFormatErrors> {\n    return normalizeAndFormatErrors(errors, {\n      formatError: internals.formatError,\n      includeStacktraceInErrorResponses:\n        internals.includeStacktraceInErrorResponses,\n    });\n  }\n}\n\nasync function seriesAsyncMap<T, U>(\n  ts: readonly T[],\n  fn: (value: T) => Promise<U>,\n): Promise<U[]> {\n  const us: U[] = [];\n  for (const t of ts) {\n    const u = await fn(t);\n    us.push(u);\n  }\n  return us;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1339, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1343, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@apollo/server/src/utils/UnreachableCaseError.ts"],"sourcesContent":["/**\n * Throw this in places that should be unreachable (because all other cases have\n * been handled, reducing the type of the argument to `never`). TypeScript will\n * complain if in fact there is a valid type for the argument.\n */\nexport class UnreachableCaseError extends Error {\n  constructor(val: never) {\n    super(`Unreachable case: ${val}`);\n  }\n}\n"],"names":[],"mappings":";;;;;AAKA,MAAa,6BAA6B;IACxC,YAAY,GAAU,CAAA;QACpB,KAAK,CAAC,CAAA,kBAAA,EAAqB,IAAG,CAAE;IAClC;;AAHF,QAAA,oBAAA,GAAA"}},
    {"offset": {"line": 1354, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1358, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@apollo/server/src/utils/computeCoreSchemaHash.ts"],"sourcesContent":["import { createHash } from '@apollo/utils.createhash';\n\n// This hash function is used in both the schema reporting and usage reporting\n// plugins. Making sure we use the same hash function hypothetically allows the\n// two reporting features to work well together, though in practice nothing on\n// the Studio side currently correlates this ID across both features.\nexport function computeCoreSchemaHash(schema: string): string {\n  return createHash('sha256').update(schema).digest('hex');\n}\n"],"names":[],"mappings":";;;;;AAAA,MAAA;AAMA,SAAgB,sBAAsB,MAAc;IAClD,OAAO,CAAA,GAAA,mBAAA,UAAU,EAAC,UAAU,MAAM,CAAC,QAAQ,MAAM,CAAC;AACpD;AAFA,QAAA,qBAAA,GAAA"}},
    {"offset": {"line": 1368, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1372, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@apollo/server/src/utils/schemaManager.ts"],"sourcesContent":["import type { Logger } from '@apollo/utils.logger';\nimport type { GraphQLSchema } from 'graphql';\nimport type {\n  GatewayExecutor,\n  GatewayInterface,\n  GatewayUnsubscriber,\n} from '@apollo/server-gateway-interface';\nimport type { SchemaDerivedData } from '../ApolloServer.js';\nimport type {\n  ApolloConfig,\n  GraphQLSchemaContext,\n} from '../externalTypes/index.js';\n\ntype SchemaDerivedDataProvider = (\n  apiSchema: GraphQLSchema,\n) => SchemaDerivedData;\n\n/**\n * An async-safe class for tracking changes in schemas and schema-derived data.\n *\n * Specifically, as long as start() is called (and completes) before stop() is\n * called, any set of executions of public methods is linearizable.\n *\n * Note that linearizability in Javascript is trivial if all public methods are\n * non-async, but increasingly difficult to guarantee if public methods become\n * async. Accordingly, if you believe a public method should be async, think\n * carefully on whether it's worth the mental overhead. (E.g. if you wished that\n * a callback was async, consider instead resolving a Promise in a non-async\n * callback and having your async code wait on the Promise in setTimeout().)\n */\nexport class SchemaManager {\n  private readonly logger: Logger;\n  private readonly schemaDerivedDataProvider: SchemaDerivedDataProvider;\n  private readonly onSchemaLoadOrUpdateListeners = new Set<\n    (schemaContext: GraphQLSchemaContext) => void\n  >();\n  private isStopped = false;\n  private schemaDerivedData?: SchemaDerivedData;\n  private schemaContext?: GraphQLSchemaContext;\n\n  // For state that's specific to the mode of operation.\n  private readonly modeSpecificState:\n    | {\n        readonly mode: 'gateway';\n        readonly gateway: GatewayInterface;\n        readonly apolloConfig: ApolloConfig;\n        unsubscribeFromGateway?: GatewayUnsubscriber;\n      }\n    | {\n        readonly mode: 'schema';\n        readonly apiSchema: GraphQLSchema;\n        readonly schemaDerivedData: SchemaDerivedData;\n      };\n\n  constructor(\n    options: (\n      | { gateway: GatewayInterface; apolloConfig: ApolloConfig }\n      | { apiSchema: GraphQLSchema }\n    ) & {\n      logger: Logger;\n      schemaDerivedDataProvider: SchemaDerivedDataProvider;\n    },\n  ) {\n    this.logger = options.logger;\n    this.schemaDerivedDataProvider = options.schemaDerivedDataProvider;\n    if ('gateway' in options) {\n      this.modeSpecificState = {\n        mode: 'gateway',\n        gateway: options.gateway,\n        apolloConfig: options.apolloConfig,\n      };\n    } else {\n      this.modeSpecificState = {\n        mode: 'schema',\n        apiSchema: options.apiSchema,\n        // The caller of the constructor expects us to fail early if the schema\n        // given is invalid/has errors, so we call the provider here. We also\n        // pass the result to start(), as the provider can be expensive to call.\n        schemaDerivedData: options.schemaDerivedDataProvider(options.apiSchema),\n      };\n    }\n  }\n\n  /**\n   * Calling start() will:\n   * - Start gateway schema fetching (if a gateway was provided).\n   * - Initialize schema-derived data.\n   * - Synchronously notify onSchemaLoadOrUpdate() listeners of schema load, and\n   *   asynchronously notify them of schema updates.\n   * - If we started a gateway, returns the gateway's executor; otherwise null.\n   */\n  public async start(): Promise<GatewayExecutor | null> {\n    if (this.modeSpecificState.mode === 'gateway') {\n      const gateway = this.modeSpecificState.gateway;\n      if (gateway.onSchemaLoadOrUpdate) {\n        // Use onSchemaLoadOrUpdate, as it reports the core supergraph SDL and\n        // always reports the initial schema load.\n        this.modeSpecificState.unsubscribeFromGateway =\n          gateway.onSchemaLoadOrUpdate((schemaContext) => {\n            this.processSchemaLoadOrUpdateEvent(schemaContext);\n          });\n      } else {\n        throw new Error(\n          \"Unexpectedly couldn't find onSchemaLoadOrUpdate on gateway\",\n        );\n      }\n\n      const config = await this.modeSpecificState.gateway.load({\n        apollo: this.modeSpecificState.apolloConfig,\n      });\n\n      return config.executor;\n    } else {\n      this.processSchemaLoadOrUpdateEvent(\n        {\n          apiSchema: this.modeSpecificState.apiSchema,\n        },\n        this.modeSpecificState.schemaDerivedData,\n      );\n      return null;\n    }\n  }\n\n  /**\n   * Registers a listener for schema load/update events. Note that the latest\n   * event is buffered, i.e.\n   * - If registered before start(), this method will throw. (We have no need\n   *   for registration before start(), but this is easy enough to change.)\n   * - If registered after start() but before stop(), the callback will be first\n   *   called in this method (for whatever the current schema is), and then\n   *   later for updates.\n   * - If registered after stop(), the callback will never be called.\n   *\n   * For gateways, a core supergraph SDL will be provided to the callback.\n   *\n   * @param callback The listener to execute on schema load/updates.\n   */\n  public onSchemaLoadOrUpdate(\n    callback: (schemaContext: GraphQLSchemaContext) => void,\n  ): GatewayUnsubscriber {\n    if (!this.schemaContext) {\n      throw new Error('You must call start() before onSchemaLoadOrUpdate()');\n    }\n    if (!this.isStopped) {\n      try {\n        callback(this.schemaContext);\n      } catch (e) {\n        // Note that onSchemaLoadOrUpdate() is currently only called from\n        // ApolloServer._start(), so we throw here to alert the user early\n        // that their callback is failing.\n        throw new Error(\n          `An error was thrown from an 'onSchemaLoadOrUpdate' listener: ${\n            (e as Error).message\n          }`,\n        );\n      }\n    }\n    this.onSchemaLoadOrUpdateListeners.add(callback);\n\n    return () => {\n      this.onSchemaLoadOrUpdateListeners.delete(callback);\n    };\n  }\n\n  /**\n   * Get the schema-derived state for the current schema. This throws if called\n   * before start() is called.\n   */\n  public getSchemaDerivedData(): SchemaDerivedData {\n    if (!this.schemaDerivedData) {\n      throw new Error('You must call start() before getSchemaDerivedData()');\n    }\n    return this.schemaDerivedData;\n  }\n\n  /**\n   * Calling stop() will:\n   * - Stop gateway schema fetching (if a gateway was provided).\n   *   - Note that this specific step may not succeed if gateway is old.\n   * - Stop updating schema-derived data.\n   * - Stop notifying onSchemaLoadOrUpdate() listeners.\n   */\n  public async stop(): Promise<void> {\n    this.isStopped = true;\n    if (this.modeSpecificState.mode === 'gateway') {\n      this.modeSpecificState.unsubscribeFromGateway?.();\n      await this.modeSpecificState.gateway.stop?.();\n    }\n  }\n\n  private processSchemaLoadOrUpdateEvent(\n    schemaContext: GraphQLSchemaContext,\n    schemaDerivedData?: SchemaDerivedData,\n  ): void {\n    if (!this.isStopped) {\n      this.schemaDerivedData =\n        schemaDerivedData ??\n        this.schemaDerivedDataProvider(schemaContext.apiSchema);\n      this.schemaContext = schemaContext;\n      this.onSchemaLoadOrUpdateListeners.forEach((listener) => {\n        try {\n          listener(schemaContext);\n        } catch (e) {\n          this.logger.error(\n            \"An error was thrown from an 'onSchemaLoadOrUpdate' listener\",\n          );\n          this.logger.error(e);\n        }\n      });\n    }\n  }\n}\n"],"names":[],"mappings":";;;;;AA8BA,MAAa;IAwBX,YACE,OAMC,CAAA;QA5Bc,IAAA,CAAA,6BAA6B,GAAG,IAAI;QAG7C,IAAA,CAAA,SAAS,GAAG;QA2BlB,IAAI,CAAC,MAAM,GAAG,QAAQ,MAAM;QAC5B,IAAI,CAAC,yBAAyB,GAAG,QAAQ,yBAAyB;QAClE,IAAI,aAAa,SAAS;YACxB,IAAI,CAAC,iBAAiB,GAAG;gBACvB,MAAM;gBACN,SAAS,QAAQ,OAAO;gBACxB,cAAc,QAAQ,YAAY;;QAEtC,OAAO;YACL,IAAI,CAAC,iBAAiB,GAAG;gBACvB,MAAM;gBACN,WAAW,QAAQ,SAAS;gBAI5B,mBAAmB,QAAQ,yBAAyB,CAAC,QAAQ,SAAS;;QAE1E;IACF;IAUO,MAAM,QAAK;QAChB,IAAI,IAAI,CAAC,iBAAiB,CAAC,IAAI,KAAK,WAAW;YAC7C,MAAM,UAAU,IAAI,CAAC,iBAAiB,CAAC,OAAO;YAC9C,IAAI,QAAQ,oBAAoB,EAAE;gBAGhC,IAAI,CAAC,iBAAiB,CAAC,sBAAsB,GAC3C,QAAQ,oBAAoB,CAAC,CAAC;oBAC5B,IAAI,CAAC,8BAA8B,CAAC;gBACtC;YACJ,OAAO;gBACL,MAAM,IAAI,MACR;YAEJ;YAEA,MAAM,SAAS,MAAM,IAAI,CAAC,iBAAiB,CAAC,OAAO,CAAC,IAAI,CAAC;gBACvD,QAAQ,IAAI,CAAC,iBAAiB,CAAC,YAAY;;YAG7C,OAAO,OAAO,QAAQ;QACxB,OAAO;YACL,IAAI,CAAC,8BAA8B,CACjC;gBACE,WAAW,IAAI,CAAC,iBAAiB,CAAC,SAAS;eAE7C,IAAI,CAAC,iBAAiB,CAAC,iBAAiB;YAE1C,OAAO;QACT;IACF;IAgBO,qBACL,QAAuD,EAAA;QAEvD,IAAI,CAAC,IAAI,CAAC,aAAa,EAAE;YACvB,MAAM,IAAI,MAAM;QAClB;QACA,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE;YACnB,IAAI;gBACF,SAAS,IAAI,CAAC,aAAa;YAC7B,EAAE,OAAO,GAAG;gBAIV,MAAM,IAAI,MACR,CAAA,6DAAA,EACG,EAAY,OACf,CAAA,CAAE;YAEN;QACF;QACA,IAAI,CAAC,6BAA6B,CAAC,GAAG,CAAC;QAEvC,OAAO;YACL,IAAI,CAAC,6BAA6B,CAAC,MAAM,CAAC;QAC5C;IACF;IAMO,uBAAoB;QACzB,IAAI,CAAC,IAAI,CAAC,iBAAiB,EAAE;YAC3B,MAAM,IAAI,MAAM;QAClB;QACA,OAAO,IAAI,CAAC,iBAAiB;IAC/B;IASO,MAAM,OAAI;QACf,IAAI,CAAC,SAAS,GAAG;QACjB,IAAI,IAAI,CAAC,iBAAiB,CAAC,IAAI,KAAK,WAAW;YAC7C,IAAI,CAAC,iBAAiB,CAAC,sBAAsB;YAC7C,MAAM,IAAI,CAAC,iBAAiB,CAAC,OAAO,CAAC,IAAI;QAC3C;IACF;IAEQ,+BACN,aAAmC,EACnC,iBAAqC,EAAA;QAErC,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE;YACnB,IAAI,CAAC,iBAAiB,GACpB,qBACA,IAAI,CAAC,yBAAyB,CAAC,cAAc,SAAS;YACxD,IAAI,CAAC,aAAa,GAAG;YACrB,IAAI,CAAC,6BAA6B,CAAC,OAAO,CAAC,CAAC;gBAC1C,IAAI;oBACF,SAAS;gBACX,EAAE,OAAO,GAAG;oBACV,IAAI,CAAC,MAAM,CAAC,KAAK,CACf;oBAEF,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC;gBACpB;YACF;QACF;IACF;;AApLF,QAAA,aAAA,GAAA"}},
    {"offset": {"line": 1463, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1467, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@apollo/server/src/plugin/cacheControl/index.ts"],"sourcesContent":["import type { ApolloServerPlugin } from '../../externalTypes/index.js';\nimport {\n  type DirectiveNode,\n  getNamedType,\n  type GraphQLCompositeType,\n  type GraphQLField,\n  isCompositeType,\n  isInterfaceType,\n  isObjectType,\n  responsePathAsArray,\n} from 'graphql';\nimport { newCachePolicy } from '../../cachePolicy.js';\nimport { internalPlugin } from '../../internalPlugin.js';\nimport LRUCache from 'lru-cache';\nimport type {\n  CacheHint,\n  CacheScope,\n  GraphQLResolveInfoWithCacheControl,\n} from '@apollo/cache-control-types';\n\n/**\n * CacheAnnotation represents the contents of a `@cacheControl` directive.\n * (`inheritMaxAge` is part of this interface and not CacheHint, because\n * `inheritMaxAge` isn't a contributing piece of a cache policy: it just means\n * to not apply default values in some contexts.)\n */\ninterface CacheAnnotation extends CacheHint {\n  inheritMaxAge?: true;\n}\n\nexport interface ApolloServerPluginCacheControlOptions {\n  /**\n   * All root fields and fields returning objects or interfaces have this value\n   * for `maxAge` unless they set a cache hint with a non-undefined `maxAge`\n   * using `@cacheControl` or `setCacheHint`. The default is 0, which means \"not\n   * cacheable\". (That is: if you don't set `defaultMaxAge`, then every root\n   * field in your operation and every field with sub-fields must have a cache\n   * hint or the overall operation will not be cacheable.)\n   */\n  defaultMaxAge?: number;\n  /**\n   * Determines whether to set the `Cache-Control` HTTP header. If true (the\n   * default), the header is written on all responses (with a value of\n   * `no-store` for non-cacheable responses). If `'if-cacheable'`, the header is\n   * only written for cacheable responses. If false, the header is never\n   * written. A response is cacheable if its overall cache policy has a non-zero\n   * `maxAge`, and the body is a single result rather than an incremental\n   * delivery response, and the body contains no errors.\n   */\n  calculateHttpHeaders?: boolean | 'if-cacheable';\n  // For testing only.\n  __testing__cacheHints?: Map<string, CacheHint>;\n}\n\nexport function ApolloServerPluginCacheControl(\n  options: ApolloServerPluginCacheControlOptions = Object.create(null),\n): ApolloServerPlugin {\n  let typeAnnotationCache: LRUCache<GraphQLCompositeType, CacheAnnotation>;\n\n  let fieldAnnotationCache: LRUCache<\n    GraphQLField<unknown, unknown>,\n    CacheAnnotation\n  >;\n\n  return internalPlugin({\n    __internal_plugin_id__: 'CacheControl',\n    __is_disabled_plugin__: false,\n\n    async serverWillStart({ schema }) {\n      // Set the size of the caches to be equal to the number of composite types\n      // and fields in the schema respectively. This generally means that the\n      // cache will always have room for all the cache hints in the active\n      // schema but we won't have a memory leak as schemas are replaced in a\n      // gateway. (Once we're comfortable breaking compatibility with\n      // versions of Gateway older than 0.35.0, we should also run this code\n      // from a schemaDidLoadOrUpdate instead of serverWillStart. Using\n      // schemaDidLoadOrUpdate throws when combined with old gateways.)\n      typeAnnotationCache = new LRUCache<GraphQLCompositeType, CacheAnnotation>(\n        {\n          max: Object.values(schema.getTypeMap()).filter(isCompositeType)\n            .length,\n        },\n      );\n\n      fieldAnnotationCache = new LRUCache<\n        GraphQLField<unknown, unknown>,\n        CacheAnnotation\n      >({\n        max:\n          Object.values(schema.getTypeMap())\n            .filter(isObjectType)\n            .flatMap((t) => Object.values(t.getFields())).length +\n          Object.values(schema.getTypeMap())\n            .filter(isInterfaceType)\n            .flatMap((t) => Object.values(t.getFields())).length,\n      });\n\n      return undefined;\n    },\n\n    async requestDidStart(requestContext) {\n      function memoizedCacheAnnotationFromType(\n        t: GraphQLCompositeType,\n      ): CacheAnnotation {\n        const existing = typeAnnotationCache.get(t);\n        if (existing) {\n          return existing;\n        }\n        const annotation = cacheAnnotationFromType(t);\n        typeAnnotationCache.set(t, annotation);\n        return annotation;\n      }\n\n      function memoizedCacheAnnotationFromField(\n        field: GraphQLField<unknown, unknown>,\n      ): CacheAnnotation {\n        const existing = fieldAnnotationCache.get(field);\n        if (existing) {\n          return existing;\n        }\n        const annotation = cacheAnnotationFromField(field);\n        fieldAnnotationCache.set(field, annotation);\n        return annotation;\n      }\n\n      const defaultMaxAge: number = options.defaultMaxAge ?? 0;\n      const calculateHttpHeaders = options.calculateHttpHeaders ?? true;\n      const { __testing__cacheHints } = options;\n\n      return {\n        async executionDidStart() {\n          // Did something set the overall cache policy before we've even\n          // started? If so, consider that as an override and don't touch it.\n          // Just put set up fake `info.cacheControl` objects and otherwise\n          // don't track cache policy.\n          //\n          // (This doesn't happen in practice using the core plugins: the main\n          // use case for restricting overallCachePolicy outside of this plugin\n          // is apollo-server-plugin-response-cache, but when it sets the policy\n          // we never get to execution at all.)\n          if (isRestricted(requestContext.overallCachePolicy)) {\n            // This is \"fake\" in the sense that it never actually affects\n            // requestContext.overallCachePolicy.\n            const fakeFieldPolicy = newCachePolicy();\n            return {\n              willResolveField({ info }) {\n                // This `as` is \"safe\" in the sense that this is the statement\n                // that makes a GraphQLResolveInfo into a\n                // GraphQLResolveInfoWithCacheControl.\n                (info as GraphQLResolveInfoWithCacheControl).cacheControl = {\n                  setCacheHint: (dynamicHint: CacheHint) => {\n                    fakeFieldPolicy.replace(dynamicHint);\n                  },\n                  cacheHint: fakeFieldPolicy,\n                  cacheHintFromType: memoizedCacheAnnotationFromType,\n                };\n              },\n            };\n          }\n\n          return {\n            willResolveField({ info }) {\n              const fieldPolicy = newCachePolicy();\n\n              let inheritMaxAge = false;\n\n              // If this field's resolver returns an object/interface/union\n              // (maybe wrapped in list/non-null), look for hints on that return\n              // type.\n              const targetType = getNamedType(info.returnType);\n              if (isCompositeType(targetType)) {\n                const typeAnnotation =\n                  memoizedCacheAnnotationFromType(targetType);\n                fieldPolicy.replace(typeAnnotation);\n                inheritMaxAge = !!typeAnnotation.inheritMaxAge;\n              }\n\n              // Look for hints on the field itself (on its parent type), taking\n              // precedence over previously calculated hints.\n              const fieldAnnotation = memoizedCacheAnnotationFromField(\n                info.parentType.getFields()[info.fieldName],\n              );\n\n              // Note that specifying `@cacheControl(inheritMaxAge: true)` on a\n              // field whose return type defines a `maxAge` gives precedence to\n              // the type's `maxAge`. (Perhaps this should be some sort of\n              // error.)\n              if (\n                fieldAnnotation.inheritMaxAge &&\n                fieldPolicy.maxAge === undefined\n              ) {\n                inheritMaxAge = true;\n                // Handle `@cacheControl(inheritMaxAge: true, scope: PRIVATE)`.\n                // (We ignore any specified `maxAge`; perhaps it should be some\n                // sort of error.)\n                if (fieldAnnotation.scope) {\n                  fieldPolicy.replace({ scope: fieldAnnotation.scope });\n                }\n              } else {\n                fieldPolicy.replace(fieldAnnotation);\n              }\n\n              // This `as` is \"safe\" in the sense that this is the statement\n              // that makes a GraphQLResolveInfo into a\n              // GraphQLResolveInfoWithCacheControl.\n              (info as GraphQLResolveInfoWithCacheControl).cacheControl = {\n                setCacheHint: (dynamicHint: CacheHint) => {\n                  fieldPolicy.replace(dynamicHint);\n                },\n                cacheHint: fieldPolicy,\n                cacheHintFromType: memoizedCacheAnnotationFromType,\n              };\n\n              // When the resolver is done, call restrict once. By calling\n              // restrict after the resolver instead of before, we don't need to\n              // \"undo\" the effect on overallCachePolicy of a static hint that\n              // gets refined by a dynamic hint.\n              return () => {\n                // If this field returns a composite type or is a root field and\n                // we haven't seen an explicit maxAge hint, set the maxAge to 0\n                // (uncached) or the default if specified in the constructor.\n                // (Non-object fields by default are assumed to inherit their\n                // cacheability from their parents. But on the other hand, while\n                // root non-object fields can get explicit hints from their\n                // definition on the Query/Mutation object, if that doesn't\n                // exist then there's no parent field that would assign the\n                // default maxAge, so we do it here.)\n                //\n                // You can disable this on a non-root field by writing\n                // `@cacheControl(inheritMaxAge: true)` on it. If you do this,\n                // then its children will be treated like root paths, since\n                // there is no parent maxAge to inherit.\n                //\n                // We do this in the end hook so that dynamic cache control\n                // prevents it from happening (eg,\n                // `info.cacheControl.cacheHint.restrict({maxAge: 60})` should\n                // work rather than doing nothing because we've already set the\n                // max age to the default of 0). This also lets resolvers assume\n                // any hint in `info.cacheControl.cacheHint` was explicitly set.\n                if (\n                  fieldPolicy.maxAge === undefined &&\n                  ((isCompositeType(targetType) && !inheritMaxAge) ||\n                    !info.path.prev)\n                ) {\n                  fieldPolicy.restrict({ maxAge: defaultMaxAge });\n                }\n\n                if (__testing__cacheHints && isRestricted(fieldPolicy)) {\n                  const path = responsePathAsArray(info.path).join('.');\n                  if (__testing__cacheHints.has(path)) {\n                    throw Error(\n                      \"shouldn't happen: addHint should only be called once per path\",\n                    );\n                  }\n                  __testing__cacheHints.set(path, {\n                    maxAge: fieldPolicy.maxAge,\n                    scope: fieldPolicy.scope,\n                  });\n                }\n                requestContext.overallCachePolicy.restrict(fieldPolicy);\n              };\n            },\n          };\n        },\n\n        async willSendResponse(requestContext) {\n          // This hook is just for setting response headers, so make sure that\n          // hasn't been disabled.\n          if (!calculateHttpHeaders) {\n            return;\n          }\n\n          const { response, overallCachePolicy } = requestContext;\n\n          // Look to see if something has already set the cache-control header.\n          // This could be a different plugin... or it could be this very plugin\n          // operating on a different operation in the same batched HTTP\n          // request.\n          const existingCacheControlHeader = parseExistingCacheControlHeader(\n            response.http.headers.get('cache-control'),\n          );\n\n          // If the header contains something other than a value that this\n          // plugin sets, then we leave it alone. We don't want to mangle\n          // something important that you set! That said, it's probably best to\n          // have only one piece of code that writes to a given header, so you\n          // should probably set `calculateHttpHeaders: false` on this plugin.\n          if (existingCacheControlHeader.kind === 'unparsable') {\n            return;\n          }\n\n          const cachePolicy = newCachePolicy();\n          cachePolicy.replace(overallCachePolicy);\n          if (existingCacheControlHeader.kind === 'parsable-and-cacheable') {\n            cachePolicy.restrict(existingCacheControlHeader.hint);\n          }\n          const policyIfCacheable = cachePolicy.policyIfCacheable();\n\n          if (\n            // This code path is only for if we believe it is cacheable.\n            policyIfCacheable &&\n            // Either there wasn't a cache-control header already, or we've\n            // already incorporated it into policyIfCacheable. (If we couldn't\n            // parse it, that means some other plugin or mechanism set the\n            // header. This is confusing, so we just don't make any more\n            // changes. You should probably set `calculateHttpHeaders` to false\n            // in that case and only set the header from one place.)\n            existingCacheControlHeader.kind !== 'uncacheable' &&\n            // At least for now, we don't set cache-control headers for\n            // incremental delivery responses, since we don't know if a later\n            // part of the execution will affect the cache policy (perhaps\n            // dynamically). (Note that willSendResponse is called when the\n            // initial payload is sent, not the final payload.)\n            response.body.kind === 'single' &&\n            !response.body.singleResult.errors\n          ) {\n            response.http.headers.set(\n              'cache-control',\n              `max-age=${\n                policyIfCacheable.maxAge\n              }, ${policyIfCacheable.scope.toLowerCase()}`,\n            );\n          } else if (calculateHttpHeaders !== 'if-cacheable') {\n            // The response is not cacheable, so make sure it doesn't get\n            // cached. This is especially important for GET requests, because\n            // browsers and other agents cache many GET requests by default.\n            // (But if some other plugin set the header to a value that this\n            // plugin does not produce, we don't do anything.)\n            response.http.headers.set(\n              'cache-control',\n              CACHE_CONTROL_HEADER_UNCACHEABLE,\n            );\n          }\n        },\n      };\n    },\n  });\n}\n\nconst CACHE_CONTROL_HEADER_CACHEABLE_REGEXP =\n  /^max-age=(\\d+), (public|private)$/;\nconst CACHE_CONTROL_HEADER_UNCACHEABLE = 'no-store';\n\ntype ExistingCacheControlHeader =\n  | { kind: 'no-header' }\n  | { kind: 'uncacheable' }\n  | { kind: 'parsable-and-cacheable'; hint: CacheHint }\n  | { kind: 'unparsable' };\n\nfunction parseExistingCacheControlHeader(\n  header: string | undefined,\n): ExistingCacheControlHeader {\n  if (!header) {\n    return { kind: 'no-header' };\n  }\n  if (header === CACHE_CONTROL_HEADER_UNCACHEABLE) {\n    return { kind: 'uncacheable' };\n  }\n  const match = CACHE_CONTROL_HEADER_CACHEABLE_REGEXP.exec(header);\n  if (!match) {\n    return { kind: 'unparsable' };\n  }\n  return {\n    kind: 'parsable-and-cacheable',\n    hint: {\n      maxAge: +match[1],\n      scope: match[2] === 'public' ? 'PUBLIC' : 'PRIVATE',\n    },\n  };\n}\n\nfunction cacheAnnotationFromDirectives(\n  directives: ReadonlyArray<DirectiveNode> | undefined,\n): CacheAnnotation | undefined {\n  if (!directives) return undefined;\n\n  const cacheControlDirective = directives.find(\n    (directive) => directive.name.value === 'cacheControl',\n  );\n  if (!cacheControlDirective) return undefined;\n\n  if (!cacheControlDirective.arguments) return undefined;\n\n  const maxAgeArgument = cacheControlDirective.arguments.find(\n    (argument) => argument.name.value === 'maxAge',\n  );\n  const scopeArgument = cacheControlDirective.arguments.find(\n    (argument) => argument.name.value === 'scope',\n  );\n  const inheritMaxAgeArgument = cacheControlDirective.arguments.find(\n    (argument) => argument.name.value === 'inheritMaxAge',\n  );\n\n  const scopeString =\n    scopeArgument?.value?.kind === 'EnumValue'\n      ? scopeArgument.value.value\n      : undefined;\n\n  const scope: CacheScope | undefined =\n    scopeString === 'PUBLIC' || scopeString === 'PRIVATE'\n      ? scopeString\n      : undefined;\n\n  if (\n    inheritMaxAgeArgument?.value?.kind === 'BooleanValue' &&\n    inheritMaxAgeArgument.value.value\n  ) {\n    // We ignore maxAge if it is also specified.\n    return { inheritMaxAge: true, scope };\n  }\n\n  return {\n    maxAge:\n      maxAgeArgument?.value?.kind === 'IntValue'\n        ? parseInt(maxAgeArgument.value.value)\n        : undefined,\n    scope,\n  };\n}\n\nfunction cacheAnnotationFromType(t: GraphQLCompositeType): CacheAnnotation {\n  if (t.astNode) {\n    const hint = cacheAnnotationFromDirectives(t.astNode.directives);\n    if (hint) {\n      return hint;\n    }\n  }\n  if (t.extensionASTNodes) {\n    for (const node of t.extensionASTNodes) {\n      const hint = cacheAnnotationFromDirectives(node.directives);\n      if (hint) {\n        return hint;\n      }\n    }\n  }\n  return {};\n}\n\nfunction cacheAnnotationFromField(\n  field: GraphQLField<unknown, unknown>,\n): CacheAnnotation {\n  if (field.astNode) {\n    const hint = cacheAnnotationFromDirectives(field.astNode.directives);\n    if (hint) {\n      return hint;\n    }\n  }\n  return {};\n}\n\nfunction isRestricted(hint: CacheHint) {\n  return hint.maxAge !== undefined || hint.scope !== undefined;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1686, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1690, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@apollo/server/src/plugin/traceTreeBuilder.ts"],"sourcesContent":["// This class is a helper for ApolloServerPluginUsageReporting and\n// ApolloServerPluginInlineTrace.\nimport {\n  GraphQLError,\n  type GraphQLResolveInfo,\n  type ResponsePath,\n} from 'graphql';\nimport { Trace, google } from '@apollo/usage-reporting-protobuf';\nimport type { SendErrorsOptions } from './usageReporting';\nimport { UnreachableCaseError } from '../utils/UnreachableCaseError.js';\n\nfunction internalError(message: string) {\n  return new Error(`[internal apollo-server error] ${message}`);\n}\n\nexport class TraceTreeBuilder {\n  private rootNode = new Trace.Node();\n  public trace = new Trace({\n    root: this.rootNode,\n    // By default, each trace counts as one operation for the sake of field\n    // execution counts. If we end up calling the fieldLevelInstrumentation\n    // callback (once we've successfully resolved the operation) then we\n    // may set this to a higher number; but we'll start it at 1 so that traces\n    // that don't successfully resolve the operation (eg parse failures) or\n    // where we don't call the callback because a plugin set captureTraces to\n    // true have a reasonable default.\n    fieldExecutionWeight: 1,\n  });\n  public startHrTime?: [number, number];\n  private stopped = false;\n  private nodes = new Map<string, Trace.Node>([\n    [responsePathAsString(), this.rootNode],\n  ]);\n  private readonly transformError:\n    | ((err: GraphQLError) => GraphQLError | null)\n    | null;\n\n  public constructor(options: {\n    maskedBy: string;\n    sendErrors?: SendErrorsOptions;\n  }) {\n    const { sendErrors, maskedBy } = options;\n    if (!sendErrors || 'masked' in sendErrors) {\n      this.transformError = () =>\n        new GraphQLError('<masked>', {\n          extensions: { maskedBy },\n        });\n    } else if ('transform' in sendErrors) {\n      this.transformError = sendErrors.transform;\n    } else if ('unmodified' in sendErrors) {\n      this.transformError = null;\n    } else {\n      throw new UnreachableCaseError(sendErrors);\n    }\n  }\n\n  public startTiming() {\n    if (this.startHrTime) {\n      throw internalError('startTiming called twice!');\n    }\n    if (this.stopped) {\n      throw internalError('startTiming called after stopTiming!');\n    }\n    this.trace.startTime = dateToProtoTimestamp(new Date());\n    this.startHrTime = process.hrtime();\n  }\n\n  public stopTiming() {\n    if (!this.startHrTime) {\n      throw internalError('stopTiming called before startTiming!');\n    }\n    if (this.stopped) {\n      throw internalError('stopTiming called twice!');\n    }\n\n    this.trace.durationNs = durationHrTimeToNanos(\n      process.hrtime(this.startHrTime),\n    );\n    this.trace.endTime = dateToProtoTimestamp(new Date());\n    this.stopped = true;\n  }\n\n  public willResolveField(info: GraphQLResolveInfo): () => void {\n    if (!this.startHrTime) {\n      throw internalError('willResolveField called before startTiming!');\n    }\n    if (this.stopped) {\n      // We've been stopped, which means execution is done... and yet we're\n      // still resolving more fields? How can that be? Shouldn't we throw an\n      // error or something?\n      //\n      // Well... we used to do exactly that. But this \"shouldn't happen\" error\n      // showed up in practice! Turns out that graphql-js can actually continue\n      // to execute more fields indefinitely long after `execute()` resolves!\n      // That's because parallelism on a selection set is implemented using\n      // `Promise.all`, and as soon as one of its arguments (ie, one field)\n      // throws an error, the combined Promise resolves, but there's no\n      // \"cancellation\" of the Promises that are the other arguments to\n      // `Promise.all`. So the code contributing to those Promises keeps on\n      // chugging away indefinitely.\n      //\n      // Concrete example: lets say you have\n      //\n      //    { x y { ARBITRARY_SELECTION_SET } }\n      //\n      // where x has a non-null return type, and x and y both have resolvers\n      // that return Promises. And lets say that x returns a Promise that\n      // rejects (or resolves to null). What this means is that were going to\n      // eventually end up with `data: null` (nothing under y will actually\n      // matter), but graphql-js execution will continue running whatever is\n      // under ARBITRARY_SELECTION_SET without any sort of short circuiting. In\n      // fact, the Promise returned from execute itself can happily resolve\n      // while execution is still chugging away on an arbitrary amount of fields\n      // under that ARBITRARY_SELECTION_SET. Theres no way to detect from the\n      // outside \"all the execution related to this operation is done\", nor to\n      // \"short-circuit\" execution so that it stops going.\n      //\n      // So, um. We will record any field whose execution we manage to observe\n      // before we \"stop\" the TraceTreeBuilder (whether it is one that actually\n      // ends up in the response or whether it gets thrown away due to null\n      // bubbling), but if we get any more fields afterwards, we just ignore\n      // them rather than throwing a confusing error.\n      //\n      // (That said, the error we used to throw here generally was hidden\n      // anyway, for the same reason: it comes from a branch of execution that\n      // ends up not being included in the response. But\n      // https://github.com/graphql/graphql-js/pull/3529 means that this\n      // sometimes crashed execution anyway. Our error never caught any actual\n      // problematic cases, so keeping it around doesn't really help.)\n      return () => {};\n    }\n\n    const path = info.path;\n    const node = this.newNode(path);\n    node.type = info.returnType.toString();\n    node.parentType = info.parentType.toString();\n    node.startTime = durationHrTimeToNanos(process.hrtime(this.startHrTime));\n    if (typeof path.key === 'string' && path.key !== info.fieldName) {\n      // This field was aliased; send the original field name too (for FieldStats).\n      node.originalFieldName = info.fieldName;\n    }\n\n    return () => {\n      node.endTime = durationHrTimeToNanos(process.hrtime(this.startHrTime));\n    };\n  }\n\n  public didEncounterErrors(errors: readonly GraphQLError[]) {\n    errors.forEach((err) => {\n      // This is an error from a federated service. We will already be reporting\n      // it in the nested Trace in the query plan.\n      //\n      // XXX This probably shouldn't skip query or validation errors, which are\n      //      not in nested Traces because format() isn't called in this case! Or\n      //      maybe format() should be called in that case?\n      if (err.extensions?.serviceName) {\n        return;\n      }\n\n      // In terms of reporting, errors can be re-written by the user by\n      // utilizing the `transformError` parameter.  This allows changing\n      // the message or stack to remove potentially sensitive information.\n      // Returning `null` will result in the error not being reported at all.\n      const errorForReporting = this.transformAndNormalizeError(err);\n\n      if (errorForReporting === null) {\n        return;\n      }\n\n      this.addProtobufError(\n        errorForReporting.path,\n        errorToProtobufError(errorForReporting),\n      );\n    });\n  }\n\n  private addProtobufError(\n    path: ReadonlyArray<string | number> | undefined,\n    error: Trace.Error,\n  ) {\n    if (!this.startHrTime) {\n      throw internalError('addProtobufError called before startTiming!');\n    }\n    if (this.stopped) {\n      throw internalError('addProtobufError called after stopTiming!');\n    }\n\n    // By default, put errors on the root node.\n    let node = this.rootNode;\n    // If a non-GraphQLError Error sneaks in here somehow with a non-array\n    // path, don't crash.\n    if (Array.isArray(path)) {\n      const specificNode = this.nodes.get(path.join('.'));\n      if (specificNode) {\n        node = specificNode;\n      } else {\n        const responsePath = responsePathFromArray(path, this.rootNode);\n        if (!responsePath) {\n          throw internalError('addProtobufError called with invalid path!');\n        }\n        node = this.newNode(responsePath);\n      }\n    }\n\n    node.error.push(error);\n  }\n\n  private newNode(path: ResponsePath): Trace.Node {\n    const node = new Trace.Node();\n    const id = path.key;\n    if (typeof id === 'number') {\n      node.index = id;\n    } else {\n      node.responseName = id;\n    }\n    this.nodes.set(responsePathAsString(path), node);\n    const parentNode = this.ensureParentNode(path);\n    parentNode.child.push(node);\n    return node;\n  }\n\n  private ensureParentNode(path: ResponsePath): Trace.Node {\n    const parentPath = responsePathAsString(path.prev);\n    const parentNode = this.nodes.get(parentPath);\n    if (parentNode) {\n      return parentNode;\n    }\n    // Because we set up the root path when creating this.nodes, we now know\n    // that path.prev isn't undefined.\n    return this.newNode(path.prev!);\n  }\n\n  private transformAndNormalizeError(err: GraphQLError): GraphQLError | null {\n    if (this.transformError) {\n      // Before passing the error to the user-provided `transformError` function,\n      // we'll make a shadow copy of the error so the user is free to change\n      // the object as they see fit.\n\n      // At this stage, this error is only for the purposes of reporting, but\n      // this is even more important since this is still a reference to the\n      // original error object and changing it would also change the error which\n      // is returned in the response to the client.\n\n      // For the clone, we'll create a new object which utilizes the exact same\n      // prototype of the error being reported.\n      const clonedError = Object.assign(\n        Object.create(Object.getPrototypeOf(err)),\n        err,\n      );\n\n      const rewrittenError = this.transformError(clonedError);\n\n      // Returning an explicit `null` means the user is requesting that the error\n      // not be reported to Apollo.\n      if (rewrittenError === null) {\n        return null;\n      }\n\n      // We don't want users to be inadvertently not reporting errors, so if\n      // they haven't returned an explicit `GraphQLError` (or `null`, handled\n      // above), then we'll report the error as usual.\n      if (!(rewrittenError instanceof GraphQLError)) {\n        return err;\n      }\n\n      // We only allow transformError to change the message and extensions of the\n      // error; we keep everything else the same. That way people don't have to\n      // do extra work to keep the error on the same trace node. We also keep\n      // extensions the same if it isn't explicitly changed (to, eg, {}). (Note\n      // that many of the fields of GraphQLError are not enumerable and won't\n      // show up in the trace (even in the json field) anyway.)\n      return new GraphQLError(rewrittenError.message, {\n        nodes: err.nodes,\n        source: err.source,\n        positions: err.positions,\n        path: err.path,\n        originalError: err.originalError,\n        extensions: rewrittenError.extensions || err.extensions,\n      });\n    }\n    return err;\n  }\n}\n\n// Converts an hrtime array (as returned from process.hrtime) to nanoseconds.\n//\n// ONLY CALL THIS ON VALUES REPRESENTING DELTAS, NOT ON THE RAW RETURN VALUE\n// FROM process.hrtime() WITH NO ARGUMENTS.\n//\n// The entire point of the hrtime data structure is that the JavaScript Number\n// type can't represent all int64 values without loss of precision:\n// Number.MAX_SAFE_INTEGER nanoseconds is about 104 days. Calling this function\n// on a duration that represents a value less than 104 days is fine. Calling\n// this function on an absolute time (which is generally roughly time since\n// system boot) is not a good idea.\n//\n// XXX We should probably use google.protobuf.Duration on the wire instead of\n// ever trying to store durations in a single number.\nfunction durationHrTimeToNanos(hrtime: [number, number]) {\n  return hrtime[0] * 1e9 + hrtime[1];\n}\n\n// Convert from the linked-list ResponsePath format to a dot-joined\n// string. Includes the full path (field names and array indices).\nfunction responsePathAsString(p?: ResponsePath): string {\n  if (p === undefined) {\n    return '';\n  }\n\n  // A previous implementation used `responsePathAsArray` from `graphql-js/execution`,\n  // however, that employed an approach that created new arrays unnecessarily.\n  let res = String(p.key);\n\n  while ((p = p.prev) !== undefined) {\n    res = `${p.key}.${res}`;\n  }\n\n  return res;\n}\n\nfunction responsePathFromArray(\n  path: ReadonlyArray<string | number>,\n  node: Trace.Node,\n): ResponsePath | undefined {\n  let responsePath: ResponsePath | undefined;\n  let nodePtr: Trace.INode | undefined = node;\n  for (const key of path) {\n    nodePtr = nodePtr?.child?.find((child) => child.responseName === key);\n    responsePath = {\n      key,\n      prev: responsePath,\n      typename: nodePtr?.type ?? undefined,\n    };\n  }\n  return responsePath;\n}\n\nfunction errorToProtobufError(error: GraphQLError): Trace.Error {\n  return new Trace.Error({\n    message: error.message,\n    location: (error.locations || []).map(\n      ({ line, column }) => new Trace.Location({ line, column }),\n    ),\n    json: JSON.stringify(error),\n  });\n}\n\n// Converts a JS Date into a Timestamp.\nexport function dateToProtoTimestamp(date: Date): google.protobuf.Timestamp {\n  const totalMillis = +date;\n  const millis = totalMillis % 1000;\n  return new google.protobuf.Timestamp({\n    seconds: (totalMillis - millis) / 1000,\n    nanos: millis * 1e6,\n  });\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1893, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1897, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@apollo/server/src/plugin/usageReporting/iterateOverTrace.ts"],"sourcesContent":["import type { Trace } from '@apollo/usage-reporting-protobuf';\n\n/**\n * Iterates over the entire trace, calling `f` on each Trace.Node found. It\n * looks under the \"root\" node as well as any inside the query plan. If any `f`\n * returns true, it stops walking the tree.\n *\n * Each call to `f` will receive an object that implements ResponseNamePath. If\n * `includePath` is true, `f` can call `toArray()` on it to convert the\n * linked-list representation to an array of the response name (field name)\n * nodes that you navigate to get to the node (including a \"service:subgraph\"\n * top-level node if this is a federated trace). Note that we don't add anything\n * to the path for index (list element) nodes. This is because the only use case\n * we have (error path statistics) does not care about list indexes (it's not\n * that interesting to know that sometimes an error was at foo.3.bar and\n * sometimes foo.5.bar, vs just generally foo.bar).\n *\n * If `includePath` is false, we don't bother to build up the linked lists, and\n * calling `toArray()` will throw.\n */\nexport function iterateOverTrace(\n  trace: Trace,\n  f: (node: Trace.INode, path: ResponseNamePath) => boolean,\n  includePath: boolean,\n) {\n  const rootPath = includePath\n    ? new RootCollectingPathsResponseNamePath()\n    : notCollectingPathsResponseNamePath;\n  if (trace.root) {\n    if (iterateOverTraceNode(trace.root, rootPath, f)) return;\n  }\n\n  if (trace.queryPlan) {\n    if (iterateOverQueryPlan(trace.queryPlan, rootPath, f)) return;\n  }\n}\n\n// Helper for iterateOverTrace; returns true to stop the overall walk.\nfunction iterateOverQueryPlan(\n  node: Trace.IQueryPlanNode,\n  rootPath: ResponseNamePath,\n  f: (node: Trace.INode, path: ResponseNamePath) => boolean,\n): boolean {\n  if (!node) return false;\n\n  if (node.fetch?.trace?.root && node.fetch.serviceName) {\n    return iterateOverTraceNode(\n      node.fetch.trace.root,\n      rootPath.child(`service:${node.fetch.serviceName}`),\n      f,\n    );\n  }\n  if (node.flatten?.node) {\n    return iterateOverQueryPlan(node.flatten.node, rootPath, f);\n  }\n  if (node.parallel?.nodes) {\n    // We want to stop as soon as some call returns true, which happens to be\n    // exactly what 'some' does.\n    return node.parallel.nodes.some((node) =>\n      iterateOverQueryPlan(node, rootPath, f),\n    );\n  }\n  if (node.sequence?.nodes) {\n    // We want to stop as soon as some call returns true, which happens to be\n    // exactly what 'some' does.\n    return node.sequence.nodes.some((node) =>\n      iterateOverQueryPlan(node, rootPath, f),\n    );\n  }\n\n  return false;\n}\n\n// Helper for iterateOverTrace; returns true to stop the overall walk.\nfunction iterateOverTraceNode(\n  node: Trace.INode,\n  path: ResponseNamePath,\n  f: (node: Trace.INode, path: ResponseNamePath) => boolean,\n): boolean {\n  // Invoke the function; if it returns true, don't descend and tell callers to\n  // stop walking.\n  if (f(node, path)) {\n    return true;\n  }\n\n  return (\n    // We want to stop as soon as some call returns true, which happens to be\n    // exactly what 'some' does.\n    node.child?.some((child) => {\n      const childPath = child.responseName\n        ? path.child(child.responseName)\n        : path;\n      return iterateOverTraceNode(child, childPath, f);\n    }) ?? false\n  );\n}\n\nexport interface ResponseNamePath {\n  toArray(): string[];\n  child(responseName: string): ResponseNamePath;\n}\n\nconst notCollectingPathsResponseNamePath: ResponseNamePath = {\n  toArray() {\n    throw Error('not collecting paths!');\n  },\n  child() {\n    return this;\n  },\n};\n\ntype CollectingPathsResponseNamePath =\n  | RootCollectingPathsResponseNamePath\n  | ChildCollectingPathsResponseNamePath;\nclass RootCollectingPathsResponseNamePath implements ResponseNamePath {\n  toArray() {\n    return [];\n  }\n  child(responseName: string) {\n    return new ChildCollectingPathsResponseNamePath(responseName, this);\n  }\n}\nclass ChildCollectingPathsResponseNamePath implements ResponseNamePath {\n  constructor(\n    readonly responseName: string,\n    readonly prev: CollectingPathsResponseNamePath,\n  ) {}\n  toArray() {\n    const out = [];\n    let curr: CollectingPathsResponseNamePath = this;\n    while (curr instanceof ChildCollectingPathsResponseNamePath) {\n      out.push(curr.responseName);\n      curr = curr.prev;\n    }\n    return out.reverse();\n  }\n  child(responseName: string) {\n    return new ChildCollectingPathsResponseNamePath(responseName, this);\n  }\n}\n"],"names":[],"mappings":";;;;;AAoBA,SAAgB,iBACd,KAAY,EACZ,CAAyD,EACzD,WAAoB;IAEpB,MAAM,WAAW,cACb,IAAI,wCACJ;IACJ,IAAI,MAAM,IAAI,EAAE;QACd,IAAI,qBAAqB,MAAM,IAAI,EAAE,UAAU,IAAI;IACrD;IAEA,IAAI,MAAM,SAAS,EAAE;QACnB,IAAI,qBAAqB,MAAM,SAAS,EAAE,UAAU,IAAI;IAC1D;AACF;AAfA,QAAA,gBAAA,GAAA;AAkBA,SAAS,qBACP,IAA0B,EAC1B,QAA0B,EAC1B,CAAyD;IAEzD,IAAI,CAAC,MAAM,OAAO;IAElB,IAAI,KAAK,KAAK,EAAE,OAAO,QAAQ,KAAK,KAAK,CAAC,WAAW,EAAE;QACrD,OAAO,qBACL,KAAK,KAAK,CAAC,KAAK,CAAC,IAAI,EACrB,SAAS,KAAK,CAAC,CAAA,QAAA,EAAW,KAAK,KAAK,CAAC,WAAW,CAAA,CAAE,GAClD;IAEJ;IACA,IAAI,KAAK,OAAO,EAAE,MAAM;QACtB,OAAO,qBAAqB,KAAK,OAAO,CAAC,IAAI,EAAE,UAAU;IAC3D;IACA,IAAI,KAAK,QAAQ,EAAE,OAAO;QAGxB,OAAO,KAAK,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,OAC/B,qBAAqB,MAAM,UAAU;IAEzC;IACA,IAAI,KAAK,QAAQ,EAAE,OAAO;QAGxB,OAAO,KAAK,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,OAC/B,qBAAqB,MAAM,UAAU;IAEzC;IAEA,OAAO;AACT;AAGA,SAAS,qBACP,IAAiB,EACjB,IAAsB,EACtB,CAAyD;IAIzD,IAAI,EAAE,MAAM,OAAO;QACjB,OAAO;IACT;IAEA,OAGE,KAAK,KAAK,EAAE,KAAK,CAAC;QAChB,MAAM,YAAY,MAAM,YAAY,GAChC,KAAK,KAAK,CAAC,MAAM,YAAY,IAC7B;QACJ,OAAO,qBAAqB,OAAO,WAAW;IAChD,MAAM;AAEV;AAOA,MAAM,qCAAuD;IAC3D;QACE,MAAM,MAAM;IACd;IACA;QACE,OAAO,IAAI;IACb;;AAMF,MAAM;IACJ,UAAO;QACL,OAAO,EAAE;IACX;IACA,MAAM,YAAoB,EAAA;QACxB,OAAO,IAAI,qCAAqC,cAAc,IAAI;IACpE;;AAEF,MAAM;IACJ,YACW,YAAoB,EACpB,IAAqC,CAAA;QADrC,IAAA,CAAA,YAAY,GAAZ;QACA,IAAA,CAAA,IAAI,GAAJ;IACR;IACH,UAAO;QACL,MAAM,MAAM,EAAE;QACd,IAAI,OAAwC,IAAI;QAChD,MAAO,gBAAgB,qCAAsC;YAC3D,IAAI,IAAI,CAAC,KAAK,YAAY;YAC1B,OAAO,KAAK,IAAI;QAClB;QACA,OAAO,IAAI,OAAO;IACpB;IACA,MAAM,YAAoB,EAAA;QACxB,OAAO,IAAI,qCAAqC,cAAc,IAAI;IACpE"}},
    {"offset": {"line": 1971, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1975, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@apollo/server/src/plugin/usageReporting/durationHistogram.ts"],"sourcesContent":["export interface DurationHistogramOptions {\n  initSize?: number;\n  buckets?: number[];\n}\nexport class DurationHistogram {\n  // Note that it's legal for the values in \"buckets\" to be non-integers; they\n  // will be floored by toArray (which is called by the protobuf encoder).\n  // (We take advantage of this for field latencies specifically, because\n  // the ability to return a non-1 weight from fieldLevelInstrumentation\n  // means we want to build up our histograms as floating-point rather than\n  // rounding after every operation.)\n  private readonly buckets: number[];\n  static readonly BUCKET_COUNT = 384;\n  static readonly EXPONENT_LOG = Math.log(1.1);\n\n  toArray(): number[] {\n    let bufferedZeroes = 0;\n    const outputArray: number[] = [];\n\n    for (const value of this.buckets) {\n      if (value === 0) {\n        bufferedZeroes++;\n      } else {\n        if (bufferedZeroes === 1) {\n          outputArray.push(0);\n        } else if (bufferedZeroes !== 0) {\n          outputArray.push(-bufferedZeroes);\n        }\n        outputArray.push(Math.floor(value));\n        bufferedZeroes = 0;\n      }\n    }\n    return outputArray;\n  }\n\n  static durationToBucket(durationNs: number): number {\n    const log = Math.log(durationNs / 1000.0);\n    const unboundedBucket = Math.ceil(log / DurationHistogram.EXPONENT_LOG);\n\n    // Compare <= 0 to catch -0 and -infinity\n    return unboundedBucket <= 0 || Number.isNaN(unboundedBucket)\n      ? 0\n      : unboundedBucket >= DurationHistogram.BUCKET_COUNT\n        ? DurationHistogram.BUCKET_COUNT - 1\n        : unboundedBucket;\n  }\n\n  incrementDuration(durationNs: number, value = 1): DurationHistogram {\n    this.incrementBucket(DurationHistogram.durationToBucket(durationNs), value);\n    return this;\n  }\n\n  incrementBucket(bucket: number, value = 1) {\n    if (bucket >= DurationHistogram.BUCKET_COUNT) {\n      // Since we don't have fixed size arrays I'd rather throw the error manually\n      throw Error('Bucket is out of bounds of the buckets array');\n    }\n\n    // Extend the array if we haven't gotten it long enough to handle the new bucket\n    if (bucket >= this.buckets.length) {\n      const oldLength = this.buckets.length;\n      this.buckets.length = bucket + 1;\n      this.buckets.fill(0, oldLength);\n    }\n\n    this.buckets[bucket] += value;\n  }\n\n  combine(otherHistogram: DurationHistogram) {\n    for (let i = 0; i < otherHistogram.buckets.length; i++) {\n      this.incrementBucket(i, otherHistogram.buckets[i]);\n    }\n  }\n\n  constructor(options?: DurationHistogramOptions) {\n    const initSize = options?.initSize || 74;\n    const buckets = options?.buckets;\n\n    const arrayInitSize = Math.max(buckets?.length || 0, initSize);\n\n    this.buckets = Array<number>(arrayInitSize).fill(0);\n\n    if (buckets) {\n      buckets.forEach((val, index) => (this.buckets[index] = val));\n    }\n  }\n}\n"],"names":[],"mappings":";;;;;AAIA,MAAa;IAWX,UAAO;QACL,IAAI,iBAAiB;QACrB,MAAM,cAAwB,EAAE;QAEhC,KAAK,MAAM,SAAS,IAAI,CAAC,OAAO,CAAE;YAChC,IAAI,UAAU,GAAG;gBACf;YACF,OAAO;gBACL,IAAI,mBAAmB,GAAG;oBACxB,YAAY,IAAI,CAAC;gBACnB,OAAO,IAAI,mBAAmB,GAAG;oBAC/B,YAAY,IAAI,CAAC,CAAC;gBACpB;gBACA,YAAY,IAAI,CAAC,KAAK,KAAK,CAAC;gBAC5B,iBAAiB;YACnB;QACF;QACA,OAAO;IACT;IAEA,OAAO,iBAAiB,UAAkB,EAAA;QACxC,MAAM,MAAM,KAAK,GAAG,CAAC,aAAa;QAClC,MAAM,kBAAkB,KAAK,IAAI,CAAC,MAAM,kBAAkB,YAAY;QAGtE,OAAO,mBAAmB,KAAK,OAAO,KAAK,CAAC,mBACxC,IACA,mBAAmB,kBAAkB,YAAY,GAC/C,kBAAkB,YAAY,GAAG,IACjC;IACR;IAEA,kBAAkB,UAAkB,EAAE,QAAQ,CAAC,EAAA;QAC7C,IAAI,CAAC,eAAe,CAAC,kBAAkB,gBAAgB,CAAC,aAAa;QACrE,OAAO,IAAI;IACb;IAEA,gBAAgB,MAAc,EAAE,QAAQ,CAAC,EAAA;QACvC,IAAI,UAAU,kBAAkB,YAAY,EAAE;YAE5C,MAAM,MAAM;QACd;QAGA,IAAI,UAAU,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE;YACjC,MAAM,YAAY,IAAI,CAAC,OAAO,CAAC,MAAM;YACrC,IAAI,CAAC,OAAO,CAAC,MAAM,GAAG,SAAS;YAC/B,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG;QACvB;QAEA,IAAI,CAAC,OAAO,CAAC,OAAO,IAAI;IAC1B;IAEA,QAAQ,cAAiC,EAAA;QACvC,IAAK,IAAI,IAAI,GAAG,IAAI,eAAe,OAAO,CAAC,MAAM,EAAE,IAAK;YACtD,IAAI,CAAC,eAAe,CAAC,GAAG,eAAe,OAAO,CAAC,EAAE;QACnD;IACF;IAEA,YAAY,OAAkC,CAAA;QAC5C,MAAM,WAAW,SAAS,YAAY;QACtC,MAAM,UAAU,SAAS;QAEzB,MAAM,gBAAgB,KAAK,GAAG,CAAC,SAAS,UAAU,GAAG;QAErD,IAAI,CAAC,OAAO,GAAG,MAAc,eAAe,IAAI,CAAC;QAEjD,IAAI,SAAS;YACX,QAAQ,OAAO,CAAC,CAAC,KAAK,QAAW,IAAI,CAAC,OAAO,CAAC,MAAM,GAAG;QACzD;IACF;;AAjFF,QAAA,iBAAA,GAAA;AAQkB,kBAAA,YAAY,GAAG;AACf,kBAAA,YAAY,GAAG,KAAK,GAAG,CAAC"}},
    {"offset": {"line": 2037, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2041, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@apollo/server/src/plugin/usageReporting/defaultSendOperationsAsTrace.ts"],"sourcesContent":["import LRUCache from 'lru-cache';\nimport type { Trace } from '@apollo/usage-reporting-protobuf';\nimport { iterateOverTrace } from './iterateOverTrace.js';\nimport { DurationHistogram } from './durationHistogram.js';\n\nexport function defaultSendOperationsAsTrace() {\n  // We keep an LRU cache mapping from a trace key (which consists of the\n  // operation as defined by statsReportKey, the rough duration of the\n  // operation, what minute the operation ended at, etc) to `true` if we've seen\n  // it recently. We actually split this into one cache per minute so we can\n  // throw away a full minute's worth of cache at once; we keep only the last\n  // three minutes.\n  // Note that if a trace is over a certain size, we will always send it as\n  // stats. We check this within the addTrace function of the OurReport class so\n  // that we don't have to encode these large traces twice.\n  const cache = new LRUCache<string, true>({\n    // 3MiB limit, very much approximately since we can't be sure how V8 might\n    // be storing these strings internally. Though this should be enough to\n    // store a fair amount of trace keys.\n\n    // A future version of this might expose some\n    // configuration option to grow the cache, but ideally, we could do that\n    // dynamically based on the resources available to the server, and not add\n    // more configuration surface area. Hopefully the warning message will allow\n    // us to evaluate the need with more validated input from those that receive\n    // it.\n    maxSize: Math.pow(2, 20),\n    sizeCalculation: (_val, key) => {\n      return (key && Buffer.byteLength(key)) || 0;\n    },\n  });\n\n  return (trace: Trace, statsReportKey: string): boolean => {\n    const endTimeSeconds = trace.endTime?.seconds;\n    if (endTimeSeconds == null) {\n      throw Error('programming error: endTime not set on trace');\n    }\n\n    const hasErrors = traceHasErrors(trace);\n    const cacheKey = JSON.stringify([\n      statsReportKey,\n      DurationHistogram.durationToBucket(trace.durationNs),\n      // What minute it started at\n      Math.floor(endTimeSeconds / 60),\n      // If the trace has an error, send one errored trace per 5 second interval\n      // instead of the normal minutely bucket a non-errored trace takes.\n      hasErrors ? Math.floor(endTimeSeconds / 5) : '',\n    ]);\n\n    // If we've already seen something roughly like this, don't send as a trace.\n    if (cache.get(cacheKey)) {\n      return false;\n    }\n\n    cache.set(cacheKey, true);\n    return true;\n  };\n}\n\n// Returns true if any node on the trace has errors. (If this ends up being a\n// hot spot, we can precalculate it in TraceTreeBuilder.)\nfunction traceHasErrors(trace: Trace): boolean {\n  let hasErrors = false;\n\n  function traceNodeStats(node: Trace.INode): boolean {\n    if ((node.error?.length ?? 0) > 0) {\n      hasErrors = true;\n    }\n    return hasErrors;\n  }\n\n  iterateOverTrace(trace, traceNodeStats, false);\n  return hasErrors;\n}\n"],"names":[],"mappings":";;;;;;;;;;AAAA,MAAA,cAAA;AAEA,MAAA;AACA,MAAA;AAEA,SAAgB;IAUd,MAAM,QAAQ,IAAI,YAAA,OAAQ,CAAe;QAWvC,SAAS,KAAK,GAAG,CAAC,GAAG;QACrB,iBAAiB,CAAC,MAAM;YACtB,OAAO,AAAC,OAAO,OAAO,UAAU,CAAC,QAAS;QAC5C;;IAGF,OAAO,CAAC,OAAc;QACpB,MAAM,iBAAiB,MAAM,OAAO,EAAE;QACtC,IAAI,kBAAkB,MAAM;YAC1B,MAAM,MAAM;QACd;QAEA,MAAM,YAAY,eAAe;QACjC,MAAM,WAAW,KAAK,SAAS,CAAC;YAC9B;YACA,uBAAA,iBAAiB,CAAC,gBAAgB,CAAC,MAAM,UAAU;YAEnD,KAAK,KAAK,CAAC,iBAAiB;YAG5B,YAAY,KAAK,KAAK,CAAC,iBAAiB,KAAK;SAC9C;QAGD,IAAI,MAAM,GAAG,CAAC,WAAW;YACvB,OAAO;QACT;QAEA,MAAM,GAAG,CAAC,UAAU;QACpB,OAAO;IACT;AACF;AApDA,QAAA,4BAAA,GAAA;AAwDA,SAAS,eAAe,KAAY;IAClC,IAAI,YAAY;IAEhB,SAAS,eAAe,IAAiB;QACvC,IAAI,CAAC,KAAK,KAAK,EAAE,UAAU,CAAC,IAAI,GAAG;YACjC,YAAY;QACd;QACA,OAAO;IACT;IAEA,CAAA,GAAA,sBAAA,gBAAgB,EAAC,OAAO,gBAAgB;IACxC,OAAO;AACT"}},
    {"offset": {"line": 2092, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2096, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@apollo/server/src/plugin/usageReporting/operationDerivedDataCache.ts"],"sourcesContent":["import type { Logger } from '@apollo/utils.logger';\nimport type { ReferencedFieldsByType } from '@apollo/utils.usagereporting';\nimport LRUCache from 'lru-cache';\n\nexport interface OperationDerivedData {\n  signature: string;\n  referencedFieldsByType: ReferencedFieldsByType;\n}\n\nexport function createOperationDerivedDataCache({\n  logger,\n}: {\n  logger: Logger;\n}): LRUCache<string, OperationDerivedData> {\n  let lastWarn: Date;\n  let lastDisposals = 0;\n  return new LRUCache<string, OperationDerivedData>({\n    // Calculate the length of cache objects by the JSON.stringify byteLength.\n    sizeCalculation(obj) {\n      return Buffer.byteLength(JSON.stringify(obj), 'utf8');\n    },\n    // 10MiB limit, very much approximately since we can't be sure how V8 might\n    // be storing this data internally. Though this should be enough to store a\n    // fair amount of operation data, depending on their overall complexity. A\n    // future version of this might expose some configuration option to grow the\n    // cache, but ideally, we could do that dynamically based on the resources\n    // available to the server, and not add more configuration surface area.\n    // Hopefully the warning message will allow us to evaluate the need with\n    // more validated input from those that receive it.\n    maxSize: Math.pow(2, 20) * 10,\n    dispose() {\n      // Count the number of disposals between warning messages.\n      lastDisposals++;\n\n      // Only show a message warning about the high turnover every 60 seconds.\n      if (!lastWarn || new Date().getTime() - lastWarn.getTime() > 60000) {\n        // Log the time that we last displayed the message.\n        lastWarn = new Date();\n        logger.warn(\n          [\n            'This server is processing a high number of unique operations.  ',\n            `A total of ${lastDisposals} records have been `,\n            'ejected from the ApolloServerPluginUsageReporting signature cache in the past ',\n            'interval.  If you see this warning frequently, please open an ',\n            'issue on the Apollo Server repository.',\n          ].join(''),\n        );\n\n        // Reset the disposal counter for the next message interval.\n        lastDisposals = 0;\n      }\n    },\n  });\n}\n\nexport function operationDerivedDataCacheKey(\n  queryHash: string,\n  operationName: string,\n) {\n  return `${queryHash}${operationName && ':' + operationName}`;\n}\n"],"names":[],"mappings":";;;;;;;;;;AAEA,MAAA,cAAA;AAOA,SAAgB,gCAAgC,EAC9C,MAAM,EAGP;IACC,IAAI;IACJ,IAAI,gBAAgB;IACpB,OAAO,IAAI,YAAA,OAAQ,CAA+B;QAEhD,iBAAgB,GAAG;YACjB,OAAO,OAAO,UAAU,CAAC,KAAK,SAAS,CAAC,MAAM;QAChD;QASA,SAAS,KAAK,GAAG,CAAC,GAAG,MAAM;QAC3B;YAEE;YAGA,IAAI,CAAC,YAAY,IAAI,OAAO,OAAO,KAAK,SAAS,OAAO,KAAK,OAAO;gBAElE,WAAW,IAAI;gBACf,OAAO,IAAI,CACT;oBACE;oBACA,CAAA,WAAA,EAAc,cAAa,mBAAA,CAAqB;oBAChD;oBACA;oBACA;iBACD,CAAC,IAAI,CAAC;gBAIT,gBAAgB;YAClB;QACF;;AAEJ;AA5CA,QAAA,+BAAA,GAAA;AA8CA,SAAgB,6BACd,SAAiB,EACjB,aAAqB;IAErB,OAAO,CAAA,EAAG,UAAS,EAAG,iBAAiB,MAAM,cAAa,CAAE;AAC9D;AALA,QAAA,4BAAA,GAAA"}},
    {"offset": {"line": 2136, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2140, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@apollo/server/src/plugin/usageReporting/stats.ts"],"sourcesContent":["import type { NonFtv1ErrorPath } from '@apollo/server-gateway-interface';\nimport {\n  type google,\n  type IContextualizedStats,\n  type IFieldStat,\n  type IPathErrorStats,\n  type IQueryLatencyStats,\n  type IReport,\n  type IStatsContext,\n  type ITracesAndStats,\n  type ITypeStat,\n  type ReportHeader,\n  Trace,\n} from '@apollo/usage-reporting-protobuf';\nimport type { ReferencedFieldsByType } from '@apollo/utils.usagereporting';\nimport { DurationHistogram } from './durationHistogram.js';\nimport { iterateOverTrace, type ResponseNamePath } from './iterateOverTrace.js';\n\n// protobuf.js exports both a class and an interface (starting with I) for each\n// message type. The class is what it produces when it decodes the message; the\n// interface is what is accepted as input. We build up our messages using custom\n// types implementing the interfaces, so that we can take advantage of the\n// js_use_toArray option we added to our protobuf.js fork which allows us to use\n// classes like DurationHistogram to generate repeated fields. We end up\n// re-creating most of the report structure as custom classes (starting with\n// \"Our\"). TypeScript validates that we've properly listed all of the message\n// fields with the appropriate types (we use `Required` to ensure we implement\n// all message fields). Using our own classes has other advantages, like being\n// able to specify that nested messages are instances of the same class rather\n// than the interface type and thus that they have non-null fields (because the\n// interface type allows all fields to be optional, even though the protobuf\n// format doesn't differentiate between missing and falsey).\n\nexport class SizeEstimator {\n  bytes = 0;\n}\nexport class OurReport implements Required<IReport> {\n  // Apollo Server includes each operation either as aggregated stats or as a\n  // trace, but not both. Other reporting agents such as Apollo Router include\n  // all operations in stats (even those that are sent as traces), and they set\n  // this flag to true.\n  tracesPreAggregated = false;\n\n  constructor(readonly header: ReportHeader) {}\n  readonly tracesPerQuery: Record<string, OurTracesAndStats> =\n    Object.create(null);\n  endTime: google.protobuf.ITimestamp | null = null;\n  operationCount = 0;\n  // A rough estimate of the number of bytes currently in the report. We start\n  // at zero and don't count `header` and `endTime`, which have the same size\n  // for every report. This really is a rough estimate, so we don't stress too\n  // much about counting bytes for the tags and string/message lengths, etc:\n  // we mostly just count the lengths of strings plus some estimates for the\n  // messages with a bunch of numbers in them.\n  //\n  // We store this in a class so we can pass it down as a reference to other\n  // methods which increment it.\n  readonly sizeEstimator = new SizeEstimator();\n\n  ensureCountsAreIntegers() {\n    for (const tracesAndStats of Object.values(this.tracesPerQuery)) {\n      tracesAndStats.ensureCountsAreIntegers();\n    }\n  }\n\n  addTrace({\n    statsReportKey,\n    trace,\n    asTrace,\n    referencedFieldsByType,\n    // The max size a trace can be before it is sent as stats. Note that the\n    // Apollo reporting ingress server will never store any traces over 10mb\n    // anyway. They will still be converted to stats as we would do here.\n    maxTraceBytes = 10 * 1024 * 1024,\n    nonFtv1ErrorPaths,\n  }: {\n    statsReportKey: string;\n    trace: Trace;\n    asTrace: boolean;\n    referencedFieldsByType: ReferencedFieldsByType;\n    maxTraceBytes?: number;\n    nonFtv1ErrorPaths: NonFtv1ErrorPath[];\n  }) {\n    const tracesAndStats = this.getTracesAndStats({\n      statsReportKey,\n      referencedFieldsByType,\n    });\n    if (asTrace) {\n      const encodedTrace = Trace.encode(trace).finish();\n\n      if (!isNaN(maxTraceBytes) && encodedTrace.length > maxTraceBytes) {\n        tracesAndStats.statsWithContext.addTrace(\n          trace,\n          this.sizeEstimator,\n          nonFtv1ErrorPaths,\n        );\n      } else {\n        tracesAndStats.trace.push(encodedTrace);\n        this.sizeEstimator.bytes += 2 + encodedTrace.length;\n      }\n    } else {\n      tracesAndStats.statsWithContext.addTrace(\n        trace,\n        this.sizeEstimator,\n        nonFtv1ErrorPaths,\n      );\n    }\n  }\n\n  private getTracesAndStats({\n    statsReportKey,\n    referencedFieldsByType,\n  }: {\n    statsReportKey: string;\n    referencedFieldsByType: ReferencedFieldsByType;\n  }) {\n    const existing = this.tracesPerQuery[statsReportKey];\n    if (existing) {\n      return existing;\n    }\n    this.sizeEstimator.bytes += estimatedBytesForString(statsReportKey);\n\n    // Update the size estimator for the referenced field structure.\n    for (const [typeName, referencedFieldsForType] of Object.entries(\n      referencedFieldsByType,\n    )) {\n      // Two bytes each for the map entry and for the ReferencedFieldsForType,\n      // and for the isInterface bool if it's set.\n      this.sizeEstimator.bytes += 2 + 2;\n      if (referencedFieldsForType.isInterface) {\n        this.sizeEstimator.bytes += 2;\n      }\n      this.sizeEstimator.bytes += estimatedBytesForString(typeName);\n      for (const fieldName of referencedFieldsForType.fieldNames) {\n        this.sizeEstimator.bytes += estimatedBytesForString(fieldName);\n      }\n    }\n\n    // Include the referenced fields map in the report. (In an ideal world we\n    // could have a slightly more sophisticated protocol and ingestion pipeline\n    // that allowed us to only have to send this data once for each\n    // schema/operation pair.)\n    return (this.tracesPerQuery[statsReportKey] = new OurTracesAndStats(\n      referencedFieldsByType,\n    ));\n  }\n}\n\nclass OurTracesAndStats implements Required<ITracesAndStats> {\n  constructor(readonly referencedFieldsByType: ReferencedFieldsByType) {}\n  readonly trace: Uint8Array[] = [];\n  readonly statsWithContext = new StatsByContext();\n  readonly internalTracesContributingToStats: Uint8Array[] = [];\n\n  ensureCountsAreIntegers() {\n    this.statsWithContext.ensureCountsAreIntegers();\n  }\n}\n\nclass StatsByContext {\n  readonly map: { [k: string]: OurContextualizedStats } = Object.create(null);\n\n  /**\n   * This function is used by the protobuf generator to convert this map into\n   * an array of contextualized stats to serialize\n   */\n  toArray(): IContextualizedStats[] {\n    return Object.values(this.map);\n  }\n\n  ensureCountsAreIntegers() {\n    for (const contextualizedStats of Object.values(this.map)) {\n      contextualizedStats.ensureCountsAreIntegers();\n    }\n  }\n\n  addTrace(\n    trace: Trace,\n    sizeEstimator: SizeEstimator,\n    nonFtv1ErrorPaths: NonFtv1ErrorPath[],\n  ) {\n    this.getContextualizedStats(trace, sizeEstimator).addTrace(\n      trace,\n      sizeEstimator,\n      nonFtv1ErrorPaths,\n    );\n  }\n\n  private getContextualizedStats(\n    trace: Trace,\n    sizeEstimator: SizeEstimator,\n  ): OurContextualizedStats {\n    const statsContext: IStatsContext = {\n      clientName: trace.clientName,\n      clientVersion: trace.clientVersion,\n    };\n    const statsContextKey = JSON.stringify(statsContext);\n\n    const existing = this.map[statsContextKey];\n    if (existing) {\n      return existing;\n    }\n    // Adding a ContextualizedStats means adding a StatsContext plus a\n    // QueryLatencyStats. Let's guess about 20 bytes for a QueryLatencyStats;\n    // it'll be more if more features are used (like cache, APQ, etc).\n    sizeEstimator.bytes +=\n      20 +\n      estimatedBytesForString(trace.clientName) +\n      estimatedBytesForString(trace.clientVersion);\n    const contextualizedStats = new OurContextualizedStats(statsContext);\n    this.map[statsContextKey] = contextualizedStats;\n    return contextualizedStats;\n  }\n}\n\nexport class OurContextualizedStats implements Required<IContextualizedStats> {\n  queryLatencyStats = new OurQueryLatencyStats();\n  perTypeStat: { [k: string]: OurTypeStat } = Object.create(null);\n\n  constructor(readonly context: IStatsContext) {}\n\n  ensureCountsAreIntegers() {\n    for (const typeStat of Object.values(this.perTypeStat)) {\n      typeStat.ensureCountsAreIntegers();\n    }\n  }\n\n  // Extract statistics from the trace, and increment the estimated report size.\n  // We only add to the estimate when adding whole sub-messages. If it really\n  // mattered, we could do a lot more careful things like incrementing it\n  // whenever a numeric field on queryLatencyStats gets incremented over 0.\n  addTrace(\n    trace: Trace,\n    sizeEstimator: SizeEstimator,\n    nonFtv1ErrorPaths: NonFtv1ErrorPath[] = [],\n  ) {\n    const { fieldExecutionWeight } = trace;\n    if (!fieldExecutionWeight) {\n      this.queryLatencyStats.requestsWithoutFieldInstrumentation++;\n    }\n\n    this.queryLatencyStats.requestCount++;\n    if (trace.fullQueryCacheHit) {\n      this.queryLatencyStats.cacheLatencyCount.incrementDuration(\n        trace.durationNs,\n      );\n      this.queryLatencyStats.cacheHits++;\n    } else {\n      this.queryLatencyStats.latencyCount.incrementDuration(trace.durationNs);\n    }\n\n    // We only provide stats about cache TTLs on cache misses (ie, TTLs directly\n    // calculated by the backend), not for cache hits. This matches the\n    // behavior we've had for a while when converting traces into statistics\n    // in Studio's servers.\n    if (!trace.fullQueryCacheHit && trace.cachePolicy?.maxAgeNs != null) {\n      switch (trace.cachePolicy.scope) {\n        case Trace.CachePolicy.Scope.PRIVATE:\n          this.queryLatencyStats.privateCacheTtlCount.incrementDuration(\n            trace.cachePolicy.maxAgeNs,\n          );\n          break;\n        case Trace.CachePolicy.Scope.PUBLIC:\n          this.queryLatencyStats.publicCacheTtlCount.incrementDuration(\n            trace.cachePolicy.maxAgeNs,\n          );\n          break;\n      }\n    }\n\n    if (trace.persistedQueryHit) {\n      this.queryLatencyStats.persistedQueryHits++;\n    }\n    if (trace.persistedQueryRegister) {\n      this.queryLatencyStats.persistedQueryMisses++;\n    }\n\n    if (trace.forbiddenOperation) {\n      this.queryLatencyStats.forbiddenOperationCount++;\n    }\n    if (trace.registeredOperation) {\n      this.queryLatencyStats.registeredOperationCount++;\n    }\n\n    let hasError = false;\n\n    const errorPathStats = new Set<OurPathErrorStats>();\n\n    const traceNodeStats = (node: Trace.INode, path: ResponseNamePath) => {\n      // Generate error stats and error path information\n      if (node.error?.length) {\n        hasError = true;\n\n        let currPathErrorStats = this.queryLatencyStats.rootErrorStats;\n        path.toArray().forEach((subPath) => {\n          currPathErrorStats = currPathErrorStats.getChild(\n            subPath,\n            sizeEstimator,\n          );\n        });\n\n        errorPathStats.add(currPathErrorStats);\n        currPathErrorStats.errorsCount += node.error.length;\n      }\n\n      if (fieldExecutionWeight) {\n        // The actual field name behind the node; originalFieldName is set\n        // if an alias was used, otherwise responseName. (This is falsey for\n        // nodes that are not fields (root, array index, etc).)\n        const fieldName = node.originalFieldName || node.responseName;\n\n        // Protobuf doesn't really differentiate between \"unset\" and \"falsey\" so\n        // we're mostly actually checking that these things are non-empty string /\n        // non-zero numbers. The time fields represent the number of nanoseconds\n        // since the beginning of the entire trace, so let's pretend for the\n        // moment that it's plausible for a node to start or even end exactly when\n        // the trace started (ie, for the time values to be 0). This is unlikely\n        // in practice (everything should take at least 1ns). In practice we only\n        // write `type` and `parentType` on a Node when we write `startTime`, so\n        // the main thing we're looking out for by checking the time values is\n        // whether we somehow failed to write `endTime` at the end of the field;\n        // in this case, the `endTime >= startTime` check won't match.\n        if (\n          node.parentType &&\n          fieldName &&\n          node.type &&\n          node.endTime != null &&\n          node.startTime != null &&\n          node.endTime >= node.startTime\n        ) {\n          const typeStat = this.getTypeStat(node.parentType, sizeEstimator);\n\n          const fieldStat = typeStat.getFieldStat(\n            fieldName,\n            node.type,\n            sizeEstimator,\n          );\n\n          fieldStat.errorsCount += node.error?.length ?? 0;\n          fieldStat.observedExecutionCount++;\n          fieldStat.estimatedExecutionCount += fieldExecutionWeight;\n          // Note: this is actually counting the number of resolver calls for this\n          // field that had at least one error, not the number of overall GraphQL\n          // queries that had at least one error for this field. That doesn't seem\n          // to match the name, but it does match the other implementations of this\n          // logic.\n          fieldStat.requestsWithErrorsCount +=\n            (node.error?.length ?? 0) > 0 ? 1 : 0;\n          fieldStat.latencyCount.incrementDuration(\n            node.endTime - node.startTime,\n            // The latency histogram is always \"estimated\"; we don't track\n            // \"observed\" and \"estimated\" separately.\n            fieldExecutionWeight,\n          );\n        }\n      }\n\n      return false;\n    };\n\n    iterateOverTrace(trace, traceNodeStats, true);\n\n    // iterate over nonFtv1ErrorPaths, using some bits from traceNodeStats function\n    for (const { subgraph, path } of nonFtv1ErrorPaths) {\n      hasError = true;\n      if (path) {\n        let currPathErrorStats = this.queryLatencyStats.rootErrorStats.getChild(\n          `service:${subgraph}`,\n          sizeEstimator,\n        );\n        path.forEach((subPath) => {\n          if (typeof subPath === 'string') {\n            currPathErrorStats = currPathErrorStats.getChild(\n              subPath,\n              sizeEstimator,\n            );\n          }\n        });\n\n        errorPathStats.add(currPathErrorStats);\n        currPathErrorStats.errorsCount += 1;\n      }\n    }\n\n    for (const errorPath of errorPathStats) {\n      errorPath.requestsWithErrorsCount += 1;\n    }\n\n    if (hasError) {\n      this.queryLatencyStats.requestsWithErrorsCount++;\n    }\n  }\n\n  getTypeStat(parentType: string, sizeEstimator: SizeEstimator): OurTypeStat {\n    const existing = this.perTypeStat[parentType];\n    if (existing) {\n      return existing;\n    }\n    sizeEstimator.bytes += estimatedBytesForString(parentType);\n    const typeStat = new OurTypeStat();\n    this.perTypeStat[parentType] = typeStat;\n    return typeStat;\n  }\n}\n\nclass OurQueryLatencyStats implements Required<IQueryLatencyStats> {\n  latencyCount: DurationHistogram = new DurationHistogram();\n  requestCount = 0;\n  requestsWithoutFieldInstrumentation = 0;\n  cacheHits = 0;\n  persistedQueryHits = 0;\n  persistedQueryMisses = 0;\n  cacheLatencyCount: DurationHistogram = new DurationHistogram();\n  rootErrorStats: OurPathErrorStats = new OurPathErrorStats();\n  requestsWithErrorsCount = 0;\n  publicCacheTtlCount: DurationHistogram = new DurationHistogram();\n  privateCacheTtlCount: DurationHistogram = new DurationHistogram();\n  registeredOperationCount = 0;\n  forbiddenOperationCount = 0;\n}\n\nclass OurPathErrorStats implements Required<IPathErrorStats> {\n  children: { [k: string]: OurPathErrorStats } = Object.create(null);\n  errorsCount = 0;\n  requestsWithErrorsCount = 0;\n\n  getChild(subPath: string, sizeEstimator: SizeEstimator): OurPathErrorStats {\n    const existing = this.children[subPath];\n    if (existing) {\n      return existing;\n    }\n    const child = new OurPathErrorStats();\n    this.children[subPath] = child;\n    // Include a few bytes in the estimate for the numbers etc.\n    sizeEstimator.bytes += estimatedBytesForString(subPath) + 4;\n    return child;\n  }\n}\n\nclass OurTypeStat implements Required<ITypeStat> {\n  perFieldStat: { [k: string]: OurFieldStat } = Object.create(null);\n\n  getFieldStat(\n    fieldName: string,\n    returnType: string,\n    sizeEstimator: SizeEstimator,\n  ): OurFieldStat {\n    const existing = this.perFieldStat[fieldName];\n    if (existing) {\n      return existing;\n    }\n    // Rough estimate of 10 bytes for the numbers in the FieldStat.\n    sizeEstimator.bytes +=\n      estimatedBytesForString(fieldName) +\n      estimatedBytesForString(returnType) +\n      10;\n    const fieldStat = new OurFieldStat(returnType);\n    this.perFieldStat[fieldName] = fieldStat;\n    return fieldStat;\n  }\n\n  ensureCountsAreIntegers() {\n    for (const fieldStat of Object.values(this.perFieldStat)) {\n      fieldStat.ensureCountsAreIntegers();\n    }\n  }\n}\n\nclass OurFieldStat implements Required<IFieldStat> {\n  errorsCount = 0;\n  observedExecutionCount = 0;\n  // Note that this number isn't necessarily an integer while it is being\n  // aggregated. Before encoding as a protobuf we call ensureCountsAreIntegers\n  // which floors it.\n  estimatedExecutionCount = 0;\n  requestsWithErrorsCount = 0;\n  latencyCount: DurationHistogram = new DurationHistogram();\n\n  constructor(readonly returnType: string) {}\n\n  ensureCountsAreIntegers() {\n    // This is the only one that ever can receive non-integers.\n    this.estimatedExecutionCount = Math.floor(this.estimatedExecutionCount);\n  }\n}\n\nfunction estimatedBytesForString(s: string) {\n  // 2 is for the tag (field ID + wire type) plus the encoded length. (The\n  // encoded length takes up more than 1 byte for strings that are longer than\n  // 127 bytes, but this is an estimate.)\n  return 2 + Buffer.byteLength(s);\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2421, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2425, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@apollo/server/src/plugin/usageReporting/traceDetails.ts"],"sourcesContent":["import { Trace } from '@apollo/usage-reporting-protobuf';\nimport type { VariableValueOptions } from './options.js';\n\n// Creates trace details from request variables, given a specification for modifying\n// values of private or sensitive variables.\n// The details will include all variable names and their (possibly hidden or modified) values.\n// If sendVariableValues is {all: bool}, {none: bool} or {exceptNames: Array}, the option will act similarly to\n// to the to-be-deprecated options.privateVariables, except that the redacted variable\n// names will still be visible in the UI even if the values are hidden.\n// If sendVariableValues is null or undefined, we default to the {none: true} case.\nexport function makeTraceDetails(\n  variables: Record<string, any>,\n  sendVariableValues?: VariableValueOptions,\n  operationString?: string,\n): Trace.Details {\n  const details = new Trace.Details();\n  const variablesToRecord = (() => {\n    if (sendVariableValues && 'transform' in sendVariableValues) {\n      const originalKeys = Object.keys(variables);\n      try {\n        // Custom function to allow user to specify what variablesJson will look like\n        const modifiedVariables = sendVariableValues.transform({\n          variables: variables,\n          operationString: operationString,\n        });\n        return cleanModifiedVariables(originalKeys, modifiedVariables);\n      } catch (e) {\n        // If the custom function provided by the user throws an exception,\n        // change all the variable values to an appropriate error message.\n        return handleVariableValueTransformError(originalKeys);\n      }\n    } else {\n      return variables;\n    }\n  })();\n\n  // Note: we explicitly do *not* include the details.rawQuery field. The\n  // Studio web app currently does nothing with this other than store it in\n  // the database and offer it up via its GraphQL API, and sending it means\n  // that using calculateSignature to hide sensitive data in the query\n  // string is ineffective.\n  Object.keys(variablesToRecord).forEach((name) => {\n    if (\n      !sendVariableValues ||\n      ('none' in sendVariableValues && sendVariableValues.none) ||\n      ('all' in sendVariableValues && !sendVariableValues.all) ||\n      ('exceptNames' in sendVariableValues &&\n        // We assume that most users will have only a few variables values to hide,\n        // or will just set {none: true}; we can change this\n        // linear-time operation if it causes real performance issues.\n        sendVariableValues.exceptNames.includes(name)) ||\n      ('onlyNames' in sendVariableValues &&\n        !sendVariableValues.onlyNames.includes(name))\n    ) {\n      // Special case for private variables. Note that this is a different\n      // representation from a variable containing the empty string, as that\n      // will be sent as '\"\"'.\n      details.variablesJson![name] = '';\n    } else {\n      try {\n        details.variablesJson![name] =\n          typeof variablesToRecord[name] === 'undefined'\n            ? ''\n            : JSON.stringify(variablesToRecord[name]);\n      } catch (e) {\n        details.variablesJson![name] = JSON.stringify(\n          '[Unable to convert value to JSON]',\n        );\n      }\n    }\n  });\n  return details;\n}\n\nfunction handleVariableValueTransformError(\n  variableNames: string[],\n): Record<string, any> {\n  const modifiedVariables = Object.create(null);\n  variableNames.forEach((name) => {\n    modifiedVariables[name] = '[PREDICATE_FUNCTION_ERROR]';\n  });\n  return modifiedVariables;\n}\n\n// Helper for makeTraceDetails() to enforce that the keys of a modified 'variables'\n// matches that of the original 'variables'\nfunction cleanModifiedVariables(\n  originalKeys: Array<string>,\n  modifiedVariables: Record<string, any>,\n): Record<string, any> {\n  const cleanedVariables: Record<string, any> = Object.create(null);\n  originalKeys.forEach((name) => {\n    cleanedVariables[name] = modifiedVariables[name];\n  });\n  return cleanedVariables;\n}\n"],"names":[],"mappings":";;;;;AAAA,MAAA;AAUA,SAAgB,iBACd,SAA8B,EAC9B,kBAAyC,EACzC,eAAwB;IAExB,MAAM,UAAU,IAAI,2BAAA,KAAK,CAAC,OAAO;IACjC,MAAM,oBAAoB,CAAC;QACzB,IAAI,sBAAsB,eAAe,oBAAoB;YAC3D,MAAM,eAAe,OAAO,IAAI,CAAC;YACjC,IAAI;gBAEF,MAAM,oBAAoB,mBAAmB,SAAS,CAAC;oBACrD,WAAW;oBACX,iBAAiB;;gBAEnB,OAAO,uBAAuB,cAAc;YAC9C,EAAE,OAAO,GAAG;gBAGV,OAAO,kCAAkC;YAC3C;QACF,OAAO;YACL,OAAO;QACT;IACF,CAAC;IAOD,OAAO,IAAI,CAAC,mBAAmB,OAAO,CAAC,CAAC;QACtC,IACE,CAAC,sBACA,UAAU,sBAAsB,mBAAmB,IAAI,IACvD,SAAS,sBAAsB,CAAC,mBAAmB,GAAG,IACtD,iBAAiB,sBAIhB,mBAAmB,WAAW,CAAC,QAAQ,CAAC,SACzC,eAAe,sBACd,CAAC,mBAAmB,SAAS,CAAC,QAAQ,CAAC,OACzC;YAIA,QAAQ,aAAc,CAAC,KAAK,GAAG;QACjC,OAAO;YACL,IAAI;gBACF,QAAQ,aAAc,CAAC,KAAK,GAC1B,OAAO,iBAAiB,CAAC,KAAK,KAAK,cAC/B,KACA,KAAK,SAAS,CAAC,iBAAiB,CAAC,KAAK;YAC9C,EAAE,OAAO,GAAG;gBACV,QAAQ,aAAc,CAAC,KAAK,GAAG,KAAK,SAAS,CAC3C;YAEJ;QACF;IACF;IACA,OAAO;AACT;AA9DA,QAAA,gBAAA,GAAA;AAgEA,SAAS,kCACP,aAAuB;IAEvB,MAAM,oBAAoB,OAAO,MAAM,CAAC;IACxC,cAAc,OAAO,CAAC,CAAC;QACrB,iBAAiB,CAAC,KAAK,GAAG;IAC5B;IACA,OAAO;AACT;AAIA,SAAS,uBACP,YAA2B,EAC3B,iBAAsC;IAEtC,MAAM,mBAAwC,OAAO,MAAM,CAAC;IAC5D,aAAa,OAAO,CAAC,CAAC;QACpB,gBAAgB,CAAC,KAAK,GAAG,iBAAiB,CAAC,KAAK;IAClD;IACA,OAAO;AACT"}},
    {"offset": {"line": 2477, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2481, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@apollo/server/src/generated/packageVersion.ts"],"sourcesContent":["export const packageVersion = \"4.10.4\";\n"],"names":[],"mappings":";;;;;AAAa,QAAA,cAAc,GAAG"}},
    {"offset": {"line": 2487, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2491, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@apollo/server/src/plugin/schemaIsSubgraph.ts"],"sourcesContent":["import {\n  type GraphQLSchema,\n  isObjectType,\n  isScalarType,\n  isNonNullType,\n} from 'graphql';\n\n// Returns true if it appears that the schema was appears to be of a subgraph\n// (eg, returned from @apollo/subgraph's buildSubgraphSchema). This strategy\n// avoids depending explicitly on @apollo/subgraph or relying on something that\n// might not survive transformations like monkey-patching a boolean field onto\n// the schema.\n//\n// This is used for two things:\n// 1) Determining whether traces should be added to responses if requested with\n//    an HTTP header. If you want to include these traces even for non-subgraphs\n//    (when requested via header, eg for Apollo Explorer's trace view) you can\n//    use ApolloServerPluginInlineTrace explicitly; if you want to never include\n//    these traces even for subgraphs you can use\n//    ApolloServerPluginInlineTraceDisabled.\n// 2) Determining whether schema-reporting should be allowed; subgraphs cannot\n//    report schemas, and we accordingly throw if it's attempted.\nexport function schemaIsSubgraph(schema: GraphQLSchema): boolean {\n  const serviceType = schema.getType('_Service');\n  if (!isObjectType(serviceType)) {\n    return false;\n  }\n  const sdlField = serviceType.getFields().sdl;\n  if (!sdlField) {\n    return false;\n  }\n\n  let sdlFieldType = sdlField.type;\n  if (isNonNullType(sdlFieldType)) {\n    sdlFieldType = sdlFieldType.ofType;\n  }\n  if (!isScalarType(sdlFieldType)) {\n    return false;\n  }\n  return sdlFieldType.name == 'String';\n}\n"],"names":[],"mappings":";;;;;AAAA,MAAA;AAsBA,SAAgB,iBAAiB,MAAqB;IACpD,MAAM,cAAc,OAAO,OAAO,CAAC;IACnC,IAAI,CAAC,CAAA,GAAA,UAAA,YAAY,EAAC,cAAc;QAC9B,OAAO;IACT;IACA,MAAM,WAAW,YAAY,SAAS,GAAG,GAAG;IAC5C,IAAI,CAAC,UAAU;QACb,OAAO;IACT;IAEA,IAAI,eAAe,SAAS,IAAI;IAChC,IAAI,CAAA,GAAA,UAAA,aAAa,EAAC,eAAe;QAC/B,eAAe,aAAa,MAAM;IACpC;IACA,IAAI,CAAC,CAAA,GAAA,UAAA,YAAY,EAAC,eAAe;QAC/B,OAAO;IACT;IACA,OAAO,aAAa,IAAI,IAAI;AAC9B;AAlBA,QAAA,gBAAA,GAAA"}},
    {"offset": {"line": 2516, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2520, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@apollo/server/src/plugin/usageReporting/plugin.ts"],"sourcesContent":["import { Report, ReportHeader, Trace } from '@apollo/usage-reporting-protobuf';\nimport type { Fetcher, FetcherResponse } from '@apollo/utils.fetcher';\nimport {\n  usageReportingSignature,\n  calculateReferencedFieldsByType,\n  type ReferencedFieldsByType,\n} from '@apollo/utils.usagereporting';\nimport retry from 'async-retry';\nimport { type GraphQLSchema, printSchema } from 'graphql';\nimport type LRUCache from 'lru-cache';\nimport { AbortController } from 'node-abort-controller';\nimport fetch from 'node-fetch';\nimport os from 'os';\nimport { gzip } from 'zlib';\nimport type {\n  ApolloServerPlugin,\n  BaseContext,\n  GraphQLRequestContext,\n  GraphQLRequestContextDidResolveOperation,\n  GraphQLRequestContextWillSendResponse,\n  GraphQLRequestListener,\n  GraphQLServerListener,\n} from '../../externalTypes/index.js';\nimport { internalPlugin } from '../../internalPlugin.js';\nimport { dateToProtoTimestamp, TraceTreeBuilder } from '../traceTreeBuilder.js';\nimport { defaultSendOperationsAsTrace } from './defaultSendOperationsAsTrace.js';\nimport {\n  createOperationDerivedDataCache,\n  type OperationDerivedData,\n  operationDerivedDataCacheKey,\n} from './operationDerivedDataCache.js';\nimport type {\n  ApolloServerPluginUsageReportingOptions,\n  SendValuesBaseOptions,\n} from './options.js';\nimport { OurReport } from './stats.js';\nimport { makeTraceDetails } from './traceDetails.js';\nimport { packageVersion } from '../../generated/packageVersion.js';\nimport { computeCoreSchemaHash } from '../../utils/computeCoreSchemaHash.js';\nimport type { HeaderMap } from '../../utils/HeaderMap.js';\nimport { schemaIsSubgraph } from '../schemaIsSubgraph.js';\n\nconst reportHeaderDefaults = {\n  hostname: os.hostname(),\n  agentVersion: `@apollo/server@${packageVersion}`,\n  runtimeVersion: `node ${process.version}`,\n  // XXX not actually uname, but what node has easily.\n  uname: `${os.platform()}, ${os.type()}, ${os.release()}, ${os.arch()})`,\n};\n\nexport function ApolloServerPluginUsageReporting<TContext extends BaseContext>(\n  options: ApolloServerPluginUsageReportingOptions<TContext> = Object.create(\n    null,\n  ),\n): ApolloServerPlugin<TContext> {\n  // Note: We'd like to change the default to false in Apollo Server 4, so that\n  // the default usage reporting experience doesn't include *anything* that\n  // could potentially be PII (like error messages) --- just operations and\n  // numbers.\n  const fieldLevelInstrumentationOption = options.fieldLevelInstrumentation;\n  const fieldLevelInstrumentation =\n    typeof fieldLevelInstrumentationOption === 'number'\n      ? async () =>\n          Math.random() < fieldLevelInstrumentationOption\n            ? 1 / fieldLevelInstrumentationOption\n            : 0\n      : fieldLevelInstrumentationOption\n        ? fieldLevelInstrumentationOption\n        : async () => true;\n\n  let requestDidStartHandler:\n    | ((\n        requestContext: GraphQLRequestContext<TContext>,\n      ) => GraphQLRequestListener<TContext>)\n    | null = null;\n  return internalPlugin({\n    __internal_plugin_id__: 'UsageReporting',\n    __is_disabled_plugin__: false,\n\n    // We want to be able to access locals from `serverWillStart` in our `requestDidStart`, thus\n    // this little hack. (Perhaps we should also allow GraphQLServerListener to contain\n    // a requestDidStart?)\n    async requestDidStart(requestContext: GraphQLRequestContext<TContext>) {\n      if (requestDidStartHandler) {\n        return requestDidStartHandler(requestContext);\n      }\n      // This happens if usage reporting is disabled (eg because this is a\n      // subgraph).\n      return {};\n    },\n\n    async serverWillStart({\n      logger: serverLogger,\n      apollo,\n      startedInBackground,\n      schema,\n    }): Promise<GraphQLServerListener> {\n      // Use the plugin-specific logger if one is provided; otherwise the general server one.\n      const logger = options.logger ?? serverLogger;\n      const { key, graphRef } = apollo;\n      if (!(key && graphRef)) {\n        throw new Error(\n          \"You've enabled usage reporting via ApolloServerPluginUsageReporting, \" +\n            'but you also need to provide your Apollo API key and graph ref, via ' +\n            'the APOLLO_KEY/APOLLO_GRAPH_REF environment ' +\n            'variables or via `new ApolloServer({apollo: {key, graphRef})`.',\n        );\n      }\n\n      if (schemaIsSubgraph(schema)) {\n        if (options.__onlyIfSchemaIsNotSubgraph) {\n          logger.warn(\n            'You have specified an Apollo API key and graph ref but this server appears ' +\n              'to be a subgraph. Typically usage reports are sent to Apollo by your Router ' +\n              'or Gateway, not directly from your subgraph; usage reporting is disabled. To ' +\n              'enable usage reporting anyway, explicitly install `ApolloServerPluginUsageReporting`. ' +\n              'To disable this warning, install `ApolloServerPluginUsageReportingDisabled`.',\n          );\n          // This early return means we don't start background timers, don't\n          // register serverDidStart, don't assign requestDidStartHandler, etc.\n          return {};\n        } else {\n          // This is just a warning; usage reporting is still enabled. If it\n          // turns out there are lots of people who really need to have this odd\n          // setup and they don't like the warning, we can provide a new option\n          // to disable the warning (or they can filter in their `logger`).\n          logger.warn(\n            'You have installed `ApolloServerPluginUsageReporting` but this server appears to ' +\n              'be a subgraph. Typically usage reports are sent to Apollo by your Router ' +\n              'or Gateway, not directly from your subgraph. If this was unintentional, remove ' +\n              \"`ApolloServerPluginUsageReporting` from your server's `plugins` array.\",\n          );\n        }\n      }\n\n      logger.info(\n        'Apollo usage reporting starting! See your graph at ' +\n          `https://studio.apollographql.com/graph/${encodeURI(graphRef)}/`,\n      );\n\n      // If sendReportsImmediately is not specified, we default to true if we're running\n      // with the ApolloServer designed for Lambda or similar. That's because these\n      // environments aren't designed around letting us run a background task to\n      // send reports later or hook into container destruction to flush buffered reports.\n      const sendReportsImmediately =\n        options.sendReportsImmediately ?? startedInBackground;\n\n      // Since calculating the signature and referenced fields for usage\n      // reporting is potentially an expensive operation, we'll cache the data\n      // we generate and re-use them for repeated operations for the same\n      // `queryHash`. However, because referenced fields depend on the current\n      // schema, we want to throw it out entirely any time the schema changes.\n      let operationDerivedDataCache: {\n        forSchema: GraphQLSchema;\n        cache: LRUCache<string, OperationDerivedData>;\n      } | null = null;\n\n      // This map maps from executable schema ID (schema hash, basically) to the\n      // report we'll send about it. That's because when we're using a gateway,\n      // the schema can change over time, but each report needs to be about a\n      // single schema. We avoid having this function be a memory leak by\n      // removing values from it when we're in the process of sending reports.\n      // That means we have to be very careful never to pull a Report out of it\n      // and hang on to it for a while before writing to it, because the report\n      // might have gotten sent and discarded in the meantime. So you should\n      // only access the values of this Map via\n      // getReportWhichMustBeUsedImmediately and getAndDeleteReport, and never\n      // hang on to the value returned by getReportWhichMustBeUsedImmediately.\n      const reportByExecutableSchemaId = new Map<string, OurReport>();\n      const getReportWhichMustBeUsedImmediately = (\n        executableSchemaId: string,\n      ): OurReport => {\n        const existing = reportByExecutableSchemaId.get(executableSchemaId);\n        if (existing) {\n          return existing;\n        }\n        const report = new OurReport(\n          new ReportHeader({\n            ...reportHeaderDefaults,\n            executableSchemaId,\n            graphRef,\n          }),\n        );\n        reportByExecutableSchemaId.set(executableSchemaId, report);\n        return report;\n      };\n      const getAndDeleteReport = (\n        executableSchemaId: string,\n      ): OurReport | null => {\n        const report = reportByExecutableSchemaId.get(executableSchemaId);\n        if (report) {\n          reportByExecutableSchemaId.delete(executableSchemaId);\n          return report;\n        }\n        return null;\n      };\n\n      const overriddenExecutableSchemaId = options.overrideReportedSchema\n        ? computeCoreSchemaHash(options.overrideReportedSchema)\n        : undefined;\n\n      let lastSeenExecutableSchemaToId:\n        | {\n            executableSchema: GraphQLSchema;\n            executableSchemaId: string;\n          }\n        | undefined;\n\n      let reportTimer: NodeJS.Timeout | undefined;\n      if (!sendReportsImmediately) {\n        reportTimer = setInterval(\n          () => sendAllReportsAndReportErrors(),\n          options.reportIntervalMs || 10 * 1000,\n        );\n      }\n\n      // We don't send traces if the user set `sendTraces: false`. We also may\n      // set this to false later if the usage-reporting ingress informs us that\n      // this graph does not support viewing traces.\n      let sendTraces = options.sendTraces ?? true;\n      const sendOperationAsTrace =\n        options.experimental_sendOperationAsTrace ??\n        defaultSendOperationsAsTrace();\n\n      let stopped = false;\n\n      function executableSchemaIdForSchema(schema: GraphQLSchema) {\n        if (lastSeenExecutableSchemaToId?.executableSchema === schema) {\n          return lastSeenExecutableSchemaToId.executableSchemaId;\n        }\n        const id = computeCoreSchemaHash(printSchema(schema));\n\n        // We override this variable every time we get a new schema so we cache\n        // the last seen value. It is a single-entry cache.\n        lastSeenExecutableSchemaToId = {\n          executableSchema: schema,\n          executableSchemaId: id,\n        };\n\n        return id;\n      }\n\n      async function sendAllReportsAndReportErrors(): Promise<void> {\n        await Promise.all(\n          [...reportByExecutableSchemaId.keys()].map((executableSchemaId) =>\n            sendReportAndReportErrors(executableSchemaId),\n          ),\n        );\n      }\n\n      async function sendReportAndReportErrors(\n        executableSchemaId: string,\n      ): Promise<void> {\n        return sendReport(executableSchemaId).catch((err) => {\n          // This catch block is primarily intended to catch network errors from\n          // the retried request itself, which include network errors and non-2xx\n          // HTTP errors.\n          if (options.reportErrorFunction) {\n            options.reportErrorFunction(err);\n          } else {\n            logger.error(err.message);\n          }\n        });\n      }\n\n      // Needs to be an arrow function to be confident that key is defined.\n      const sendReport = async (executableSchemaId: string): Promise<void> => {\n        let report = getAndDeleteReport(executableSchemaId);\n        if (\n          !report ||\n          (Object.keys(report.tracesPerQuery).length === 0 &&\n            report.operationCount === 0)\n        ) {\n          return;\n        }\n\n        // Set the report's overall end time. This is the timestamp that will be\n        // associated with the summarized statistics.\n        report.endTime = dateToProtoTimestamp(new Date());\n\n        report.ensureCountsAreIntegers();\n\n        const protobufError = Report.verify(report);\n        if (protobufError) {\n          throw new Error(`Error verifying report: ${protobufError}`);\n        }\n        let message: Uint8Array | null = Report.encode(report).finish();\n        // Let the original protobuf object be garbage collected (helpful if the\n        // HTTP request hangs).\n        report = null;\n\n        // Potential follow-up: we can compare message.length to\n        // report.sizeEstimator.bytes and use it to \"learn\" if our estimation is\n        // off and adjust it based on what we learn.\n\n        if (options.debugPrintReports) {\n          // We decode the report rather than printing the original `report`\n          // so that it includes all of the pre-encoded traces.\n          const decodedReport = Report.decode(message);\n          logger.info(\n            `Apollo usage report: ${JSON.stringify(decodedReport.toJSON())}`,\n          );\n        }\n\n        const compressed = await new Promise<Buffer>((resolve, reject) => {\n          gzip(message!, (error, result) => {\n            error ? reject(error) : resolve(result);\n          });\n        });\n        // Let the uncompressed message be garbage collected (helpful if the\n        // HTTP request is slow).\n        message = null;\n\n        // Wrap fetcher with async-retry for automatic retrying\n        const fetcher: Fetcher = options.fetcher ?? fetch;\n        const response: FetcherResponse = await retry(\n          // Retry on network errors and 5xx HTTP\n          // responses.\n          async () => {\n            // Note that once we require Node v16 we can use its global\n            // AbortController instead of the one from `node-abort-controller`.\n            const controller = new AbortController();\n            const abortTimeout = setTimeout(() => {\n              controller.abort();\n            }, options.requestTimeoutMs ?? 30_000);\n            let curResponse;\n            try {\n              curResponse = await fetcher(\n                (options.endpointUrl ||\n                  'https://usage-reporting.api.apollographql.com') +\n                  '/api/ingress/traces',\n                {\n                  method: 'POST',\n                  headers: {\n                    'user-agent': 'ApolloServerPluginUsageReporting',\n                    'x-api-key': key,\n                    'content-encoding': 'gzip',\n                    accept: 'application/json',\n                  },\n                  body: compressed,\n                  signal: controller.signal,\n                },\n              );\n            } finally {\n              clearTimeout(abortTimeout);\n            }\n\n            if (curResponse.status >= 500 && curResponse.status < 600) {\n              throw new Error(\n                `HTTP status ${curResponse.status}, ${\n                  (await curResponse.text()) || '(no body)'\n                }`,\n              );\n            } else {\n              return curResponse;\n            }\n          },\n          {\n            retries: (options.maxAttempts || 5) - 1,\n            minTimeout: options.minimumRetryDelayMs || 100,\n            factor: 2,\n          },\n        ).catch((err: Error) => {\n          throw new Error(\n            `Error sending report to Apollo servers: ${err.message}`,\n          );\n        });\n\n        if (response.status < 200 || response.status >= 300) {\n          // Note that we don't expect to see a 3xx here because request follows\n          // redirects.\n          throw new Error(\n            `Error sending report to Apollo servers: HTTP status ${\n              response.status\n            }, ${(await response.text()) || '(no body)'}`,\n          );\n        }\n\n        if (\n          sendTraces &&\n          response.status === 200 &&\n          response.headers\n            .get('content-type')\n            ?.match(/^\\s*application\\/json\\s*(?:;|$)/i)\n        ) {\n          const body = await response.text();\n          let parsedBody;\n          try {\n            parsedBody = JSON.parse(body);\n          } catch (e) {\n            throw new Error(`Error parsing response from Apollo servers: ${e}`);\n          }\n          if (parsedBody.tracesIgnored === true) {\n            logger.debug(\n              \"This graph's organization does not have access to traces; sending all \" +\n                'subsequent operations as stats.',\n            );\n            sendTraces = false;\n          }\n        }\n        if (options.debugPrintReports) {\n          logger.info(`Apollo usage report: status ${response.status}`);\n        }\n      };\n\n      requestDidStartHandler = ({\n        metrics,\n        schema,\n        request: { http, variables },\n      }): GraphQLRequestListener<TContext> => {\n        const treeBuilder: TraceTreeBuilder = new TraceTreeBuilder({\n          maskedBy: 'ApolloServerPluginUsageReporting',\n          sendErrors: options.sendErrors,\n        });\n        treeBuilder.startTiming();\n        metrics.startHrTime = treeBuilder.startHrTime;\n        let graphqlValidationFailure = false;\n        let graphqlUnknownOperationName = false;\n        let includeOperationInUsageReporting: boolean | null = null;\n\n        if (http) {\n          treeBuilder.trace.http = new Trace.HTTP({\n            method:\n              Trace.HTTP.Method[\n                http.method as keyof typeof Trace.HTTP.Method\n              ] || Trace.HTTP.Method.UNKNOWN,\n          });\n\n          if (options.sendHeaders) {\n            makeHTTPRequestHeaders(\n              treeBuilder.trace.http,\n              http.headers,\n              options.sendHeaders,\n            );\n          }\n        }\n\n        // After this function completes, includeOperationInUsageReporting is\n        // defined.\n        async function maybeCallIncludeRequestHook(\n          requestContext:\n            | GraphQLRequestContextDidResolveOperation<TContext>\n            | GraphQLRequestContextWillSendResponse<TContext>,\n        ): Promise<void> {\n          // If this is the second call in `willSendResponse` after\n          // `didResolveOperation`, we're done.\n          if (includeOperationInUsageReporting !== null) return;\n\n          if (typeof options.includeRequest !== 'function') {\n            // Default case we always report\n            includeOperationInUsageReporting = true;\n            return;\n          }\n          includeOperationInUsageReporting =\n            await options.includeRequest(requestContext);\n\n          // Help the user understand they've returned an unexpected value,\n          // which might be a subtle mistake.\n          if (typeof includeOperationInUsageReporting !== 'boolean') {\n            logger.warn(\n              \"The 'includeRequest' async predicate function must return a boolean value.\",\n            );\n            includeOperationInUsageReporting = true;\n          }\n        }\n\n        // Our usage reporting groups everything by operation, so we don't\n        // actually report about any issues that prevent us from getting an\n        // operation string (eg, a missing operation, or APQ problems).\n        // This is effectively bypassing the reporting of:\n        //   - PersistedQueryNotFoundError\n        //   - PersistedQueryNotSupportedError\n        //   - Missing `query` error\n        // We may want to report them some other way later!\n        let didResolveSource = false;\n\n        return {\n          async didResolveSource(requestContext) {\n            didResolveSource = true;\n\n            if (metrics.persistedQueryHit) {\n              treeBuilder.trace.persistedQueryHit = true;\n            }\n            if (metrics.persistedQueryRegister) {\n              treeBuilder.trace.persistedQueryRegister = true;\n            }\n\n            if (variables) {\n              treeBuilder.trace.details = makeTraceDetails(\n                variables,\n                options.sendVariableValues,\n                requestContext.source,\n              );\n            }\n\n            const clientInfo = (\n              options.generateClientInfo || defaultGenerateClientInfo\n            )(requestContext);\n            if (clientInfo) {\n              // While there is a clientAddress protobuf field, the backend\n              // doesn't pay attention to it yet, so we'll ignore it for now.\n              const { clientName, clientVersion } = clientInfo;\n              treeBuilder.trace.clientVersion = clientVersion || '';\n              treeBuilder.trace.clientName = clientName || '';\n            }\n          },\n          async validationDidStart() {\n            return async (validationErrors?: ReadonlyArray<Error>) => {\n              graphqlValidationFailure = validationErrors\n                ? validationErrors.length !== 0\n                : false;\n            };\n          },\n          async didResolveOperation(requestContext) {\n            // If operation is undefined then `getOperationAST` returned null\n            // and an unknown operation was specified.\n            graphqlUnknownOperationName =\n              requestContext.operation === undefined;\n            await maybeCallIncludeRequestHook(requestContext);\n\n            if (\n              includeOperationInUsageReporting &&\n              // No need to capture traces if the operation is going to\n              // immediately fail due to unknown operation name.\n              !graphqlUnknownOperationName\n            ) {\n              if (metrics.captureTraces === undefined) {\n                // We're not completely ignoring the operation. But should we\n                // calculate a detailed trace of every field while we do so (either\n                // directly in this plugin, or in a subgraph by sending the\n                // apollo-federation-include-trace header)? That will allow this\n                // operation to contribute to the \"field executions\" column in the\n                // Studio Fields page, to the timing hints in Explorer and\n                // vscode-graphql, and to the traces visible under Operations. (Note\n                // that `true` here does not imply that this operation will\n                // necessarily be *sent* to the usage-reporting endpoint in the form\n                // of a trace --- it still might be aggregated into stats first. But\n                // capturing a trace will mean we can understand exactly what fields\n                // were executed and what their performance was, at the tradeoff of\n                // some overhead for tracking the trace (and transmitting it between\n                // subgraph and gateway).\n                const rawWeight =\n                  await fieldLevelInstrumentation(requestContext);\n                treeBuilder.trace.fieldExecutionWeight =\n                  typeof rawWeight === 'number' ? rawWeight : rawWeight ? 1 : 0;\n\n                metrics.captureTraces =\n                  !!treeBuilder.trace.fieldExecutionWeight;\n              }\n            }\n          },\n          async executionDidStart() {\n            // If we're not capturing traces, don't return a willResolveField so\n            // that we don't build up a detailed trace inside treeBuilder. (We still\n            // will use treeBuilder as a convenient place to put top-level facts\n            // about the operation which can end up aggregated as stats, and we do\n            // eventually put *errors* onto the trace tree.)\n            if (!metrics.captureTraces) return;\n\n            return {\n              willResolveField({ info }) {\n                return treeBuilder.willResolveField(info);\n                // We could save the error into the trace during the end handler, but\n                // it won't have all the information that graphql-js adds to it later,\n                // like 'locations'.\n              },\n            };\n          },\n\n          async didEncounterSubsequentErrors(_requestContext, errors) {\n            treeBuilder.didEncounterErrors(errors);\n          },\n\n          async willSendSubsequentPayload(requestContext, payload) {\n            if (!payload.hasNext) {\n              await operationFinished(requestContext);\n            }\n          },\n\n          async willSendResponse(requestContext) {\n            // Search above for a comment about \"didResolveSource\" to see which\n            // of the pre-source-resolution errors we are intentionally avoiding.\n            if (!didResolveSource) return;\n            if (requestContext.errors) {\n              treeBuilder.didEncounterErrors(requestContext.errors);\n            }\n\n            // If there isn't any defer/stream coming later, we're done.\n            // Otherwise willSendSubsequentPayload will trigger\n            // operationFinished.\n            if (requestContext.response.body.kind === 'single') {\n              await operationFinished(requestContext);\n            }\n          },\n        };\n\n        async function operationFinished(\n          requestContext: GraphQLRequestContextWillSendResponse<TContext>,\n        ) {\n          const resolvedOperation = !!requestContext.operation;\n\n          // If we got an error before we called didResolveOperation (eg parse or\n          // validation error), check to see if we should include the request.\n          await maybeCallIncludeRequestHook(requestContext);\n\n          treeBuilder.stopTiming();\n          const executableSchemaId =\n            overriddenExecutableSchemaId ?? executableSchemaIdForSchema(schema);\n\n          if (includeOperationInUsageReporting === false) {\n            if (resolvedOperation) {\n              getReportWhichMustBeUsedImmediately(executableSchemaId)\n                .operationCount++;\n            }\n            return;\n          }\n\n          treeBuilder.trace.fullQueryCacheHit = !!metrics.responseCacheHit;\n          treeBuilder.trace.forbiddenOperation = !!metrics.forbiddenOperation;\n          treeBuilder.trace.registeredOperation = !!metrics.registeredOperation;\n\n          const policyIfCacheable =\n            requestContext.overallCachePolicy.policyIfCacheable();\n          if (policyIfCacheable) {\n            treeBuilder.trace.cachePolicy = new Trace.CachePolicy({\n              scope:\n                policyIfCacheable.scope === 'PRIVATE'\n                  ? Trace.CachePolicy.Scope.PRIVATE\n                  : policyIfCacheable.scope === 'PUBLIC'\n                    ? Trace.CachePolicy.Scope.PUBLIC\n                    : Trace.CachePolicy.Scope.UNKNOWN,\n              // Convert from seconds to ns.\n              maxAgeNs: policyIfCacheable.maxAge * 1e9,\n            });\n          }\n\n          // If this was a federated operation and we're the gateway, add the query plan\n          // to the trace.\n          if (metrics.queryPlanTrace) {\n            treeBuilder.trace.queryPlan = metrics.queryPlanTrace;\n          }\n\n          // Intentionally un-awaited so as not to block the response.  Any\n          // errors will be logged, but will not manifest a user-facing error.\n          // The logger in this case is a request specific logger OR the logger\n          // defined by the plugin if that's unavailable.  The request-specific\n          // logger is preferred since this is very much coupled directly to a\n          // client-triggered action which might be more granularly tagged by\n          // logging implementations.\n          addTrace().catch(logger.error);\n\n          async function addTrace(): Promise<void> {\n            // Ignore traces that come in after stop().\n            if (stopped) {\n              return;\n            }\n\n            // Ensure that the caller of addTrace (which does not await it) is\n            // not blocked. We use setImmediate rather than process.nextTick or\n            // just relying on the Promise microtask queue because setImmediate\n            // comes after IO, which is what we want.\n            await new Promise((res) => setImmediate(res));\n\n            const executableSchemaId =\n              overriddenExecutableSchemaId ??\n              executableSchemaIdForSchema(schema);\n\n            const { trace } = treeBuilder;\n\n            let statsReportKey: string | undefined = undefined;\n            let referencedFieldsByType: ReferencedFieldsByType;\n            if (!requestContext.document) {\n              statsReportKey = `## GraphQLParseFailure\\n`;\n            } else if (graphqlValidationFailure) {\n              statsReportKey = `## GraphQLValidationFailure\\n`;\n            } else if (graphqlUnknownOperationName) {\n              statsReportKey = `## GraphQLUnknownOperationName\\n`;\n            }\n\n            const isExecutable = statsReportKey === undefined;\n\n            if (statsReportKey) {\n              if (options.sendUnexecutableOperationDocuments) {\n                trace.unexecutedOperationBody = requestContext.source;\n                // Get the operation name from the request (which might not\n                // correspond to an actual operation).\n                trace.unexecutedOperationName =\n                  requestContext.request.operationName || '';\n              }\n              referencedFieldsByType = Object.create(null);\n            } else {\n              const operationDerivedData = getOperationDerivedData();\n              statsReportKey = `# ${requestContext.operationName || '-'}\\n${\n                operationDerivedData.signature\n              }`;\n              referencedFieldsByType =\n                operationDerivedData.referencedFieldsByType;\n            }\n\n            const protobufError = Trace.verify(trace);\n            if (protobufError) {\n              throw new Error(`Error encoding trace: ${protobufError}`);\n            }\n\n            if (resolvedOperation) {\n              getReportWhichMustBeUsedImmediately(executableSchemaId)\n                .operationCount++;\n            }\n\n            getReportWhichMustBeUsedImmediately(executableSchemaId).addTrace({\n              statsReportKey,\n              trace,\n              // We include the operation as a trace (rather than aggregated into stats) only if:\n              // * the user didn't set `sendTraces: false` AND\n              // * it's possible that the organization's plan allows for viewing traces AND\n              // * we captured this as a full trace AND\n              // * gateway reported no errors missing ftv1 data AND\n              // * sendOperationAsTrace says so\n              //\n              // (As an edge case, if the reason metrics.captureTraces is\n              // falsey is that this is an unexecutable operation and thus we\n              // never ran the code in didResolveOperation that sets\n              // metrics.captureTrace, we allow it to be sent as a trace. This\n              // means we'll still send some parse and validation failures as\n              // traces, for the sake of the Errors page.)\n              asTrace:\n                sendTraces &&\n                (!isExecutable || !!metrics.captureTraces) &&\n                !metrics.nonFtv1ErrorPaths?.length &&\n                sendOperationAsTrace(trace, statsReportKey),\n              referencedFieldsByType,\n              nonFtv1ErrorPaths: metrics.nonFtv1ErrorPaths ?? [],\n            });\n\n            // If the buffer gets big (according to our estimate), send.\n            if (\n              sendReportsImmediately ||\n              getReportWhichMustBeUsedImmediately(executableSchemaId)\n                .sizeEstimator.bytes >=\n                (options.maxUncompressedReportSize || 4 * 1024 * 1024)\n            ) {\n              await sendReportAndReportErrors(executableSchemaId);\n            }\n          }\n\n          // Calculates signature and referenced fields for the current document.\n          // Only call this when the document properly parses and validates and\n          // the given operation name (if any) is known!\n          function getOperationDerivedData(): OperationDerivedData {\n            if (!requestContext.document) {\n              // This shouldn't happen: no document means parse failure, which\n              // uses its own special statsReportKey.\n              throw new Error('No document?');\n            }\n\n            const cacheKey = operationDerivedDataCacheKey(\n              requestContext.queryHash,\n              requestContext.operationName || '',\n            );\n\n            // Ensure that the cache we have is for the right schema.\n            if (\n              !operationDerivedDataCache ||\n              operationDerivedDataCache.forSchema !== schema\n            ) {\n              operationDerivedDataCache = {\n                forSchema: schema,\n                cache: createOperationDerivedDataCache({ logger }),\n              };\n            }\n\n            // If we didn't have the signature in the cache, we'll resort to\n            // calculating it.\n            const cachedOperationDerivedData =\n              operationDerivedDataCache.cache.get(cacheKey);\n            if (cachedOperationDerivedData) {\n              return cachedOperationDerivedData;\n            }\n\n            const generatedSignature = (\n              options.calculateSignature || usageReportingSignature\n            )(requestContext.document, requestContext.operationName || '');\n\n            const generatedOperationDerivedData: OperationDerivedData = {\n              signature: generatedSignature,\n              referencedFieldsByType: calculateReferencedFieldsByType({\n                document: requestContext.document,\n                schema,\n                resolvedOperationName: requestContext.operationName ?? null,\n              }),\n            };\n\n            // Note that this cache is always an in-memory cache.\n            // If we replace it with a more generic async cache, we should\n            // not await the write operation.\n            operationDerivedDataCache.cache.set(\n              cacheKey,\n              generatedOperationDerivedData,\n            );\n            return generatedOperationDerivedData;\n          }\n        }\n      };\n\n      return {\n        async serverWillStop() {\n          if (reportTimer) {\n            clearInterval(reportTimer);\n            reportTimer = undefined;\n          }\n\n          stopped = true;\n          await sendAllReportsAndReportErrors();\n        },\n      };\n    },\n  });\n}\n\nexport function makeHTTPRequestHeaders(\n  http: Trace.IHTTP,\n  headers: HeaderMap,\n  sendHeaders?: SendValuesBaseOptions,\n): void {\n  if (\n    !sendHeaders ||\n    ('none' in sendHeaders && sendHeaders.none) ||\n    ('all' in sendHeaders && !sendHeaders.all)\n  ) {\n    return;\n  }\n  for (const [key, value] of headers) {\n    // Note that HeaderMap keys are already lower-case.\n    if (\n      ('exceptNames' in sendHeaders &&\n        // We assume that most users only have a few headers to hide, or will\n        // just set {none: true} ; we can change this linear-time\n        // operation if it causes real performance issues.\n        sendHeaders.exceptNames.some((exceptHeader) => {\n          // Headers are case-insensitive, and should be compared as such.\n          return exceptHeader.toLowerCase() === key;\n        })) ||\n      ('onlyNames' in sendHeaders &&\n        !sendHeaders.onlyNames.some((header) => {\n          return header.toLowerCase() === key;\n        }))\n    ) {\n      continue;\n    }\n\n    switch (key) {\n      case 'authorization':\n      case 'cookie':\n      case 'set-cookie':\n        break;\n      default:\n        http!.requestHeaders![key] = new Trace.HTTP.Values({\n          value: [value],\n        });\n    }\n  }\n}\n\nfunction defaultGenerateClientInfo<TContext extends BaseContext>({\n  request,\n}: GraphQLRequestContext<TContext>) {\n  const clientNameHeaderKey = 'apollographql-client-name';\n  const clientVersionHeaderKey = 'apollographql-client-version';\n\n  // Default to using the `apollo-client-x` header fields if present.\n  // If none are present, fallback on the `clientInfo` query extension\n  // for backwards compatibility.\n  // The default value if neither header values nor query extension is\n  // set is the empty String for all fields (as per protobuf defaults)\n  if (\n    request.http?.headers?.get(clientNameHeaderKey) ||\n    request.http?.headers?.get(clientVersionHeaderKey)\n  ) {\n    return {\n      clientName: request.http?.headers?.get(clientNameHeaderKey),\n      clientVersion: request.http?.headers?.get(clientVersionHeaderKey),\n    };\n  } else if (request.extensions?.clientInfo) {\n    return request.extensions.clientInfo;\n  } else {\n    return {};\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2965, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2969, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@apollo/server/src/plugin/usageReporting/index.ts"],"sourcesContent":["export { ApolloServerPluginUsageReporting } from './plugin.js';\nexport type {\n  ApolloServerPluginUsageReportingOptions,\n  SendValuesBaseOptions,\n  VariableValueOptions,\n  SendErrorsOptions,\n  ClientInfo,\n  GenerateClientInfo,\n} from './options.js';\n"],"names":[],"mappings":";;;;;AAAA,IAAA;AAAS,OAAA,cAAA,CAAA,SAAA,oCAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,YAAA,gCAAgC;IAAA;AAAA"}},
    {"offset": {"line": 2981, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2985, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@apollo/server/src/plugin/schemaReporting/schemaReporter.ts"],"sourcesContent":["import fetch from 'node-fetch';\nimport type { GraphQLRequest } from '../../externalTypes/index.js';\nimport type { Logger } from '@apollo/utils.logger';\nimport type {\n  SchemaReport,\n  SchemaReportMutationVariables,\n  SchemaReportMutation,\n  ReportSchemaResponse,\n} from './generated/operations';\nimport type { Fetcher } from '@apollo/utils.fetcher';\nimport { packageVersion } from '../../generated/packageVersion.js';\n\n// Magic GraphQL comment allows codegen to find the query\n// prettier-ignore\nexport const schemaReportGql = /* GraphQL */ `#graphql\n  mutation SchemaReport($report: SchemaReport!, $coreSchema: String) {\n    reportSchema(report: $report, coreSchema: $coreSchema) {\n      __typename\n      ... on ReportSchemaError {\n        message\n        code\n      }\n      ... on ReportSchemaResponse {\n        inSeconds\n        withCoreSchema\n      }\n    }\n  }\n`;\n\n// This class is meant to be a thin shim around the gql mutations.\nexport class SchemaReporter {\n  // These mirror the gql variables\n  private readonly schemaReport: SchemaReport;\n  private readonly coreSchema: string;\n  private readonly endpointUrl: string;\n  private readonly logger: Logger;\n  private readonly initialReportingDelayInMs: number;\n  private readonly fallbackReportingDelayInMs: number;\n  private readonly fetcher: Fetcher;\n\n  private isStopped: boolean;\n  private pollTimer?: NodeJS.Timeout;\n  private readonly headers: Record<string, string>;\n\n  constructor(options: {\n    schemaReport: SchemaReport;\n    coreSchema: string;\n    apiKey: string;\n    endpointUrl: string | undefined;\n    logger: Logger;\n    initialReportingDelayInMs: number;\n    fallbackReportingDelayInMs: number;\n    fetcher?: Fetcher;\n  }) {\n    this.headers = {\n      'Content-Type': 'application/json',\n      'x-api-key': options.apiKey,\n      'apollographql-client-name': 'ApolloServerPluginSchemaReporting',\n      'apollographql-client-version': packageVersion,\n    };\n\n    this.endpointUrl =\n      options.endpointUrl ||\n      'https://schema-reporting.api.apollographql.com/api/graphql';\n\n    this.schemaReport = options.schemaReport;\n    this.coreSchema = options.coreSchema;\n    this.isStopped = false;\n    this.logger = options.logger;\n    this.initialReportingDelayInMs = options.initialReportingDelayInMs;\n    this.fallbackReportingDelayInMs = options.fallbackReportingDelayInMs;\n    this.fetcher = options.fetcher ?? fetch;\n  }\n\n  public stopped(): boolean {\n    return this.isStopped;\n  }\n\n  public start() {\n    this.pollTimer = setTimeout(\n      () => this.sendOneReportAndScheduleNext(false),\n      this.initialReportingDelayInMs,\n    );\n  }\n\n  public stop() {\n    this.isStopped = true;\n    if (this.pollTimer) {\n      clearTimeout(this.pollTimer);\n      this.pollTimer = undefined;\n    }\n  }\n\n  private async sendOneReportAndScheduleNext(sendNextWithCoreSchema: boolean) {\n    this.pollTimer = undefined;\n\n    // Bail out permanently\n    if (this.stopped()) return;\n    try {\n      const result = await this.reportSchema(sendNextWithCoreSchema);\n      if (!result) {\n        return;\n      }\n      if (!this.stopped()) {\n        this.pollTimer = setTimeout(\n          () => this.sendOneReportAndScheduleNext(result.withCoreSchema),\n          result.inSeconds * 1000,\n        );\n      }\n      return;\n    } catch (error) {\n      // In the case of an error we want to continue looping\n      // We can add hardcoded backoff in the future,\n      // or on repeated failures stop responding reporting.\n      this.logger.error(\n        `Error reporting server info to Apollo during schema reporting: ${error}`,\n      );\n      if (!this.stopped()) {\n        this.pollTimer = setTimeout(\n          () => this.sendOneReportAndScheduleNext(false),\n          this.fallbackReportingDelayInMs,\n        );\n      }\n    }\n  }\n\n  public async reportSchema(\n    withCoreSchema: boolean,\n  ): Promise<ReportSchemaResponse | null> {\n    const { data, errors } = await this.apolloQuery({\n      report: this.schemaReport,\n      coreSchema: withCoreSchema ? this.coreSchema : null,\n    });\n\n    if (errors) {\n      throw new Error(errors.map((x: any) => x.message).join('\\n'));\n    }\n\n    function msgForUnexpectedResponse(data: any): string {\n      return [\n        'Unexpected response shape from Apollo when',\n        'reporting schema. If this continues, please reach',\n        'out to support@apollographql.com.',\n        'Received response:',\n        JSON.stringify(data),\n      ].join(' ');\n    }\n\n    if (!data || !data.reportSchema) {\n      throw new Error(msgForUnexpectedResponse(data));\n    }\n\n    if (data.reportSchema.__typename === 'ReportSchemaResponse') {\n      return data.reportSchema;\n    } else if (data.reportSchema.__typename === 'ReportSchemaError') {\n      this.logger.error(\n        [\n          'Received input validation error from Apollo:',\n          data.reportSchema.message,\n          'Stopping reporting. Please fix the input errors.',\n        ].join(' '),\n      );\n      this.stop();\n      return null;\n    }\n    throw new Error(msgForUnexpectedResponse(data));\n  }\n\n  private async apolloQuery(\n    variables: SchemaReportMutationVariables,\n  ): Promise<{ data?: SchemaReportMutation; errors?: any[] }> {\n    const request: GraphQLRequest = {\n      query: schemaReportGql,\n      variables,\n    };\n\n    const httpResponse = await this.fetcher(this.endpointUrl, {\n      method: 'POST',\n      headers: this.headers,\n      body: JSON.stringify(request),\n    });\n\n    if (!httpResponse.ok) {\n      throw new Error(\n        [\n          `An unexpected HTTP status code (${httpResponse.status}) was`,\n          'encountered during schema reporting.',\n        ].join(' '),\n      );\n    }\n\n    try {\n      // JSON parsing failure due to malformed data is the likely failure case\n      // here.  Any non-JSON response (e.g. HTML) is usually the suspect.\n      return await httpResponse.json();\n    } catch (error) {\n      throw new Error(\n        [\n          \"Couldn't report schema to Apollo.\",\n          'Parsing response as JSON failed.',\n          'If this continues please reach out to support@apollographql.com',\n          error,\n        ].join(' '),\n      );\n    }\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3123, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3127, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@apollo/server/src/plugin/schemaReporting/index.ts"],"sourcesContent":["import os from 'os';\nimport { internalPlugin } from '../../internalPlugin.js';\nimport { v4 as uuidv4 } from 'uuid';\nimport { printSchema, validateSchema, buildSchema } from 'graphql';\nimport { SchemaReporter } from './schemaReporter.js';\nimport { schemaIsSubgraph } from '../schemaIsSubgraph.js';\nimport type { SchemaReport } from './generated/operations.js';\nimport type { ApolloServerPlugin } from '../../externalTypes/index.js';\nimport type { Fetcher } from '@apollo/utils.fetcher';\nimport { packageVersion } from '../../generated/packageVersion.js';\nimport { computeCoreSchemaHash } from '../../utils/computeCoreSchemaHash.js';\n\nexport interface ApolloServerPluginSchemaReportingOptions {\n  /**\n   * The schema reporter waits before starting reporting.\n   * By default, the report waits some random amount of time between 0 and 10 seconds.\n   * A longer interval leads to more staggered starts which means it is less likely\n   * multiple servers will get asked to upload the same schema.\n   *\n   * If this server runs in lambda or in other constrained environments it would be useful\n   * to decrease the schema reporting max wait time to be less than default.\n   *\n   * This number will be the max for the range in ms that the schema reporter will\n   * wait before starting to report.\n   */\n  initialDelayMaxMs?: number;\n  /**\n   * Override the reported schema that is reported to the Apollo registry. This\n   * schema does not go through any normalizations and the string is directly\n   * sent to the Apollo registry. This can be useful for comments or other\n   * ordering and whitespace changes that get stripped when generating a\n   * `GraphQLSchema`.\n   *\n   * **If you pass this option to this plugin, you should explicitly configure\n   * `ApolloServerPluginUsageReporting` and pass the same value to its\n   * `overrideReportedSchema` option.** This ensures that the schema ID\n   * associated with requests reported by the usage reporting plugin matches the\n   * schema ID that this plugin reports. For example:\n   *\n   * ```js\n   * new ApolloServer({\n   *   plugins: [\n   *     ApolloServerPluginSchemaReporting({overrideReportedSchema: schema}),\n   *     ApolloServerPluginUsageReporting({overrideReportedSchema: schema}),\n   *   ],\n   * })\n   * ```\n   */\n  overrideReportedSchema?: string;\n  /**\n   * The URL to use for reporting schemas. Primarily for testing and internal\n   * Apollo use.\n   */\n  endpointUrl?: string;\n  /**\n   * Specifies which Fetch API implementation to use when reporting schemas.\n   */\n  fetcher?: Fetcher;\n}\n\nexport function ApolloServerPluginSchemaReporting(\n  {\n    initialDelayMaxMs,\n    overrideReportedSchema,\n    endpointUrl,\n    fetcher,\n  }: ApolloServerPluginSchemaReportingOptions = Object.create(null),\n): ApolloServerPlugin {\n  const bootId = uuidv4();\n\n  return internalPlugin({\n    __internal_plugin_id__: 'SchemaReporting',\n    __is_disabled_plugin__: false,\n    async serverWillStart({ apollo, schema, logger }) {\n      const { key, graphRef } = apollo;\n      if (!key) {\n        throw Error(\n          'To use ApolloServerPluginSchemaReporting, you must provide an Apollo API ' +\n            'key, via the APOLLO_KEY environment variable or via `new ApolloServer({apollo: {key})`',\n        );\n      }\n      if (!graphRef) {\n        // This error is a bit imprecise as you can also specify ID and variant separately,\n        // or rely on API-key parsing (before AS3), but this is \"best practices\".\n        throw Error(\n          'To use ApolloServerPluginSchemaReporting, you must provide your graph ref (eg, ' +\n            \"'my-graph-id@my-graph-variant'). Try setting the APOLLO_GRAPH_REF environment \" +\n            'variable or passing `new ApolloServer({apollo: {graphRef}})`.',\n        );\n      }\n\n      // Ensure a provided override schema can be parsed and validated\n      if (overrideReportedSchema) {\n        try {\n          const validationErrors = validateSchema(\n            buildSchema(overrideReportedSchema, { noLocation: true }),\n          );\n          if (validationErrors.length) {\n            throw new Error(\n              validationErrors.map((error) => error.message).join('\\n'),\n            );\n          }\n        } catch (err) {\n          throw new Error(\n            'The schema provided to overrideReportedSchema failed to parse or ' +\n              `validate: ${(err as Error).message}`,\n          );\n        }\n      }\n\n      if (schemaIsSubgraph(schema)) {\n        throw Error(\n          [\n            'Schema reporting is not yet compatible with Apollo Federation subgraphs.',\n            \"If you're interested in using schema reporting with subgraphs,\",\n            'please contact Apollo support. To set up managed federation, see',\n            'https://go.apollo.dev/s/managed-federation',\n          ].join(' '),\n        );\n      }\n\n      if (endpointUrl !== undefined) {\n        logger.info(\n          `Apollo schema reporting: schema reporting URL override: ${endpointUrl}`,\n        );\n      }\n\n      const baseSchemaReport: Omit<SchemaReport, 'coreSchemaHash'> = {\n        bootId,\n        graphRef,\n        // The infra environment in which this edge server is running, e.g. localhost, Kubernetes\n        // Length must be <= 256 characters.\n        platform: process.env.APOLLO_SERVER_PLATFORM || 'local',\n        runtimeVersion: `node ${process.version}`,\n        // An identifier used to distinguish the version of the server code such as git or docker sha.\n        // Length must be <= 256 characters\n        userVersion: process.env.APOLLO_SERVER_USER_VERSION,\n        // \"An identifier for the server instance. Length must be <= 256 characters.\n        serverId:\n          process.env.APOLLO_SERVER_ID || process.env.HOSTNAME || os.hostname(),\n        libraryVersion: `@apollo/server@${packageVersion}`,\n      };\n      let currentSchemaReporter: SchemaReporter | undefined;\n\n      return {\n        schemaDidLoadOrUpdate({ apiSchema, coreSupergraphSdl }): void {\n          if (overrideReportedSchema !== undefined) {\n            if (currentSchemaReporter) {\n              // When the schema to report has been overridden, there is no need\n              // to create a new schema reporter.\n              return;\n            } else {\n              logger.info(\n                'Apollo schema reporting: schema to report has been overridden',\n              );\n            }\n          }\n\n          const coreSchema =\n            overrideReportedSchema ??\n            coreSupergraphSdl ??\n            printSchema(apiSchema);\n          const coreSchemaHash = computeCoreSchemaHash(coreSchema);\n          const schemaReport: SchemaReport = {\n            ...baseSchemaReport,\n            coreSchemaHash,\n          };\n\n          currentSchemaReporter?.stop();\n          currentSchemaReporter = new SchemaReporter({\n            schemaReport,\n            coreSchema,\n            apiKey: key,\n            endpointUrl,\n            logger,\n            // Jitter the startup between 0 and 10 seconds\n            initialReportingDelayInMs: Math.floor(\n              Math.random() * (initialDelayMaxMs ?? 10_000),\n            ),\n            fallbackReportingDelayInMs: 20_000,\n            fetcher,\n          });\n          currentSchemaReporter.start();\n\n          logger.info(\n            'Apollo schema reporting: reporting a new schema to Studio! See your graph at ' +\n              `https://studio.apollographql.com/graph/${encodeURI(\n                graphRef,\n              )}/ with server info ${JSON.stringify(schemaReport)}`,\n          );\n        },\n        async serverWillStop() {\n          currentSchemaReporter?.stop();\n        },\n      };\n    },\n  });\n}\n"],"names":[],"mappings":";;;;;;;;;;AAAA,MAAA,OAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AAIA,MAAA;AACA,MAAA;AAkDA,SAAgB,kCACd,EACE,iBAAiB,EACjB,sBAAsB,EACtB,WAAW,EACX,OAAO,EAAA,GACqC,OAAO,MAAM,CAAC,KAAK;IAEjE,MAAM,SAAS,CAAA,GAAA,OAAA,EAAM;IAErB,OAAO,CAAA,GAAA,oBAAA,cAAc,EAAC;QACpB,wBAAwB;QACxB,wBAAwB;QACxB,MAAM,iBAAgB,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE;YAC9C,MAAM,EAAE,GAAG,EAAE,QAAQ,EAAE,GAAG;YAC1B,IAAI,CAAC,KAAK;gBACR,MAAM,MACJ,8EACE;YAEN;YACA,IAAI,CAAC,UAAU;gBAGb,MAAM,MACJ,oFACE,mFACA;YAEN;YAGA,IAAI,wBAAwB;gBAC1B,IAAI;oBACF,MAAM,mBAAmB,CAAA,GAAA,UAAA,cAAc,EACrC,CAAA,GAAA,UAAA,WAAW,EAAC,wBAAwB;wBAAE,YAAY;oBAAI;oBAExD,IAAI,iBAAiB,MAAM,EAAE;wBAC3B,MAAM,IAAI,MACR,iBAAiB,GAAG,CAAC,CAAC,QAAU,MAAM,OAAO,EAAE,IAAI,CAAC;oBAExD;gBACF,EAAE,OAAO,KAAK;oBACZ,MAAM,IAAI,MACR,sEACE,CAAA,UAAA,EAAc,IAAc,OAAO,CAAA,CAAE;gBAE3C;YACF;YAEA,IAAI,CAAA,GAAA,sBAAA,gBAAgB,EAAC,SAAS;gBAC5B,MAAM,MACJ;oBACE;oBACA;oBACA;oBACA;iBACD,CAAC,IAAI,CAAC;YAEX;YAEA,IAAI,gBAAgB,WAAW;gBAC7B,OAAO,IAAI,CACT,CAAA,wDAAA,EAA2D,YAAW,CAAE;YAE5E;YAEA,MAAM,mBAAyD;gBAC7D;gBACA;gBAGA,UAAU,QAAQ,GAAG,CAAC,sBAAsB,IAAI;gBAChD,gBAAgB,CAAA,KAAA,EAAQ,QAAQ,OAAO,CAAA,CAAE;gBAGzC,aAAa,QAAQ,GAAG,CAAC,0BAA0B;gBAEnD,UACE,QAAQ,GAAG,CAAC,gBAAgB,IAAI,QAAQ,GAAG,CAAC,QAAQ,IAAI,KAAA,OAAE,CAAC,QAAQ;gBACrE,gBAAgB,CAAA,eAAA,EAAkB,oBAAA,cAAc,CAAA,CAAE;;YAEpD,IAAI;YAEJ,OAAO;gBACL,uBAAsB,EAAE,SAAS,EAAE,iBAAiB,EAAE;oBACpD,IAAI,2BAA2B,WAAW;wBACxC,IAAI,uBAAuB;4BAGzB;wBACF,OAAO;4BACL,OAAO,IAAI,CACT;wBAEJ;oBACF;oBAEA,MAAM,aACJ,0BACA,qBACA,CAAA,GAAA,UAAA,WAAW,EAAC;oBACd,MAAM,iBAAiB,CAAA,GAAA,2BAAA,qBAAqB,EAAC;oBAC7C,MAAM,eAA6B;wBACjC,GAAG,gBAAgB;wBACnB;;oBAGF,uBAAuB;oBACvB,wBAAwB,IAAI,oBAAA,cAAc,CAAC;wBACzC;wBACA;wBACA,QAAQ;wBACR;wBACA;wBAEA,2BAA2B,KAAK,KAAK,CACnC,KAAK,MAAM,KAAK,CAAC,qBAAqB,KAAM;wBAE9C,4BAA4B;wBAC5B;;oBAEF,sBAAsB,KAAK;oBAE3B,OAAO,IAAI,CACT,kFACE,CAAA,uCAAA,EAA0C,UACxC,UACD,mBAAA,EAAsB,KAAK,SAAS,CAAC,cAAa,CAAE;gBAE3D;gBACA,MAAM;oBACJ,uBAAuB;gBACzB;;QAEJ;;AAEJ;AAzIA,QAAA,iCAAA,GAAA"}},
    {"offset": {"line": 3228, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3232, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@apollo/server/src/plugin/inlineTrace/index.ts"],"sourcesContent":["import { Trace } from '@apollo/usage-reporting-protobuf';\nimport { TraceTreeBuilder } from '../traceTreeBuilder.js';\nimport type { SendErrorsOptions } from '../usageReporting/index.js';\nimport { internalPlugin } from '../../internalPlugin.js';\nimport { schemaIsSubgraph } from '../schemaIsSubgraph.js';\nimport type { ApolloServerPlugin } from '../../externalTypes/index.js';\n\nexport interface ApolloServerPluginInlineTraceOptions {\n  /**\n   * By default, if a trace contains errors, the errors are included in the\n   * trace with the message `<masked>`. The errors are associated with specific\n   * paths in the operation, but do not include the original error message or\n   * any extensions such as the error `code`, as those details may contain your\n   * users' private data. The extension `maskedBy:\n   * 'ApolloServerPluginInlineTrace'` is added.\n   *\n   * If you'd like details about the error included in traces, set this option.\n   * This option can take several forms:\n   *\n   * - { masked: true }: mask error messages and omit extensions (DEFAULT)\n   * - { unmodified: true }: include all error messages and extensions\n   * - { transform: ... }: a custom function for transforming errors. This\n   *   function receives a `GraphQLError` and may return a `GraphQLError`\n   *   (either a new error, or its potentially-modified argument) or `null`.\n   *   This error is used in the trace; if `null`, the error is not included in\n   *   traces or error statistics.\n   */\n  includeErrors?: SendErrorsOptions;\n  /**\n   * This option is for internal use by `@apollo/server` only.\n   *\n   * By default we want to enable this plugin for subgraph schemas only, but we\n   * need to come up with our list of plugins before we have necessarily loaded\n   * the schema. So (unless the user installs this plugin or\n   * ApolloServerPluginInlineTraceDisabled themselves), `@apollo/server` always\n   * installs this plugin and uses this option to make sure traces are only\n   * included if the schema appears to be a subgraph.\n   */\n  __onlyIfSchemaIsSubgraph?: boolean;\n}\n\n// This ftv1 plugin produces a base64'd Trace protobuf containing only the\n// durationNs, startTime, endTime, and root fields.  This output is placed\n// on the `extensions`.`ftv1` property of the response.  The Apollo Gateway\n// utilizes this data to construct the full trace and submit it to Apollo's\n// usage reporting ingress.\nexport function ApolloServerPluginInlineTrace(\n  options: ApolloServerPluginInlineTraceOptions = Object.create(null),\n): ApolloServerPlugin {\n  let enabled: boolean | null = options.__onlyIfSchemaIsSubgraph ? null : true;\n  return internalPlugin({\n    __internal_plugin_id__: 'InlineTrace',\n    __is_disabled_plugin__: false,\n    async serverWillStart({ schema, logger }) {\n      // Handle the case that the plugin was implicitly installed. We only want it\n      // to actually be active if the schema appears to be federated. If you don't\n      // like the log line, just install `ApolloServerPluginInlineTrace()` in\n      // `plugins` yourself.\n      if (enabled === null) {\n        enabled = schemaIsSubgraph(schema);\n        if (enabled) {\n          logger.info(\n            'Enabling inline tracing for this subgraph. To disable, use ' +\n              'ApolloServerPluginInlineTraceDisabled.',\n          );\n        }\n      }\n    },\n    async requestDidStart({ request: { http }, metrics }) {\n      if (!enabled) {\n        return;\n      }\n\n      const treeBuilder = new TraceTreeBuilder({\n        maskedBy: 'ApolloServerPluginInlineTrace',\n        sendErrors: options.includeErrors,\n      });\n\n      // XXX Provide a mechanism to customize this logic.\n      if (http?.headers.get('apollo-federation-include-trace') !== 'ftv1') {\n        return;\n      }\n\n      // If some other (user-written?) plugin already decided that we are not\n      // capturing traces, then we should not capture traces.\n      if (metrics.captureTraces === false) {\n        return;\n      }\n\n      // Note that this will override any `fieldLevelInstrumentation` parameter\n      // to the usage reporting plugin for requests with the\n      // `apollo-federation-include-trace` header set.\n      metrics.captureTraces = true;\n\n      treeBuilder.startTiming();\n\n      return {\n        async executionDidStart() {\n          return {\n            willResolveField({ info }) {\n              return treeBuilder.willResolveField(info);\n            },\n          };\n        },\n\n        async didEncounterErrors({ errors }) {\n          treeBuilder.didEncounterErrors(errors);\n        },\n\n        async willSendResponse({ response }) {\n          // We record the end time at the latest possible time: right before serializing the trace.\n          // If we wait any longer, the time we record won't actually be sent anywhere!\n          treeBuilder.stopTiming();\n\n          // For now, we don't support inline traces on incremental delivery\n          // responses. (We could perhaps place the trace on the final chunk, or\n          // even deliver it bit by bit. For now, since Gateway does not support\n          // incremental delivery and Router does not pass through defers to\n          // subgraphs, this doesn't affect the \"federated tracing\" use case,\n          // though it does affect the ability to look at inline traces in other\n          // tools like Explorer.\n          if (response.body.kind === 'incremental') {\n            return;\n          }\n\n          // If we're in a gateway, include the query plan (and subgraph traces)\n          // in the inline trace. This is designed more for manually querying\n          // your graph while running locally to see what the query planner is\n          // doing rather than for running in production.\n          if (metrics.queryPlanTrace) {\n            treeBuilder.trace.queryPlan = metrics.queryPlanTrace;\n          }\n\n          const encodedUint8Array = Trace.encode(treeBuilder.trace).finish();\n          const encodedBuffer = Buffer.from(\n            encodedUint8Array,\n            encodedUint8Array.byteOffset,\n            encodedUint8Array.byteLength,\n          );\n\n          const extensions =\n            response.body.singleResult.extensions ||\n            (response.body.singleResult.extensions = Object.create(null));\n\n          // This should only happen if another plugin is using the same name-\n          // space within the `extensions` object and got to it before us.\n          if (typeof extensions.ftv1 !== 'undefined') {\n            throw new Error('The `ftv1` extension was already present.');\n          }\n\n          extensions.ftv1 = encodedBuffer.toString('base64');\n        },\n      };\n    },\n  });\n}\n"],"names":[],"mappings":";;;;;AAAA,MAAA;AACA,MAAA;AAEA,MAAA;AACA,MAAA;AA0CA,SAAgB,8BACd,UAAgD,OAAO,MAAM,CAAC,KAAK;IAEnE,IAAI,UAA0B,QAAQ,wBAAwB,GAAG,OAAO;IACxE,OAAO,CAAA,GAAA,oBAAA,cAAc,EAAC;QACpB,wBAAwB;QACxB,wBAAwB;QACxB,MAAM,iBAAgB,EAAE,MAAM,EAAE,MAAM,EAAE;YAKtC,IAAI,YAAY,MAAM;gBACpB,UAAU,CAAA,GAAA,sBAAA,gBAAgB,EAAC;gBAC3B,IAAI,SAAS;oBACX,OAAO,IAAI,CACT,gEACE;gBAEN;YACF;QACF;QACA,MAAM,iBAAgB,EAAE,SAAS,EAAE,IAAI,EAAE,EAAE,OAAO,EAAE;YAClD,IAAI,CAAC,SAAS;gBACZ;YACF;YAEA,MAAM,cAAc,IAAI,sBAAA,gBAAgB,CAAC;gBACvC,UAAU;gBACV,YAAY,QAAQ,aAAa;;YAInC,IAAI,MAAM,QAAQ,IAAI,uCAAuC,QAAQ;gBACnE;YACF;YAIA,IAAI,QAAQ,aAAa,KAAK,OAAO;gBACnC;YACF;YAKA,QAAQ,aAAa,GAAG;YAExB,YAAY,WAAW;YAEvB,OAAO;gBACL,MAAM;oBACJ,OAAO;wBACL,kBAAiB,EAAE,IAAI,EAAE;4BACvB,OAAO,YAAY,gBAAgB,CAAC;wBACtC;;gBAEJ;gBAEA,MAAM,oBAAmB,EAAE,MAAM,EAAE;oBACjC,YAAY,kBAAkB,CAAC;gBACjC;gBAEA,MAAM,kBAAiB,EAAE,QAAQ,EAAE;oBAGjC,YAAY,UAAU;oBAStB,IAAI,SAAS,IAAI,CAAC,IAAI,KAAK,eAAe;wBACxC;oBACF;oBAMA,IAAI,QAAQ,cAAc,EAAE;wBAC1B,YAAY,KAAK,CAAC,SAAS,GAAG,QAAQ,cAAc;oBACtD;oBAEA,MAAM,oBAAoB,2BAAA,KAAK,CAAC,MAAM,CAAC,YAAY,KAAK,EAAE,MAAM;oBAChE,MAAM,gBAAgB,OAAO,IAAI,CAC/B,mBACA,kBAAkB,UAAU,EAC5B,kBAAkB,UAAU;oBAG9B,MAAM,aACJ,SAAS,IAAI,CAAC,YAAY,CAAC,UAAU,IACrC,CAAC,SAAS,IAAI,CAAC,YAAY,CAAC,UAAU,GAAG,OAAO,MAAM,CAAC,KAAK;oBAI9D,IAAI,OAAO,WAAW,IAAI,KAAK,aAAa;wBAC1C,MAAM,IAAI,MAAM;oBAClB;oBAEA,WAAW,IAAI,GAAG,cAAc,QAAQ,CAAC;gBAC3C;;QAEJ;;AAEJ;AA7GA,QAAA,6BAAA,GAAA"}},
    {"offset": {"line": 3302, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3306, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@apollo/server/src/plugin/landingPage/default/getEmbeddedHTML.ts"],"sourcesContent":["import type {\n  ApolloServerPluginEmbeddedLandingPageLocalDefaultOptions,\n  ApolloServerPluginEmbeddedLandingPageProductionDefaultOptions,\n} from './types';\n\n// This function turns an object into a string and replaces\n// <, >, &, ' with their unicode chars to avoid adding html tags to\n// the landing page html that might be passed from the config.\n// The only place these characters can appear in the output of\n// JSON.stringify is within string literals, where they can equally\n// well appear \\u-escaped. This specifically means that\n// `</script>` won't terminate the script block early.\n// (Perhaps we should have done this instead of the triple-encoding\n// of encodeConfig for the main landing page.)\nfunction getConfigStringForHtml(config: object) {\n  return JSON.stringify(config)\n    .replace('<', '\\\\u003c')\n    .replace('>', '\\\\u003e')\n    .replace('&', '\\\\u0026')\n    .replace(\"'\", '\\\\u0027');\n}\n\nexport const getEmbeddedExplorerHTML = (\n  explorerCdnVersion: string,\n  config: ApolloServerPluginEmbeddedLandingPageProductionDefaultOptions,\n  apolloServerVersion: string,\n  nonce: string,\n) => {\n  interface EmbeddableExplorerOptions {\n    graphRef: string;\n    target: string;\n\n    initialState?: {\n      document?: string;\n      variables?: Record<string, any>;\n      headers?: Record<string, string>;\n      collectionId?: string;\n      operationId?: string;\n      displayOptions: {\n        docsPanelState?: 'open' | 'closed'; // default to 'open',\n        showHeadersAndEnvVars?: boolean; // default to `false`\n        theme?: 'dark' | 'light';\n      };\n    };\n    persistExplorerState?: boolean; // defaults to 'false'\n\n    endpointUrl: string;\n\n    includeCookies?: boolean; // defaults to 'false'\n\n    runTelemetry?: boolean;\n\n    allowDynamicStyles?: boolean; // defaults to 'true'\n  }\n  const productionLandingPageEmbedConfigOrDefault = {\n    displayOptions: {},\n    persistExplorerState: false,\n    runTelemetry: true,\n    ...(typeof config.embed === 'boolean' ? {} : config.embed),\n  };\n  const embeddedExplorerParams: Omit<\n    EmbeddableExplorerOptions,\n    'endpointUrl'\n  > & { runtime: string } = {\n    graphRef: config.graphRef,\n    target: '#embeddableExplorer',\n    initialState: {\n      ...('document' in config || 'headers' in config || 'variables' in config\n        ? {\n            document: config.document,\n            headers: config.headers,\n            variables: config.variables,\n          }\n        : {}),\n      ...('collectionId' in config\n        ? {\n            collectionId: config.collectionId,\n            operationId: config.operationId,\n          }\n        : {}),\n      displayOptions: {\n        ...productionLandingPageEmbedConfigOrDefault.displayOptions,\n      },\n    },\n    persistExplorerState:\n      productionLandingPageEmbedConfigOrDefault.persistExplorerState,\n    includeCookies: config.includeCookies,\n    runtime: apolloServerVersion,\n    runTelemetry: productionLandingPageEmbedConfigOrDefault.runTelemetry,\n    allowDynamicStyles: false, // disabled for CSP - we add the iframe styles ourselves instead\n  };\n\n  return `\n<div class=\"fallback\">\n  <h1>Welcome to Apollo Server</h1>\n  <p>Apollo Explorer cannot be loaded; it appears that you might be offline.</p>\n</div>\n<style nonce=${nonce}>\n  iframe {\n    background-color: white;\n    height: 100%;\n    width: 100%;\n    border: none;\n  }\n  #embeddableExplorer {\n    width: 100vw;\n    height: 100vh;\n    position: absolute;\n    top: 0;\n  }\n</style>\n<div id=\"embeddableExplorer\"></div>\n<script nonce=\"${nonce}\" src=\"https://embeddable-explorer.cdn.apollographql.com/${encodeURIComponent(\n    explorerCdnVersion,\n  )}/embeddable-explorer.umd.production.min.js?runtime=${encodeURIComponent(\n    apolloServerVersion,\n  )}\"></script>\n<script nonce=\"${nonce}\">\n  var endpointUrl = window.location.href;\n  var embeddedExplorerConfig = ${getConfigStringForHtml(\n    embeddedExplorerParams,\n  )};\n  new window.EmbeddedExplorer({\n    ...embeddedExplorerConfig,\n    endpointUrl,\n  });\n</script>\n`;\n};\n\nexport const getEmbeddedSandboxHTML = (\n  sandboxCdnVersion: string,\n  config: ApolloServerPluginEmbeddedLandingPageLocalDefaultOptions,\n  apolloServerVersion: string,\n  nonce: string,\n) => {\n  const localDevelopmentEmbedConfigOrDefault = {\n    runTelemetry: true,\n    endpointIsEditable: false,\n    initialState: {},\n    ...(typeof config.embed === 'boolean' ? {} : config.embed ?? {}),\n  };\n  const embeddedSandboxConfig = {\n    target: '#embeddableSandbox',\n    initialState: {\n      ...('document' in config || 'headers' in config || 'variables' in config\n        ? {\n            document: config.document,\n            variables: config.variables,\n            headers: config.headers,\n          }\n        : {}),\n      ...('collectionId' in config\n        ? {\n            collectionId: config.collectionId,\n            operationId: config.operationId,\n          }\n        : {}),\n      includeCookies: config.includeCookies,\n      ...localDevelopmentEmbedConfigOrDefault.initialState,\n    },\n    hideCookieToggle: false,\n    endpointIsEditable: localDevelopmentEmbedConfigOrDefault.endpointIsEditable,\n    runtime: apolloServerVersion,\n    runTelemetry: localDevelopmentEmbedConfigOrDefault.runTelemetry,\n    allowDynamicStyles: false, // disabled for CSP - we add the iframe styles ourselves instead\n  };\n  return `\n<div class=\"fallback\">\n  <h1>Welcome to Apollo Server</h1>\n  <p>Apollo Sandbox cannot be loaded; it appears that you might be offline.</p>\n</div>\n<style nonce=${nonce}>\n  iframe {\n    background-color: white;\n    height: 100%;\n    width: 100%;\n    border: none;\n  }\n  #embeddableSandbox {\n    width: 100vw;\n    height: 100vh;\n    position: absolute;\n    top: 0;\n  }\n</style>\n<div id=\"embeddableSandbox\"></div>\n<script nonce=\"${nonce}\" src=\"https://embeddable-sandbox.cdn.apollographql.com/${encodeURIComponent(\n    sandboxCdnVersion,\n  )}/embeddable-sandbox.umd.production.min.js?runtime=${encodeURIComponent(\n    apolloServerVersion,\n  )}\"></script>\n<script nonce=\"${nonce}\">\n  var initialEndpoint = window.location.href;\n  var embeddedSandboxConfig = ${getConfigStringForHtml(embeddedSandboxConfig)};\n  new window.EmbeddedSandbox(\n    {\n      ...embeddedSandboxConfig,\n      initialEndpoint,\n    }\n  );\n</script>\n`;\n};\n"],"names":[],"mappings":";;;;;AAcA,SAAS,uBAAuB,MAAc;IAC5C,OAAO,KAAK,SAAS,CAAC,QACnB,OAAO,CAAC,KAAK,WACb,OAAO,CAAC,KAAK,WACb,OAAO,CAAC,KAAK,WACb,OAAO,CAAC,KAAK;AAClB;AAEO,MAAM,0BAA0B,CACrC,oBACA,QACA,qBACA;IA4BA,MAAM,4CAA4C;QAChD,gBAAgB,CAAA;QAChB,sBAAsB;QACtB,cAAc;QACd,GAAI,OAAO,OAAO,KAAK,KAAK,YAAY,CAAA,IAAK,OAAO,KAAK;;IAE3D,MAAM,yBAGoB;QACxB,UAAU,OAAO,QAAQ;QACzB,QAAQ;QACR,cAAc;YACZ,GAAI,cAAc,UAAU,aAAa,UAAU,eAAe,SAC9D;gBACE,UAAU,OAAO,QAAQ;gBACzB,SAAS,OAAO,OAAO;gBACvB,WAAW,OAAO,SAAS;gBAE7B,CAAA,CAAE;YACN,GAAI,kBAAkB,SAClB;gBACE,cAAc,OAAO,YAAY;gBACjC,aAAa,OAAO,WAAW;gBAEjC,CAAA,CAAE;YACN,gBAAgB;gBACd,GAAG,0CAA0C,cAAc;;;QAG/D,sBACE,0CAA0C,oBAAoB;QAChE,gBAAgB,OAAO,cAAc;QACrC,SAAS;QACT,cAAc,0CAA0C,YAAY;QACpE,oBAAoB;;IAGtB,OAAO,CAAA;;;;;eAKM,MAAK;;;;;;;;;;;;;;;iBAeH,MAAK,yDAAA,EAA4D,mBAC9E,oBACD,mDAAA,EAAsD,mBACrD,qBACD;iBACc,MAAK;;iCAEW,uBAC7B,wBACD;;;;;;CAMF;AACD;AA1Ga,QAAA,uBAAuB,GAAA;AA4G7B,MAAM,yBAAyB,CACpC,mBACA,QACA,qBACA;IAEA,MAAM,uCAAuC;QAC3C,cAAc;QACd,oBAAoB;QACpB,cAAc,CAAA;QACd,GAAI,OAAO,OAAO,KAAK,KAAK,YAAY,CAAA,IAAK,OAAO,KAAK,IAAI,CAAA,CAAE;;IAEjE,MAAM,wBAAwB;QAC5B,QAAQ;QACR,cAAc;YACZ,GAAI,cAAc,UAAU,aAAa,UAAU,eAAe,SAC9D;gBACE,UAAU,OAAO,QAAQ;gBACzB,WAAW,OAAO,SAAS;gBAC3B,SAAS,OAAO,OAAO;gBAEzB,CAAA,CAAE;YACN,GAAI,kBAAkB,SAClB;gBACE,cAAc,OAAO,YAAY;gBACjC,aAAa,OAAO,WAAW;gBAEjC,CAAA,CAAE;YACN,gBAAgB,OAAO,cAAc;YACrC,GAAG,qCAAqC,YAAY;;QAEtD,kBAAkB;QAClB,oBAAoB,qCAAqC,kBAAkB;QAC3E,SAAS;QACT,cAAc,qCAAqC,YAAY;QAC/D,oBAAoB;;IAEtB,OAAO,CAAA;;;;;eAKM,MAAK;;;;;;;;;;;;;;;iBAeH,MAAK,wDAAA,EAA2D,mBAC7E,mBACD,kDAAA,EAAqD,mBACpD,qBACD;iBACc,MAAK;;gCAEU,uBAAuB,uBAAsB;;;;;;;;CAQ5E;AACD;AAzEa,QAAA,sBAAsB,GAAA"}},
    {"offset": {"line": 3438, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3442, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@apollo/server/src/plugin/landingPage/default/index.ts"],"sourcesContent":["import type {\n  ApolloServerPlugin,\n  BaseContext,\n} from '../../../externalTypes/index.js';\nimport type { ImplicitlyInstallablePlugin } from '../../../ApolloServer.js';\nimport type {\n  ApolloServerPluginLandingPageLocalDefaultOptions,\n  ApolloServerPluginLandingPageProductionDefaultOptions,\n  LandingPageConfig,\n} from './types.js';\nimport {\n  getEmbeddedExplorerHTML,\n  getEmbeddedSandboxHTML,\n} from './getEmbeddedHTML.js';\nimport { packageVersion } from '../../../generated/packageVersion.js';\nimport { createHash } from '@apollo/utils.createhash';\nimport { v4 as uuidv4 } from 'uuid';\n\nexport type {\n  ApolloServerPluginLandingPageLocalDefaultOptions,\n  ApolloServerPluginLandingPageProductionDefaultOptions,\n};\n\nexport function ApolloServerPluginLandingPageLocalDefault(\n  options: ApolloServerPluginLandingPageLocalDefaultOptions = {},\n): ApolloServerPlugin {\n  const { version, __internal_apolloStudioEnv__, ...rest } = {\n    // we default to Sandbox unless embed is specified as false\n    embed: true as const,\n    ...options,\n  };\n  return ApolloServerPluginLandingPageDefault(version, {\n    isProd: false,\n    apolloStudioEnv: __internal_apolloStudioEnv__,\n    ...rest,\n  });\n}\n\nexport function ApolloServerPluginLandingPageProductionDefault(\n  options: ApolloServerPluginLandingPageProductionDefaultOptions = {},\n): ApolloServerPlugin {\n  const { version, __internal_apolloStudioEnv__, ...rest } = options;\n  return ApolloServerPluginLandingPageDefault(version, {\n    isProd: true,\n    apolloStudioEnv: __internal_apolloStudioEnv__,\n    ...rest,\n  });\n}\n\n// A triple encoding! Wow! First we use JSON.stringify to turn our object into a\n// string. Then we encodeURIComponent so we don't have to stress about what\n// would happen if the config contained `</script>`. Finally, we JSON.stringify\n// it again, which in practice just wraps it in a pair of double quotes (since\n// there shouldn't be any backslashes left after encodeURIComponent). The\n// consumer of this needs to decodeURIComponent and then JSON.parse; there's\n// only one JSON.parse because the outermost JSON string is parsed by the JS\n// parser itself.\nfunction encodeConfig(config: LandingPageConfig): string {\n  return JSON.stringify(encodeURIComponent(JSON.stringify(config)));\n}\n\nconst getNonEmbeddedLandingPageHTML = (\n  cdnVersion: string,\n  config: LandingPageConfig,\n  apolloServerVersion: string,\n  nonce: string,\n) => {\n  const encodedConfig = encodeConfig(config);\n\n  return `\n <div class=\"fallback\">\n  <h1>Welcome to Apollo Server</h1>\n  <p>The full landing page cannot be loaded; it appears that you might be offline.</p>\n</div>\n<script nonce=\"${nonce}\">window.landingPage = ${encodedConfig};</script>\n<script nonce=\"${nonce}\" src=\"https://apollo-server-landing-page.cdn.apollographql.com/${encodeURIComponent(\n    cdnVersion,\n  )}/static/js/main.js?runtime=${apolloServerVersion}\"></script>`;\n};\n\nexport const DEFAULT_EMBEDDED_EXPLORER_VERSION = 'v3';\nexport const DEFAULT_EMBEDDED_SANDBOX_VERSION = 'v2';\nexport const DEFAULT_APOLLO_SERVER_LANDING_PAGE_VERSION = '_latest';\n\n// Helper for the two actual plugin functions.\nfunction ApolloServerPluginLandingPageDefault<TContext extends BaseContext>(\n  maybeVersion: string | undefined,\n  config: LandingPageConfig & {\n    isProd: boolean;\n    apolloStudioEnv: 'staging' | 'prod' | undefined;\n  },\n): ImplicitlyInstallablePlugin<TContext> {\n  const explorerVersion = maybeVersion ?? DEFAULT_EMBEDDED_EXPLORER_VERSION;\n  const sandboxVersion = maybeVersion ?? DEFAULT_EMBEDDED_SANDBOX_VERSION;\n  const apolloServerLandingPageVersion =\n    maybeVersion ?? DEFAULT_APOLLO_SERVER_LANDING_PAGE_VERSION;\n  const apolloServerVersion = `@apollo/server@${packageVersion}`;\n\n  const scriptSafeList = [\n    'https://apollo-server-landing-page.cdn.apollographql.com',\n    'https://embeddable-sandbox.cdn.apollographql.com',\n    'https://embeddable-explorer.cdn.apollographql.com',\n  ].join(' ');\n  const styleSafeList = [\n    'https://apollo-server-landing-page.cdn.apollographql.com',\n    'https://embeddable-sandbox.cdn.apollographql.com',\n    'https://embeddable-explorer.cdn.apollographql.com',\n    'https://fonts.googleapis.com',\n  ].join(' ');\n  const iframeSafeList = [\n    'https://explorer.embed.apollographql.com',\n    'https://sandbox.embed.apollographql.com',\n    'https://embed.apollo.local:3000',\n  ].join(' ');\n\n  return {\n    __internal_installed_implicitly__: false,\n    async serverWillStart(server) {\n      if (config.precomputedNonce) {\n        server.logger.warn(\n          \"The `precomputedNonce` landing page configuration option is deprecated. Removing this option is strictly an improvement to Apollo Server's landing page Content Security Policy (CSP) implementation for preventing XSS attacks.\",\n        );\n      }\n      return {\n        async renderLandingPage() {\n          const encodedASLandingPageVersion = encodeURIComponent(\n            apolloServerLandingPageVersion,\n          );\n          async function html() {\n            const nonce =\n              config.precomputedNonce ??\n              createHash('sha256').update(uuidv4()).digest('hex');\n            const scriptCsp = `script-src 'self' 'nonce-${nonce}' ${scriptSafeList}`;\n            const styleCsp = `style-src 'nonce-${nonce}' ${styleSafeList}`;\n            const imageCsp = `img-src https://apollo-server-landing-page.cdn.apollographql.com`;\n            const manifestCsp = `manifest-src https://apollo-server-landing-page.cdn.apollographql.com`;\n            const frameCsp = `frame-src ${iframeSafeList}`;\n            return `\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta http-equiv=\"Content-Security-Policy\" content=\"${scriptCsp}; ${styleCsp}; ${imageCsp}; ${manifestCsp}; ${frameCsp}\" />\n    <link\n      rel=\"icon\"\n      href=\"https://apollo-server-landing-page.cdn.apollographql.com/${encodedASLandingPageVersion}/assets/favicon.png\"\n    />\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n    <link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" />\n    <link\n      href=\"https://fonts.googleapis.com/css2?family=Source+Sans+Pro&display=swap\"\n      rel=\"stylesheet\"\n    />\n    <meta name=\"theme-color\" content=\"#000000\" />\n    <meta name=\"description\" content=\"Apollo server landing page\" />\n    <link\n      rel=\"apple-touch-icon\"\n      href=\"https://apollo-server-landing-page.cdn.apollographql.com/${encodedASLandingPageVersion}/assets/favicon.png\"\n    />\n    <link\n      rel=\"manifest\"\n      href=\"https://apollo-server-landing-page.cdn.apollographql.com/${encodedASLandingPageVersion}/manifest.json\"\n    />\n    <title>Apollo Server</title>\n  </head>\n  <body>\n    <noscript>You need to enable JavaScript to run this app.</noscript>\n    <div id=\"react-root\">\n      <style nonce=${nonce}>\n        body {\n          margin: 0;\n          overflow-x: hidden;\n          overflow-y: hidden;\n        }\n        .fallback {\n          opacity: 0;\n          animation: fadeIn 1s 1s;\n          animation-iteration-count: 1;\n          animation-fill-mode: forwards;\n          padding: 1em;\n        }\n        @keyframes fadeIn {\n          0% {opacity:0;}\n          100% {opacity:1; }\n        }\n      </style>\n    ${\n      config.embed\n        ? 'graphRef' in config && config.graphRef\n          ? getEmbeddedExplorerHTML(\n              explorerVersion,\n              config,\n              apolloServerVersion,\n              nonce,\n            )\n          : !('graphRef' in config)\n            ? getEmbeddedSandboxHTML(\n                sandboxVersion,\n                config,\n                apolloServerVersion,\n                nonce,\n              )\n            : getNonEmbeddedLandingPageHTML(\n                apolloServerLandingPageVersion,\n                config,\n                apolloServerVersion,\n                nonce,\n              )\n        : getNonEmbeddedLandingPageHTML(\n            apolloServerLandingPageVersion,\n            config,\n            apolloServerVersion,\n            nonce,\n          )\n    }\n    </div>\n  </body>\n</html>\n          `;\n          }\n          return { html };\n        },\n      };\n    },\n  };\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3588, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3592, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@apollo/server/src/ApolloServer.ts"],"sourcesContent":["import type { GatewayExecutor } from '@apollo/server-gateway-interface';\nimport { isNodeLike } from '@apollo/utils.isnodelike';\nimport {\n  InMemoryLRUCache,\n  PrefixingKeyValueCache,\n  type KeyValueCache,\n} from '@apollo/utils.keyvaluecache';\nimport type { Logger } from '@apollo/utils.logger';\nimport type { WithRequired } from '@apollo/utils.withrequired';\nimport { makeExecutableSchema } from '@graphql-tools/schema';\nimport resolvable, { type Resolvable } from '@josephg/resolvable';\nimport {\n  GraphQLError,\n  assertValidSchema,\n  print,\n  printSchema,\n  type DocumentNode,\n  type FormattedExecutionResult,\n  type GraphQLFieldResolver,\n  type GraphQLFormattedError,\n  type GraphQLSchema,\n  type ParseOptions,\n  type TypedQueryDocumentNode,\n  type ValidationContext,\n  type ValidationRule,\n} from 'graphql';\nimport loglevel from 'loglevel';\nimport Negotiator from 'negotiator';\nimport { newCachePolicy } from './cachePolicy.js';\nimport { determineApolloConfig } from './determineApolloConfig.js';\nimport {\n  ensureError,\n  ensureGraphQLError,\n  normalizeAndFormatErrors,\n} from './errorNormalize.js';\nimport {\n  ApolloServerErrorCode,\n  ApolloServerValidationErrorCode,\n} from './errors/index.js';\nimport type { ApolloServerOptionsWithStaticSchema } from './externalTypes/constructor.js';\nimport type {\n  ExecuteOperationOptions,\n  VariableValues,\n} from './externalTypes/graphql.js';\nimport type {\n  ApolloConfig,\n  ApolloServerOptions,\n  ApolloServerPlugin,\n  BaseContext,\n  ContextThunk,\n  DocumentStore,\n  GraphQLRequest,\n  GraphQLRequestContext,\n  GraphQLResponse,\n  GraphQLServerContext,\n  GraphQLServerListener,\n  HTTPGraphQLHead,\n  HTTPGraphQLRequest,\n  HTTPGraphQLResponse,\n  LandingPage,\n  PersistedQueryOptions,\n} from './externalTypes/index.js';\nimport { runPotentiallyBatchedHttpQuery } from './httpBatching.js';\nimport type { GraphQLExperimentalIncrementalExecutionResults } from './incrementalDeliveryPolyfill.js';\nimport { pluginIsInternal, type InternalPluginId } from './internalPlugin.js';\nimport {\n  preventCsrf,\n  recommendedCsrfPreventionRequestHeaders,\n} from './preventCsrf.js';\nimport { APQ_CACHE_PREFIX, processGraphQLRequest } from './requestPipeline.js';\nimport { newHTTPGraphQLHead, prettyJSONStringify } from './runHttpQuery.js';\nimport { HeaderMap } from './utils/HeaderMap.js';\nimport { UnreachableCaseError } from './utils/UnreachableCaseError.js';\nimport { computeCoreSchemaHash } from './utils/computeCoreSchemaHash.js';\nimport { isDefined } from './utils/isDefined.js';\nimport { SchemaManager } from './utils/schemaManager.js';\n\nconst NoIntrospection: ValidationRule = (context: ValidationContext) => ({\n  Field(node) {\n    if (node.name.value === '__schema' || node.name.value === '__type') {\n      context.reportError(\n        new GraphQLError(\n          'GraphQL introspection is not allowed by Apollo Server, but the query contained __schema or __type. To enable introspection, pass introspection: true to ApolloServer in production',\n          {\n            nodes: [node],\n            extensions: {\n              validationErrorCode:\n                ApolloServerValidationErrorCode.INTROSPECTION_DISABLED,\n            },\n          },\n        ),\n      );\n    }\n  },\n});\n\nexport type SchemaDerivedData = {\n  schema: GraphQLSchema;\n  // A store that, when enabled (default), will store the parsed and validated\n  // versions of operations in-memory, allowing subsequent parses/validates\n  // on the same operation to be executed immediately.\n  documentStore: DocumentStore | null;\n  // Prefix for keys in the DocumentStore if a custom one is provided (to\n  // separate the cache for different schema versions). This is vital to\n  // security so we do it explicitly so that\n  // PrefixingKeyValueCache.cacheDangerouslyDoesNotNeedPrefixesForIsolation\n  // doesn't affect it.\n  documentStoreKeyPrefix: string;\n};\n\ntype RunningServerState = {\n  schemaManager: SchemaManager;\n  landingPage: LandingPage | null;\n};\n\ntype ServerState =\n  | {\n      phase: 'initialized';\n      schemaManager: SchemaManager;\n    }\n  | {\n      phase: 'starting';\n      barrier: Resolvable<void>;\n      schemaManager: SchemaManager;\n      // This is set to true if you called\n      // startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests\n      // instead of start. The main purpose is that assertStarted allows you to\n      // still be in the starting phase if this is set. (This is the serverless\n      // use case.)\n      startedInBackground: boolean;\n    }\n  | {\n      phase: 'failed to start';\n      error: Error;\n    }\n  | ({\n      phase: 'started';\n      drainServers: (() => Promise<void>) | null;\n      toDispose: (() => Promise<void>)[];\n      toDisposeLast: (() => Promise<void>)[];\n    } & RunningServerState)\n  | ({\n      phase: 'draining';\n      barrier: Resolvable<void>;\n    } & RunningServerState)\n  | {\n      phase: 'stopping';\n      barrier: Resolvable<void>;\n    }\n  | {\n      phase: 'stopped';\n      stopError: Error | null;\n    };\n\nexport interface ApolloServerInternals<TContext extends BaseContext> {\n  state: ServerState;\n  gatewayExecutor: GatewayExecutor | null;\n  dangerouslyDisableValidation?: boolean;\n  formatError?: (\n    formattedError: GraphQLFormattedError,\n    error: unknown,\n  ) => GraphQLFormattedError;\n  includeStacktraceInErrorResponses: boolean;\n  persistedQueries?: WithRequired<PersistedQueryOptions, 'cache'>;\n  nodeEnv: string;\n  allowBatchedHttpRequests: boolean;\n  apolloConfig: ApolloConfig;\n  plugins: ApolloServerPlugin<TContext>[];\n  parseOptions: ParseOptions;\n  // `undefined` means we figure out what to do during _start (because\n  // the default depends on whether or not we used the background version\n  // of start).\n  stopOnTerminationSignals: boolean | undefined;\n  csrfPreventionRequestHeaders: string[] | null;\n\n  rootValue?: ((parsedQuery: DocumentNode) => unknown) | unknown;\n  validationRules: Array<ValidationRule>;\n  fieldResolver?: GraphQLFieldResolver<any, TContext>;\n  // TODO(AS5): remove OR warn + ignore with this option set, ignore option and\n  // flip default behavior.\n  status400ForVariableCoercionErrors?: boolean;\n  __testing_incrementalExecutionResults?: GraphQLExperimentalIncrementalExecutionResults;\n  stringifyResult: (\n    value: FormattedExecutionResult,\n  ) => string | Promise<string>;\n}\n\nfunction defaultLogger(): Logger {\n  const loglevelLogger = loglevel.getLogger('apollo-server');\n  loglevelLogger.setLevel(loglevel.levels.INFO);\n  return loglevelLogger;\n}\n\n// We really want to prevent this from being legal:\n//\n//     const s: ApolloServer<{}> =\n//       new ApolloServer<{importantContextField: boolean}>({ ... });\n//     s.executeOperation({query}, {contextValue: {}});\n//\n// ie, if you declare an ApolloServer whose context values must be of a certain\n// type, you can't assign it to a variable whose context values are less\n// constrained and then pass in a context value missing important fields.\n//\n// We also want this to be illegal:\n//\n//     const sBase = new ApolloServer<{}>({ ... });\n//     const s: ApolloServer<{importantContextField: boolean}> = sBase;\n//     s.addPlugin({async requestDidStart({contextValue: {importantContextField}}) { ... }})\n//     sBase.executeOperation({query}, {contextValue: {}});\n//\n// so you shouldn't be able to assign an ApolloServer to a variable whose\n// context values are more constrained, either. So we want to declare that\n// ApolloServer is *invariant* in TContext, which we do with `in out` (a\n// TypeScript 4.7 feature).\nexport class ApolloServer<in out TContext extends BaseContext = BaseContext> {\n  private internals: ApolloServerInternals<TContext>;\n\n  public readonly cache: KeyValueCache<string>;\n  public readonly logger: Logger;\n\n  constructor(config: ApolloServerOptions<TContext>) {\n    const nodeEnv = config.nodeEnv ?? process.env.NODE_ENV ?? '';\n\n    this.logger = config.logger ?? defaultLogger();\n\n    const apolloConfig = determineApolloConfig(config.apollo, this.logger);\n\n    const isDev = nodeEnv !== 'production';\n\n    if (\n      config.cache &&\n      config.cache !== 'bounded' &&\n      PrefixingKeyValueCache.prefixesAreUnnecessaryForIsolation(config.cache)\n    ) {\n      throw new Error(\n        'You cannot pass a cache returned from ' +\n          '`PrefixingKeyValueCache.cacheDangerouslyDoesNotNeedPrefixesForIsolation`' +\n          'to `new ApolloServer({ cache })`, because Apollo Server may use it for ' +\n          'multiple features whose cache keys must be distinct from each other.',\n      );\n    }\n\n    const state: ServerState = config.gateway\n      ? // ApolloServer has been initialized but we have not yet tried to load the\n        // schema from the gateway. That will wait until `start()` or\n        // `startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests()`\n        // is called. (These may be called by other helpers; for example,\n        // `standaloneServer` calls `start` for you inside its `listen` method,\n        // and a serverless framework integration would call\n        // startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests\n        // for you.)\n        {\n          phase: 'initialized',\n          schemaManager: new SchemaManager({\n            gateway: config.gateway,\n            apolloConfig,\n            schemaDerivedDataProvider: (schema) =>\n              ApolloServer.generateSchemaDerivedData(\n                schema,\n                config.documentStore,\n              ),\n            logger: this.logger,\n          }),\n        }\n      : // We construct the schema synchronously so that we can fail fast if the\n        // schema can't be constructed. (This used to be more important because we\n        // used to have a 'schema' field that was publicly accessible immediately\n        // after construction, though that field never actually worked with\n        // gateways.)\n        {\n          phase: 'initialized',\n          schemaManager: new SchemaManager({\n            apiSchema: ApolloServer.constructSchema(config),\n            schemaDerivedDataProvider: (schema) =>\n              ApolloServer.generateSchemaDerivedData(\n                schema,\n                config.documentStore,\n              ),\n            logger: this.logger,\n          }),\n        };\n\n    const introspectionEnabled = config.introspection ?? isDev;\n\n    // We continue to allow 'bounded' for backwards-compatibility with the AS3.9\n    // API.\n    this.cache =\n      config.cache === undefined || config.cache === 'bounded'\n        ? new InMemoryLRUCache()\n        : config.cache;\n\n    // Note that we avoid calling methods on `this` before `this.internals` is assigned\n    // (thus a bunch of things being static methods above).\n    this.internals = {\n      formatError: config.formatError,\n      rootValue: config.rootValue,\n      validationRules: [\n        ...(config.validationRules ?? []),\n        ...(introspectionEnabled ? [] : [NoIntrospection]),\n      ],\n      dangerouslyDisableValidation:\n        config.dangerouslyDisableValidation ?? false,\n      fieldResolver: config.fieldResolver,\n      includeStacktraceInErrorResponses:\n        config.includeStacktraceInErrorResponses ??\n        (nodeEnv !== 'production' && nodeEnv !== 'test'),\n      persistedQueries:\n        config.persistedQueries === false\n          ? undefined\n          : {\n              ...config.persistedQueries,\n              cache: new PrefixingKeyValueCache(\n                config.persistedQueries?.cache ?? this.cache,\n                APQ_CACHE_PREFIX,\n              ),\n            },\n      nodeEnv,\n      allowBatchedHttpRequests: config.allowBatchedHttpRequests ?? false,\n      apolloConfig,\n      // Note that more plugins can be added before `start()` with `addPlugin()`\n      // (eg, plugins that want to take this ApolloServer as an argument), and\n      // `start()` will call `addDefaultPlugins` to add default plugins.\n      plugins: config.plugins ?? [],\n      parseOptions: config.parseOptions ?? {},\n      state,\n      stopOnTerminationSignals: config.stopOnTerminationSignals,\n\n      gatewayExecutor: null, // set by _start\n\n      csrfPreventionRequestHeaders:\n        config.csrfPrevention === true || config.csrfPrevention === undefined\n          ? recommendedCsrfPreventionRequestHeaders\n          : config.csrfPrevention === false\n            ? null\n            : config.csrfPrevention.requestHeaders ??\n              recommendedCsrfPreventionRequestHeaders,\n      status400ForVariableCoercionErrors:\n        config.status400ForVariableCoercionErrors ?? false,\n      __testing_incrementalExecutionResults:\n        config.__testing_incrementalExecutionResults,\n      stringifyResult: config.stringifyResult ?? prettyJSONStringify,\n    };\n  }\n\n  // Awaiting a call to `start` ensures that a schema has been loaded and that\n  // all plugin `serverWillStart` hooks have been called. If either of these\n  // processes throw, `start` will (async) throw as well.\n  //\n  // If you're using `standaloneServer`, you don't need to call `start` yourself\n  // (in fact, it will throw if you do so); its `listen` method takes care of\n  // that for you.\n  //\n  // If instead you're using an integration package for a non-serverless\n  // framework (like Express), you must await a call to `start` immediately\n  // after creating your `ApolloServer`, before attaching it to your web\n  // framework and starting to accept requests. `start` should only be called\n  // once; if it throws and you'd like to retry, just create another\n  // `ApolloServer`. (Calling `start` was optional in Apollo Server 2, but in\n  // Apollo Server 3+ the functions like `expressMiddleware` use `assertStarted`\n  // to throw if `start` hasn't successfully completed.)\n  //\n  // Serverless integrations like Lambda do not support calling `start()`,\n  // because their lifecycle doesn't allow you to wait before assigning a\n  // handler or allowing the handler to be called. So they call\n  // `startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests()`\n  // instead, and don't really differentiate between startup failures and\n  // request failures. This is hopefully appropriate for a \"serverless\"\n  // framework. Serverless startup failures result in returning a redacted error\n  // to the end user and logging the more detailed error.\n  public async start(): Promise<void> {\n    return await this._start(false);\n  }\n\n  public startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests(): void {\n    this._start(true).catch((e) => this.logStartupError(e));\n  }\n\n  private async _start(startedInBackground: boolean): Promise<void> {\n    if (this.internals.state.phase !== 'initialized') {\n      // If we wanted we could make this error detectable and change\n      // `standaloneServer` to change the message to say not to call start() at\n      // all.\n      throw new Error(\n        `You should only call 'start()' or ` +\n          `'startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests()' ` +\n          `once on your ApolloServer.`,\n      );\n    }\n    const schemaManager = this.internals.state.schemaManager;\n    const barrier = resolvable();\n    this.internals.state = {\n      phase: 'starting',\n      barrier,\n      schemaManager,\n      startedInBackground,\n    };\n    try {\n      // Now that you can't call addPlugin any more, add default plugins like\n      // usage reporting if they're not already added.\n      await this.addDefaultPlugins();\n\n      const toDispose: (() => Promise<void>)[] = [];\n      const executor = await schemaManager.start();\n      if (executor) {\n        this.internals.gatewayExecutor = executor;\n      }\n      toDispose.push(async () => {\n        await schemaManager.stop();\n      });\n\n      const schemaDerivedData = schemaManager.getSchemaDerivedData();\n      const service: GraphQLServerContext = {\n        logger: this.logger,\n        cache: this.cache,\n        schema: schemaDerivedData.schema,\n        apollo: this.internals.apolloConfig,\n        startedInBackground,\n      };\n\n      const taggedServerListeners = (\n        await Promise.all(\n          this.internals.plugins.map(async (plugin) => ({\n            serverListener:\n              plugin.serverWillStart && (await plugin.serverWillStart(service)),\n            installedImplicitly:\n              isImplicitlyInstallablePlugin(plugin) &&\n              plugin.__internal_installed_implicitly__,\n          })),\n        )\n      ).filter(\n        (\n          maybeTaggedServerListener,\n        ): maybeTaggedServerListener is {\n          serverListener: GraphQLServerListener;\n          installedImplicitly: boolean;\n        } => typeof maybeTaggedServerListener.serverListener === 'object',\n      );\n\n      taggedServerListeners.forEach(\n        ({ serverListener: { schemaDidLoadOrUpdate } }) => {\n          if (schemaDidLoadOrUpdate) {\n            schemaManager.onSchemaLoadOrUpdate(schemaDidLoadOrUpdate);\n          }\n        },\n      );\n\n      const serverWillStops = taggedServerListeners\n        .map((l) => l.serverListener.serverWillStop)\n        .filter(isDefined);\n      if (serverWillStops.length) {\n        toDispose.push(async () => {\n          await Promise.all(\n            serverWillStops.map((serverWillStop) => serverWillStop()),\n          );\n        });\n      }\n\n      const drainServerCallbacks = taggedServerListeners\n        .map((l) => l.serverListener.drainServer)\n        .filter(isDefined);\n      const drainServers = drainServerCallbacks.length\n        ? async () => {\n            await Promise.all(\n              drainServerCallbacks.map((drainServer) => drainServer()),\n            );\n          }\n        : null;\n\n      // Find the renderLandingPage callback, if one is provided. If the user\n      // installed ApolloServerPluginLandingPageDisabled then there may be none\n      // found. On the other hand, if the user installed a landingPage plugin,\n      // then both the implicit installation of\n      // ApolloServerPluginLandingPage*Default and the other plugin will be\n      // found; we skip the implicit plugin.\n      let taggedServerListenersWithRenderLandingPage =\n        taggedServerListeners.filter((l) => l.serverListener.renderLandingPage);\n      if (taggedServerListenersWithRenderLandingPage.length > 1) {\n        taggedServerListenersWithRenderLandingPage =\n          taggedServerListenersWithRenderLandingPage.filter(\n            (l) => !l.installedImplicitly,\n          );\n      }\n      let landingPage: LandingPage | null = null;\n      if (taggedServerListenersWithRenderLandingPage.length > 1) {\n        throw Error('Only one plugin can implement renderLandingPage.');\n      } else if (taggedServerListenersWithRenderLandingPage.length) {\n        landingPage =\n          await taggedServerListenersWithRenderLandingPage[0].serverListener\n            .renderLandingPage!();\n      }\n\n      const toDisposeLast = this.maybeRegisterTerminationSignalHandlers(\n        ['SIGINT', 'SIGTERM'],\n        startedInBackground,\n      );\n\n      this.internals.state = {\n        phase: 'started',\n        schemaManager,\n        drainServers,\n        landingPage,\n        toDispose,\n        toDisposeLast,\n      };\n    } catch (maybeError: unknown) {\n      const error = ensureError(maybeError);\n\n      try {\n        await Promise.all(\n          this.internals.plugins.map(\n            async (plugin) => plugin.startupDidFail?.({ error }),\n          ),\n        );\n      } catch (pluginError) {\n        this.logger.error(`startupDidFail hook threw: ${pluginError}`);\n      }\n\n      this.internals.state = {\n        phase: 'failed to start',\n        error,\n      };\n      throw error;\n    } finally {\n      barrier.resolve();\n    }\n  }\n\n  private maybeRegisterTerminationSignalHandlers(\n    signals: NodeJS.Signals[],\n    startedInBackground: boolean,\n  ): (() => Promise<void>)[] {\n    const toDisposeLast: (() => Promise<void>)[] = [];\n\n    // We handle signals if it was explicitly requested\n    // (stopOnTerminationSignals === true), or if we're in Node, not in a test,\n    // not in a serverless framework (which we guess based on whether they\n    // called\n    // startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests),\n    // and it wasn't explicitly turned off. (We only actually register the\n    // signal handlers once we've successfully started up, because there's\n    // nothing to stop otherwise.)\n    if (\n      this.internals.stopOnTerminationSignals === false ||\n      (this.internals.stopOnTerminationSignals === undefined &&\n        !(\n          isNodeLike &&\n          this.internals.nodeEnv !== 'test' &&\n          !startedInBackground\n        ))\n    ) {\n      return toDisposeLast;\n    }\n\n    let receivedSignal = false;\n    const signalHandler: NodeJS.SignalsListener = async (signal) => {\n      if (receivedSignal) {\n        // If we receive another SIGINT or SIGTERM while we're waiting\n        // for the server to stop, just ignore it.\n        return;\n      }\n      receivedSignal = true;\n      try {\n        await this.stop();\n      } catch (e) {\n        this.logger.error(`stop() threw during ${signal} shutdown`);\n        this.logger.error(e);\n        // Can't rely on the signal handlers being removed.\n        process.exit(1);\n      }\n      // Note: this.stop will call the toDisposeLast handlers below, so at\n      // this point this handler will have been removed and we can re-kill\n      // ourself to die with the appropriate signal exit status. this.stop\n      // takes care to call toDisposeLast last, so the signal handler isn't\n      // removed until after the rest of shutdown happens.\n      process.kill(process.pid, signal);\n    };\n\n    signals.forEach((signal) => {\n      process.on(signal, signalHandler);\n      toDisposeLast.push(async () => {\n        process.removeListener(signal, signalHandler);\n      });\n    });\n    return toDisposeLast;\n  }\n\n  // This method is called at the beginning of each GraphQL request by\n  // `executeHTTPGraphQLRequest` and `executeOperation`. Most of its logic is\n  // only helpful if you started the server in the background (ie, for\n  // serverless frameworks): unless you're in a serverless framework, you should\n  // have called `await server.start()` before the server got to the point of\n  // running GraphQL requests (`assertStarted` calls in the framework\n  // integrations verify that) and so the only cases for non-serverless\n  // frameworks that this should hit are 'started', 'stopping', and 'stopped'.\n  // But if you started the server in the background (with\n  // startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests), this\n  // lets the server wait until fully started before serving operations.\n  private async _ensureStarted(): Promise<RunningServerState> {\n    while (true) {\n      switch (this.internals.state.phase) {\n        case 'initialized':\n          // This error probably won't happen: serverless framework integrations\n          // should call\n          // `startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests`\n          // for you, and other frameworks call `assertStarted` before setting\n          // things up enough to make calling this function possible.\n          throw new Error(\n            'You need to call `server.start()` before using your Apollo Server.',\n          );\n        case 'starting':\n          await this.internals.state.barrier;\n          // continue the while loop\n          break;\n        case 'failed to start':\n          // First we log the error that prevented startup (which means it will\n          // get logged once for every GraphQL operation).\n          this.logStartupError(this.internals.state.error);\n          // Now make the operation itself fail.\n          // We intentionally do not re-throw actual startup error as it may contain\n          // implementation details and this error will propagate to the client.\n          throw new Error(\n            'This data graph is missing a valid configuration. More details may be available in the server logs.',\n          );\n        case 'started':\n        case 'draining': // We continue to run operations while draining.\n          return this.internals.state;\n        case 'stopping':\n        case 'stopped':\n          this.logger.warn(\n            'A GraphQL operation was received during server shutdown. The ' +\n              'operation will fail. Consider draining the HTTP server on shutdown; ' +\n              'see https://go.apollo.dev/s/drain for details.',\n          );\n          throw new Error(\n            `Cannot execute GraphQL operations ${\n              this.internals.state.phase === 'stopping'\n                ? 'while the server is stopping'\n                : 'after the server has stopped'\n            }.'`,\n          );\n        default:\n          throw new UnreachableCaseError(this.internals.state);\n      }\n    }\n  }\n\n  // Framework integrations should call this to ensure that you've properly\n  // started your server before you get anywhere close to actually listening for\n  // incoming requests.\n  //\n  // There's a special case that if you called\n  // `startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests` and\n  // it hasn't finished starting up yet, this works too. This is intended for\n  // cases like a serverless integration (say, Google Cloud Functions) that\n  // calls\n  // `startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests` for\n  // you and then immediately sets up an integration based on another middleware\n  // like `expressMiddleware` which calls this function. We'd like this to be\n  // OK, but we still want normal Express users to start their ApolloServer\n  // before setting up their HTTP server unless they know what they are doing\n  // well enough to call the function with the long name themselves.\n  public assertStarted(expressionForError: string) {\n    if (\n      this.internals.state.phase !== 'started' &&\n      this.internals.state.phase !== 'draining' &&\n      !(\n        this.internals.state.phase === 'starting' &&\n        this.internals.state.startedInBackground\n      )\n    ) {\n      throw new Error(\n        'You must `await server.start()` before calling `' +\n          expressionForError +\n          '`',\n      );\n    }\n  }\n\n  // Given an error that occurred during Apollo Server startup, log it with a\n  // helpful message. This should happen when you call\n  // `startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests` (ie,\n  // in serverless frameworks); with other frameworks, you must `await\n  // server.start()` which will throw the startup error directly instead of\n  // logging. This gets called both immediately when the startup error happens,\n  // and on all subsequent requests.\n  private logStartupError(err: Error) {\n    this.logger.error(\n      'An error occurred during Apollo Server startup. All GraphQL requests ' +\n        'will now fail. The startup error was: ' +\n        (err?.message || err),\n    );\n  }\n\n  private static constructSchema<TContext extends BaseContext>(\n    config: ApolloServerOptionsWithStaticSchema<TContext>,\n  ): GraphQLSchema {\n    if (config.schema) {\n      return config.schema;\n    }\n\n    const { typeDefs, resolvers } = config;\n    const augmentedTypeDefs = Array.isArray(typeDefs) ? typeDefs : [typeDefs];\n\n    // For convenience, we allow you to pass a few options that we pass through\n    // to a particular version of `@graphql-tools/schema`'s\n    // `makeExecutableSchema`. If you want to use more of this function's\n    // features or have more control over the version of the packages used, just\n    // call it yourself like `new ApolloServer({schema:\n    // makeExecutableSchema(...)})`.\n    return makeExecutableSchema({\n      typeDefs: augmentedTypeDefs,\n      resolvers,\n    });\n  }\n\n  private static generateSchemaDerivedData(\n    schema: GraphQLSchema,\n    // null means don't use a documentStore at all.\n    // missing/undefined means use the default (creating a new one each\n    // time).\n    // defined means wrap this one in a random prefix for each new schema.\n    providedDocumentStore: DocumentStore | null | undefined,\n  ): SchemaDerivedData {\n    // Instead of waiting for the first operation execution against the schema\n    // to find out if it's a valid schema or not, check right now. In the\n    // non-gateway case, if this throws then the `new ApolloServer` call will\n    // throw. In the gateway case if this throws then it will log a message and\n    // just not update the schema (although oddly the message will claim that\n    // the schema is updating).\n    assertValidSchema(schema);\n\n    return {\n      schema,\n      // The DocumentStore is schema-derived because we put documents in it\n      // after checking that they pass GraphQL validation against the schema and\n      // use this to skip validation as well as parsing. So we can't reuse the\n      // same DocumentStore for different schemas because that might make us\n      // treat invalid operations as valid. If we're using the default\n      // DocumentStore, then we just create it from scratch each time we get a\n      // new schema. If we're using a user-provided DocumentStore, then we use\n      // the schema hash as a prefix.\n      documentStore:\n        providedDocumentStore === undefined\n          ? new InMemoryLRUCache<DocumentNode>()\n          : providedDocumentStore,\n      documentStoreKeyPrefix: providedDocumentStore\n        ? `${computeCoreSchemaHash(printSchema(schema))}:`\n        : '',\n    };\n  }\n\n  public async stop() {\n    switch (this.internals.state.phase) {\n      case 'initialized':\n      case 'starting':\n      case 'failed to start':\n        throw Error(\n          'apolloServer.stop() should only be called after `await apolloServer.start()` has succeeded',\n        );\n\n      // Calling stop more than once should have the same result as the first time.\n      case 'stopped':\n        if (this.internals.state.stopError) {\n          throw this.internals.state.stopError;\n        }\n        return;\n\n      // Two parallel calls to stop; just wait for the other one to finish and\n      // do whatever it did.\n      case 'stopping':\n      case 'draining': {\n        await this.internals.state.barrier;\n        // The cast here is because TS doesn't understand that this.state can\n        // change during the await\n        // (https://github.com/microsoft/TypeScript/issues/9998).\n        const state = this.internals.state as ServerState;\n        if (state.phase !== 'stopped') {\n          throw Error(`Surprising post-stopping state ${state.phase}`);\n        }\n        if (state.stopError) {\n          throw state.stopError;\n        }\n        return;\n      }\n\n      case 'started':\n        // This is handled by the rest of the function.\n        break;\n\n      default:\n        throw new UnreachableCaseError(this.internals.state);\n    }\n\n    const barrier = resolvable();\n\n    const {\n      schemaManager,\n      drainServers,\n      landingPage,\n      toDispose,\n      toDisposeLast,\n    } = this.internals.state;\n\n    // Commit to stopping and start draining servers.\n    this.internals.state = {\n      phase: 'draining',\n      barrier,\n      schemaManager,\n      landingPage,\n    };\n\n    try {\n      await drainServers?.();\n\n      // Servers are drained. Prevent further operations from starting and call\n      // stop handlers.\n      this.internals.state = { phase: 'stopping', barrier };\n\n      // We run shutdown handlers in two phases because we don't want to turn\n      // off our signal listeners (ie, allow signals to kill the process) until\n      // we've done the important parts of shutdown like running serverWillStop\n      // handlers. (We can make this more generic later if it's helpful.)\n      await Promise.all([...toDispose].map((dispose) => dispose()));\n      await Promise.all([...toDisposeLast].map((dispose) => dispose()));\n    } catch (stopError) {\n      this.internals.state = {\n        phase: 'stopped',\n        stopError: stopError as Error,\n      };\n      barrier.resolve();\n      throw stopError;\n    }\n    this.internals.state = { phase: 'stopped', stopError: null };\n  }\n\n  private async addDefaultPlugins() {\n    const { plugins, apolloConfig, nodeEnv } = this.internals;\n    const isDev = nodeEnv !== 'production';\n\n    const alreadyHavePluginWithInternalId = (id: InternalPluginId) =>\n      plugins.some(\n        (p) => pluginIsInternal(p) && p.__internal_plugin_id__ === id,\n      );\n\n    // Make sure we're not trying to explicitly enable and disable the same\n    // feature. (Be careful: we are not trying to stop people from installing\n    // the same plugin twice if they have a use case for it, like two usage\n    // reporting plugins for different variants.)\n    //\n    // Note that this check doesn't work for the landing page plugin, because\n    // users can write their own landing page plugins and we don't know if a\n    // given plugin is a landing page plugin until the server has started.\n    const pluginsByInternalID = new Map<\n      InternalPluginId,\n      { sawDisabled: boolean; sawNonDisabled: boolean }\n    >();\n    for (const p of plugins) {\n      if (pluginIsInternal(p)) {\n        const id = p.__internal_plugin_id__;\n        if (!pluginsByInternalID.has(id)) {\n          pluginsByInternalID.set(id, {\n            sawDisabled: false,\n            sawNonDisabled: false,\n          });\n        }\n        const seen = pluginsByInternalID.get(id)!;\n        if (p.__is_disabled_plugin__) {\n          seen.sawDisabled = true;\n        } else {\n          seen.sawNonDisabled = true;\n        }\n\n        if (seen.sawDisabled && seen.sawNonDisabled) {\n          throw new Error(\n            `You have tried to install both ApolloServerPlugin${id} and ` +\n              `ApolloServerPlugin${id}Disabled in your server. Please choose ` +\n              `whether or not you want to disable the feature and install the ` +\n              `appropriate plugin for your use case.`,\n          );\n        }\n      }\n    }\n\n    // Special case: cache control is on unless you explicitly disable it.\n    {\n      if (!alreadyHavePluginWithInternalId('CacheControl')) {\n        const { ApolloServerPluginCacheControl } = await import(\n          './plugin/cacheControl/index.js'\n        );\n        plugins.push(ApolloServerPluginCacheControl());\n      }\n    }\n\n    // Special case: usage reporting is on by default (and first!) if you\n    // configure an API key.\n    {\n      const alreadyHavePlugin =\n        alreadyHavePluginWithInternalId('UsageReporting');\n      if (!alreadyHavePlugin && apolloConfig.key) {\n        if (apolloConfig.graphRef) {\n          // Keep this plugin first so it wraps everything. (Unfortunately despite\n          // the fact that the person who wrote this line also was the original\n          // author of the comment above in #1105, they don't quite understand why this was important.)\n          const { ApolloServerPluginUsageReporting } = await import(\n            './plugin/usageReporting/index.js'\n          );\n          plugins.unshift(\n            ApolloServerPluginUsageReporting({\n              __onlyIfSchemaIsNotSubgraph: true,\n            }),\n          );\n        } else {\n          this.logger.warn(\n            'You have specified an Apollo key but have not specified a graph ref; usage ' +\n              'reporting is disabled. To enable usage reporting, set the `APOLLO_GRAPH_REF` ' +\n              'environment variable to `your-graph-id@your-graph-variant`. To disable this ' +\n              'warning, install `ApolloServerPluginUsageReportingDisabled`.',\n          );\n        }\n      }\n    }\n\n    // Special case: schema reporting can be turned on via environment variable.\n    {\n      const alreadyHavePlugin =\n        alreadyHavePluginWithInternalId('SchemaReporting');\n      const enabledViaEnvVar = process.env.APOLLO_SCHEMA_REPORTING === 'true';\n      if (!alreadyHavePlugin && enabledViaEnvVar) {\n        if (apolloConfig.key) {\n          const { ApolloServerPluginSchemaReporting } = await import(\n            './plugin/schemaReporting/index.js'\n          );\n          plugins.push(ApolloServerPluginSchemaReporting());\n        } else {\n          throw new Error(\n            \"You've enabled schema reporting by setting the APOLLO_SCHEMA_REPORTING \" +\n              'environment variable to true, but you also need to provide your ' +\n              'Apollo API key, via the APOLLO_KEY environment ' +\n              'variable or via `new ApolloServer({apollo: {key})',\n          );\n        }\n      }\n    }\n\n    // Special case: inline tracing is on by default for federated schemas.\n    {\n      const alreadyHavePlugin = alreadyHavePluginWithInternalId('InlineTrace');\n      if (!alreadyHavePlugin) {\n        // If we haven't explicitly disabled inline tracing via\n        // ApolloServerPluginInlineTraceDisabled or explicitly installed our own\n        // ApolloServerPluginInlineTrace, we set up inline tracing in \"only if\n        // federated\" mode.  (This is slightly different than the\n        // pre-ApolloServerPluginInlineTrace where we would also avoid doing\n        // this if an API key was configured and log a warning.)\n        const { ApolloServerPluginInlineTrace } = await import(\n          './plugin/inlineTrace/index.js'\n        );\n        plugins.push(\n          ApolloServerPluginInlineTrace({ __onlyIfSchemaIsSubgraph: true }),\n        );\n      }\n    }\n\n    // Special case: If we're not in production, show our default landing page.\n    //\n    // This works a bit differently from the other implicitly installed plugins,\n    // which rely entirely on the __internal_plugin_id__ to decide whether the\n    // plugin takes effect. That's because we want third-party plugins to be\n    // able to provide a landing page that overrides the default landing page,\n    // without them having to know about __internal_plugin_id__. So unless we\n    // actively disable the default landing page with\n    // ApolloServerPluginLandingPageDisabled, we install the default landing\n    // page, but with a special flag that _start() uses to ignore it if some\n    // other plugin defines a renderLandingPage callback. (We can't just look\n    // now to see if the plugin defines renderLandingPage because we haven't run\n    // serverWillStart yet.)\n    const alreadyHavePlugin = alreadyHavePluginWithInternalId(\n      'LandingPageDisabled',\n    );\n    if (!alreadyHavePlugin) {\n      const {\n        ApolloServerPluginLandingPageLocalDefault,\n        ApolloServerPluginLandingPageProductionDefault,\n      } = await import('./plugin/landingPage/default/index.js');\n      const plugin: ApolloServerPlugin<TContext> = isDev\n        ? ApolloServerPluginLandingPageLocalDefault()\n        : ApolloServerPluginLandingPageProductionDefault();\n      if (!isImplicitlyInstallablePlugin(plugin)) {\n        throw Error(\n          'default landing page plugin should be implicitly installable?',\n        );\n      }\n      plugin.__internal_installed_implicitly__ = true;\n      plugins.push(plugin);\n    }\n  }\n\n  public addPlugin(plugin: ApolloServerPlugin<TContext>) {\n    if (this.internals.state.phase !== 'initialized') {\n      throw new Error(\"Can't add plugins after the server has started\");\n    }\n    this.internals.plugins.push(plugin);\n  }\n\n  public async executeHTTPGraphQLRequest({\n    httpGraphQLRequest,\n    context,\n  }: {\n    httpGraphQLRequest: HTTPGraphQLRequest;\n    context: ContextThunk<TContext>;\n  }): Promise<HTTPGraphQLResponse> {\n    try {\n      let runningServerState;\n      try {\n        runningServerState = await this._ensureStarted();\n      } catch (error: unknown) {\n        // This is typically either the masked error from when background startup\n        // failed, or related to invoking this function before startup or\n        // during/after shutdown (due to lack of draining).\n        return await this.errorResponse(error, httpGraphQLRequest);\n      }\n\n      if (\n        runningServerState.landingPage &&\n        this.prefersHTML(httpGraphQLRequest)\n      ) {\n        let renderedHtml;\n        if (typeof runningServerState.landingPage.html === 'string') {\n          renderedHtml = runningServerState.landingPage.html;\n        } else {\n          try {\n            renderedHtml = await runningServerState.landingPage.html();\n          } catch (maybeError: unknown) {\n            const error = ensureError(maybeError);\n            this.logger.error(`Landing page \\`html\\` function threw: ${error}`);\n            return await this.errorResponse(error, httpGraphQLRequest);\n          }\n        }\n\n        return {\n          headers: new HeaderMap([['content-type', 'text/html']]),\n          body: {\n            kind: 'complete',\n            string: renderedHtml,\n          },\n        };\n      }\n\n      // If enabled, check to ensure that this request was preflighted before doing\n      // anything real (such as running the context function).\n      if (this.internals.csrfPreventionRequestHeaders) {\n        preventCsrf(\n          httpGraphQLRequest.headers,\n          this.internals.csrfPreventionRequestHeaders,\n        );\n      }\n\n      let contextValue: TContext;\n      try {\n        contextValue = await context();\n      } catch (maybeError: unknown) {\n        const error = ensureError(maybeError);\n        try {\n          await Promise.all(\n            this.internals.plugins.map(\n              async (plugin) =>\n                plugin.contextCreationDidFail?.({\n                  error,\n                }),\n            ),\n          );\n        } catch (pluginError) {\n          this.logger.error(\n            `contextCreationDidFail hook threw: ${pluginError}`,\n          );\n        }\n\n        // If some random function threw, add a helpful prefix when converting\n        // to GraphQLError. If it was already a GraphQLError, trust that the\n        // message was chosen thoughtfully and leave off the prefix.\n        return await this.errorResponse(\n          ensureGraphQLError(error, 'Context creation failed: '),\n          httpGraphQLRequest,\n        );\n      }\n\n      return await runPotentiallyBatchedHttpQuery(\n        this,\n        httpGraphQLRequest,\n        contextValue,\n        runningServerState.schemaManager.getSchemaDerivedData(),\n        this.internals,\n      );\n    } catch (maybeError_: unknown) {\n      const maybeError = maybeError_; // fixes inference because catch vars are not const\n      if (\n        maybeError instanceof GraphQLError &&\n        maybeError.extensions.code === ApolloServerErrorCode.BAD_REQUEST\n      ) {\n        try {\n          await Promise.all(\n            this.internals.plugins.map(\n              async (plugin) =>\n                plugin.invalidRequestWasReceived?.({ error: maybeError }),\n            ),\n          );\n        } catch (pluginError) {\n          this.logger.error(\n            `invalidRequestWasReceived hook threw: ${pluginError}`,\n          );\n        }\n      }\n      return await this.errorResponse(maybeError, httpGraphQLRequest);\n    }\n  }\n\n  private async errorResponse(\n    error: unknown,\n    requestHead: HTTPGraphQLHead,\n  ): Promise<HTTPGraphQLResponse> {\n    const { formattedErrors, httpFromErrors } = normalizeAndFormatErrors(\n      [error],\n      {\n        includeStacktraceInErrorResponses:\n          this.internals.includeStacktraceInErrorResponses,\n        formatError: this.internals.formatError,\n      },\n    );\n\n    return {\n      status: httpFromErrors.status ?? 500,\n      headers: new HeaderMap([\n        ...httpFromErrors.headers,\n        [\n          'content-type',\n          // Note that we may change the default to\n          // 'application/graphql-response+json' by 2025 as encouraged by the\n          // graphql-over-http spec. It's maybe a bit bad for us to provide\n          // an application/json response if they send `accept: foo/bar`,\n          // but we're already providing some sort of bad request error, and\n          // it's probably more useful for them to fix the other error before\n          // they deal with the `accept` header.\n          chooseContentTypeForSingleResultResponse(requestHead) ??\n            MEDIA_TYPES.APPLICATION_JSON,\n        ],\n      ]),\n      body: {\n        kind: 'complete',\n        string: await this.internals.stringifyResult({\n          errors: formattedErrors,\n        }),\n      },\n    };\n  }\n\n  private prefersHTML(request: HTTPGraphQLRequest): boolean {\n    const acceptHeader = request.headers.get('accept');\n    return (\n      request.method === 'GET' &&\n      !!acceptHeader &&\n      new Negotiator({\n        headers: { accept: acceptHeader },\n      }).mediaType([\n        // We need it to actively prefer text/html over less browser-y types;\n        // eg, `accept: */*' should still go for JSON. Negotiator does tiebreak\n        // by the order in the list we provide, so we put text/html last.\n        MEDIA_TYPES.APPLICATION_JSON,\n        MEDIA_TYPES.APPLICATION_GRAPHQL_RESPONSE_JSON,\n        MEDIA_TYPES.MULTIPART_MIXED_EXPERIMENTAL,\n        MEDIA_TYPES.MULTIPART_MIXED_NO_DEFER_SPEC,\n        MEDIA_TYPES.TEXT_HTML,\n      ]) === MEDIA_TYPES.TEXT_HTML\n    );\n  }\n\n  /**\n   * This method is primarily meant for testing: it allows you to execute a\n   * GraphQL operation via the request pipeline without going through the HTTP\n   * layer. Note that this means that any handling you do in your server at the\n   * HTTP level will not affect this call!\n   *\n   * For convenience, you can provide `request.query` either as a string or a\n   * DocumentNode, in case you choose to use the gql tag in your tests. This is\n   * just a convenience, not an optimization (we convert provided ASTs back into\n   * string).\n   *\n   * The second object is an optional options object which includes the optional\n   * `contextValue` object available in resolvers.\n   *\n   * You may specify the TData and TVariables generic types when calling this\n   * method; Apollo Server does not validate that the returned data actually\n   * matches the structure of TData. (Typically these types are created by a\n   * code generation tool.) Note that this does not enforce that `variables` is\n   * provided at all, just that it has the right type if provided.\n   */\n  public async executeOperation<\n    TData = Record<string, unknown>,\n    TVariables extends VariableValues = VariableValues,\n  >(\n    this: ApolloServer<BaseContext>,\n    request: Omit<GraphQLRequest<TVariables>, 'query'> & {\n      query?: string | DocumentNode | TypedQueryDocumentNode<TData, TVariables>;\n    },\n  ): Promise<GraphQLResponse<TData>>;\n  public async executeOperation<\n    TData = Record<string, unknown>,\n    TVariables extends VariableValues = VariableValues,\n  >(\n    request: Omit<GraphQLRequest<TVariables>, 'query'> & {\n      query?: string | DocumentNode | TypedQueryDocumentNode<TData, TVariables>;\n    },\n    options?: ExecuteOperationOptions<TContext>,\n  ): Promise<GraphQLResponse<TData>>;\n\n  async executeOperation<\n    TData = Record<string, unknown>,\n    TVariables extends VariableValues = VariableValues,\n  >(\n    request: Omit<GraphQLRequest<TVariables>, 'query'> & {\n      // We should consider supporting TypedDocumentNode from\n      // `@graphql-typed-document-node/core` as well, as it is more popular than\n      // the newer built-in type.\n      query?: string | DocumentNode | TypedQueryDocumentNode<TData, TVariables>;\n    },\n    options: ExecuteOperationOptions<TContext> = {},\n  ): Promise<GraphQLResponse<TData>> {\n    // Since this function is mostly for testing, you don't need to explicitly\n    // start your server before calling it. (That also means you can use it with\n    // `apollo-server` which doesn't support `start()`.)\n    if (this.internals.state.phase === 'initialized') {\n      await this.start();\n    }\n\n    const schemaDerivedData = (\n      await this._ensureStarted()\n    ).schemaManager.getSchemaDerivedData();\n\n    // For convenience, this function lets you pass either a string or an AST,\n    // but we normalize to string.\n    const graphQLRequest: GraphQLRequest = {\n      ...request,\n      query:\n        request.query && typeof request.query !== 'string'\n          ? print(request.query)\n          : request.query,\n    };\n\n    const response: GraphQLResponse = await internalExecuteOperation(\n      {\n        server: this,\n        graphQLRequest,\n        internals: this.internals,\n        schemaDerivedData,\n        sharedResponseHTTPGraphQLHead: null,\n      },\n      options,\n    );\n\n    // It's your job to set an appropriate TData (perhaps using codegen); we\n    // don't validate it.\n    return response as GraphQLResponse<TData>;\n  }\n}\n\n// Shared code between runHttpQuery (ie executeHTTPGraphQLRequest) and\n// executeOperation to set up a request context and invoke the request pipeline.\nexport async function internalExecuteOperation<TContext extends BaseContext>(\n  {\n    server,\n    graphQLRequest,\n    internals,\n    schemaDerivedData,\n    sharedResponseHTTPGraphQLHead,\n  }: {\n    server: ApolloServer<TContext>;\n    graphQLRequest: GraphQLRequest;\n    internals: ApolloServerInternals<TContext>;\n    schemaDerivedData: SchemaDerivedData;\n    sharedResponseHTTPGraphQLHead: HTTPGraphQLHead | null;\n  },\n  options: ExecuteOperationOptions<TContext>,\n): Promise<GraphQLResponse> {\n  const requestContext: GraphQLRequestContext<TContext> = {\n    logger: server.logger,\n    cache: server.cache,\n    schema: schemaDerivedData.schema,\n    request: graphQLRequest,\n    response: {\n      http: sharedResponseHTTPGraphQLHead ?? newHTTPGraphQLHead(),\n    },\n    // We clone the context because there are some assumptions that every operation\n    // execution has a brand new context object; specifically, in order to implement\n    // willResolveField we put a Symbol on the context that is specific to a particular\n    // request pipeline execution. We could avoid this if we had a better way of\n    // instrumenting execution.\n    //\n    // We don't want to do a deep clone here, because one of the main advantages of\n    // using batched HTTP requests is to share context across operations for a\n    // single request.\n    //\n    // The typecast here is safe, because the only way `contextValue` can be\n    // null-ish is if we used the `contextValue?: BaseContext` override, in\n    // which case TContext is BaseContext and {} is ok. (This does depend on\n    // the fact we've hackily forced the class to be contravariant in\n    // TContext.)\n    contextValue: cloneObject(options?.contextValue ?? ({} as TContext)),\n    metrics: {},\n    overallCachePolicy: newCachePolicy(),\n    requestIsBatched: sharedResponseHTTPGraphQLHead !== null,\n  };\n\n  try {\n    return await processGraphQLRequest(\n      schemaDerivedData,\n      server,\n      internals,\n      requestContext,\n    );\n  } catch (maybeError: unknown) {\n    // processGraphQLRequest throwing usually means that either there's a bug in\n    // Apollo Server or some plugin hook threw unexpectedly.\n    const error = ensureError(maybeError);\n    // If *these* hooks throw then we'll still get a 500 but won't mask its\n    // error.\n    await Promise.all(\n      internals.plugins.map(\n        async (plugin) =>\n          plugin.unexpectedErrorProcessingRequest?.({\n            requestContext,\n            error,\n          }),\n      ),\n    );\n    // Mask unexpected error externally.\n    server.logger.error(`Unexpected error processing request: ${error}`);\n    throw new Error('Internal server error');\n  }\n}\n\n// Unlike InternalPlugins (where we can decide whether to install the default\n// plugin based on looking at which plugins are installed),\n// ImplicitlyInstallablePlugins (ie the default landing page plugin) can't\n// determine if they're needed until later in startup. Specifically, we can't\n// know if we've defined our own landing page until after serverWillStart\n// plugins have run.\nexport type ImplicitlyInstallablePlugin<TContext extends BaseContext> =\n  ApolloServerPlugin<TContext> & {\n    __internal_installed_implicitly__: boolean;\n  };\n\nexport function isImplicitlyInstallablePlugin<TContext extends BaseContext>(\n  p: ApolloServerPlugin<TContext>,\n): p is ImplicitlyInstallablePlugin<TContext> {\n  return '__internal_installed_implicitly__' in p;\n}\n\nexport const MEDIA_TYPES = {\n  APPLICATION_JSON: 'application/json; charset=utf-8',\n  APPLICATION_JSON_GRAPHQL_CALLBACK:\n    'application/json; callbackSpec=1.0; charset=utf-8',\n  APPLICATION_GRAPHQL_RESPONSE_JSON:\n    'application/graphql-response+json; charset=utf-8',\n  // We do *not* currently support this content-type; we will once incremental\n  // delivery is part of the official GraphQL spec.\n  MULTIPART_MIXED_NO_DEFER_SPEC: 'multipart/mixed',\n  MULTIPART_MIXED_EXPERIMENTAL: 'multipart/mixed; deferSpec=20220824',\n  TEXT_HTML: 'text/html',\n};\n\nexport function chooseContentTypeForSingleResultResponse(\n  head: HTTPGraphQLHead,\n): string | null {\n  const acceptHeader = head.headers.get('accept');\n  if (!acceptHeader) {\n    // Note that we may change the default to\n    // 'application/graphql-response+json' by 2025 as encouraged by the\n    // graphql-over-http spec.\n    return MEDIA_TYPES.APPLICATION_JSON;\n  } else {\n    const preferred = new Negotiator({\n      headers: { accept: head.headers.get('accept') },\n    }).mediaType([\n      MEDIA_TYPES.APPLICATION_JSON,\n      MEDIA_TYPES.APPLICATION_GRAPHQL_RESPONSE_JSON,\n      MEDIA_TYPES.APPLICATION_JSON_GRAPHQL_CALLBACK,\n    ]);\n    if (preferred) {\n      return preferred;\n    } else {\n      return null;\n    }\n  }\n}\n\nfunction cloneObject<T extends Object>(object: T): T {\n  return Object.assign(Object.create(Object.getPrototypeOf(object)), object);\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 4239, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4243, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@apollo/server/src/externalTypes/index.ts"],"sourcesContent":["/**\n * This file represents the external type definitions needed by end users,\n * integration implementors, and plugin implementors. Everything from this file\n * is re-exported by the root (via * export), so add exports to this file with\n * intention (it's public API).\n */\nexport type { BaseContext, ContextFunction, ContextThunk } from './context.js';\nexport type { GraphQLRequest, GraphQLResponse } from './graphql.js';\nexport type {\n  HTTPGraphQLRequest,\n  HTTPGraphQLResponse,\n  HTTPGraphQLHead,\n} from './http.js';\nexport type {\n  ApolloServerPlugin,\n  GraphQLFieldResolverParams,\n  GraphQLRequestExecutionListener,\n  GraphQLRequestListener,\n  GraphQLRequestListenerDidResolveField,\n  GraphQLRequestListenerExecutionDidEnd,\n  GraphQLRequestListenerParsingDidEnd,\n  GraphQLRequestListenerValidationDidEnd,\n  GraphQLSchemaContext,\n  GraphQLServerListener,\n  GraphQLServerContext,\n  LandingPage,\n} from './plugins.js';\nexport type {\n  GraphQLRequestContext,\n  GraphQLRequestMetrics,\n  GraphQLRequestContextDidEncounterErrors,\n  GraphQLRequestContextDidResolveOperation,\n  GraphQLRequestContextDidResolveSource,\n  GraphQLRequestContextExecutionDidStart,\n  GraphQLRequestContextParsingDidStart,\n  GraphQLRequestContextResponseForOperation,\n  GraphQLRequestContextValidationDidStart,\n  GraphQLRequestContextWillSendResponse,\n} from './requestPipeline.js';\nexport type {\n  DocumentStore,\n  ApolloConfigInput,\n  ApolloConfig,\n  PersistedQueryOptions,\n  CSRFPreventionOptions,\n  ApolloServerOptionsWithSchema,\n  ApolloServerOptionsWithTypeDefs,\n  ApolloServerOptionsWithStaticSchema,\n  ApolloServerOptionsWithGateway,\n  ApolloServerOptions,\n} from './constructor.js';\n\nexport type {\n  GraphQLExperimentalFormattedInitialIncrementalExecutionResult,\n  GraphQLExperimentalFormattedSubsequentIncrementalExecutionResult,\n  GraphQLExperimentalFormattedIncrementalResult,\n  GraphQLExperimentalFormattedIncrementalDeferResult,\n  GraphQLExperimentalFormattedIncrementalStreamResult,\n} from './incrementalDeliveryPolyfill.js';\n"],"names":[],"mappings":""}},
    {"offset": {"line": 4247, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4251, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@apollo/server/src/index.ts"],"sourcesContent":["export { ApolloServer } from './ApolloServer.js';\nexport { HeaderMap } from './utils/HeaderMap.js';\n// Note that this is purely a type export.\nexport * from './externalTypes/index.js';\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAA;AAAS,OAAA,cAAA,CAAA,SAAA,gBAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,kBAAA,YAAY;IAAA;AAAA;AACrB,IAAA;AAAS,OAAA,cAAA,CAAA,SAAA,aAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,eAAA,SAAS;IAAA;AAAA;AAElB,sIAAA"}},
    {"offset": {"line": 4290, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4295, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@apollo/server/src/cachePolicy.ts"],"sourcesContent":["import type { CacheHint, CachePolicy } from '@apollo/cache-control-types';\n\nexport function newCachePolicy(): CachePolicy {\n  return {\n    maxAge: undefined,\n    scope: undefined,\n    restrict(hint: CacheHint) {\n      if (\n        hint.maxAge !== undefined &&\n        (this.maxAge === undefined || hint.maxAge < this.maxAge)\n      ) {\n        this.maxAge = hint.maxAge;\n      }\n      if (hint.scope !== undefined && this.scope !== 'PRIVATE') {\n        this.scope = hint.scope;\n      }\n    },\n    replace(hint: CacheHint) {\n      if (hint.maxAge !== undefined) {\n        this.maxAge = hint.maxAge;\n      }\n      if (hint.scope !== undefined) {\n        this.scope = hint.scope;\n      }\n    },\n    policyIfCacheable() {\n      if (this.maxAge === undefined || this.maxAge === 0) {\n        return null;\n      }\n      return { maxAge: this.maxAge, scope: this.scope ?? 'PUBLIC' };\n    },\n  };\n}\n"],"names":[],"mappings":";;;AAEM,SAAU;IACd,OAAO;QACL,QAAQ;QACR,OAAO;QACP,UAAS,IAAe;YACtB,IACE,KAAK,MAAM,KAAK,aAChB,CAAC,IAAI,CAAC,MAAM,KAAK,aAAa,KAAK,MAAM,GAAG,IAAI,CAAC,MAAM,GACvD;gBACA,IAAI,CAAC,MAAM,GAAG,KAAK,MAAM;YAC3B;YACA,IAAI,KAAK,KAAK,KAAK,aAAa,IAAI,CAAC,KAAK,KAAK,WAAW;gBACxD,IAAI,CAAC,KAAK,GAAG,KAAK,KAAK;YACzB;QACF;QACA,SAAQ,IAAe;YACrB,IAAI,KAAK,MAAM,KAAK,WAAW;gBAC7B,IAAI,CAAC,MAAM,GAAG,KAAK,MAAM;YAC3B;YACA,IAAI,KAAK,KAAK,KAAK,WAAW;gBAC5B,IAAI,CAAC,KAAK,GAAG,KAAK,KAAK;YACzB;QACF;QACA;YACE,IAAI,IAAI,CAAC,MAAM,KAAK,aAAa,IAAI,CAAC,MAAM,KAAK,GAAG;gBAClD,OAAO;YACT;YACA,OAAO;gBAAE,QAAQ,IAAI,CAAC,MAAM;gBAAE,OAAO,IAAI,CAAC,KAAK,IAAI;YAAQ;QAC7D;;AAEJ"}},
    {"offset": {"line": 4329, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4334, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@apollo/server/src/determineApolloConfig.ts"],"sourcesContent":["import { createHash } from '@apollo/utils.createhash';\nimport type { ApolloConfig, ApolloConfigInput } from './externalTypes/index.js';\nimport type { Logger } from '@apollo/utils.logger';\n\n// This function combines the `apollo` constructor argument and some environment\n// variables to come up with a full ApolloConfig.\nexport function determineApolloConfig(\n  input: ApolloConfigInput | undefined,\n  logger: Logger,\n): ApolloConfig {\n  const apolloConfig: ApolloConfig = {};\n\n  const {\n    APOLLO_KEY,\n    APOLLO_GRAPH_REF,\n    APOLLO_GRAPH_ID,\n    APOLLO_GRAPH_VARIANT,\n  } = process.env;\n\n  // Determine key.\n  if (input?.key) {\n    apolloConfig.key = input.key.trim();\n  } else if (APOLLO_KEY) {\n    apolloConfig.key = APOLLO_KEY.trim();\n  }\n  if ((input?.key ?? APOLLO_KEY) !== apolloConfig.key) {\n    logger.warn(\n      'The provided API key has unexpected leading or trailing whitespace. ' +\n        'Apollo Server will trim the key value before use.',\n    );\n  }\n\n  // Assert API key is a valid header value, since it's going to be used as one\n  // throughout.\n  if (apolloConfig.key) {\n    assertValidHeaderValue(apolloConfig.key);\n  }\n\n  // Determine key hash.\n  if (apolloConfig.key) {\n    apolloConfig.keyHash = createHash('sha512')\n      .update(apolloConfig.key)\n      .digest('hex');\n  }\n\n  // Determine graph ref, if provided together.\n  if (input?.graphRef) {\n    apolloConfig.graphRef = input.graphRef;\n  } else if (APOLLO_GRAPH_REF) {\n    apolloConfig.graphRef = APOLLO_GRAPH_REF;\n  }\n\n  // See if graph ID and variant were provided separately.\n  const graphId = input?.graphId ?? APOLLO_GRAPH_ID;\n  const graphVariant = input?.graphVariant ?? APOLLO_GRAPH_VARIANT;\n\n  if (apolloConfig.graphRef) {\n    if (graphId) {\n      throw new Error(\n        'Cannot specify both graph ref and graph ID. Please use ' +\n          '`apollo.graphRef` or `APOLLO_GRAPH_REF` without also setting the graph ID.',\n      );\n    }\n    if (graphVariant) {\n      throw new Error(\n        'Cannot specify both graph ref and graph variant. Please use ' +\n          '`apollo.graphRef` or `APOLLO_GRAPH_REF` without also setting the graph variant.',\n      );\n    }\n  } else if (graphId) {\n    // Graph ref is not specified, but the ID is. We can construct the ref\n    // from the ID and variant. Note that after this, we stop tracking the ID\n    // and variant, because Apollo Server 3 does not assume that all graph refs\n    // can be decomposed into ID and variant (except in the op reg plugin).\n    apolloConfig.graphRef = graphVariant\n      ? `${graphId}@${graphVariant}`\n      : graphId;\n  }\n\n  return apolloConfig;\n}\n\nfunction assertValidHeaderValue(value: string) {\n  // Ref: node-fetch@2.x `Headers` validation\n  // https://github.com/node-fetch/node-fetch/blob/9b9d45881e5ca68757077726b3c0ecf8fdca1f29/src/headers.js#L18\n  const invalidHeaderCharRegex = /[^\\t\\x20-\\x7e\\x80-\\xff]/g;\n  if (invalidHeaderCharRegex.test(value)) {\n    const invalidChars = value.match(invalidHeaderCharRegex)!;\n    throw new Error(\n      `The API key provided to Apollo Server contains characters which are invalid as HTTP header values. The following characters found in the key are invalid: ${invalidChars.join(\n        ', ',\n      )}. Valid header values may only contain ASCII visible characters. If you think there is an issue with your key, please contact Apollo support.`,\n    );\n  }\n}\n"],"names":[],"mappings":";;;;;;AAMM,SAAU,sBACd,KAAoC,EACpC,MAAc;IAEd,MAAM,eAA6B,CAAA;IAEnC,MAAM,EACJ,UAAU,EACV,gBAAgB,EAChB,eAAe,EACf,oBAAoB,EACrB,GAAG,QAAQ,GAAG;IAGf,IAAI,OAAO,KAAK;QACd,aAAa,GAAG,GAAG,MAAM,GAAG,CAAC,IAAI;IACnC,OAAO,IAAI,YAAY;QACrB,aAAa,GAAG,GAAG,WAAW,IAAI;IACpC;IACA,IAAI,CAAC,OAAO,OAAO,UAAU,MAAM,aAAa,GAAG,EAAE;QACnD,OAAO,IAAI,CACT,yEACE;IAEN;IAIA,IAAI,aAAa,GAAG,EAAE;QACpB,uBAAuB,aAAa,GAAG;IACzC;IAGA,IAAI,aAAa,GAAG,EAAE;QACpB,aAAa,OAAO,GAAG,CAAA,GAAA,kKAAA,CAAA,aAAU,AAAV,EAAW,UAC/B,MAAM,CAAC,aAAa,GAAG,EACvB,MAAM,CAAC;IACZ;IAGA,IAAI,OAAO,UAAU;QACnB,aAAa,QAAQ,GAAG,MAAM,QAAQ;IACxC,OAAO,IAAI,kBAAkB;QAC3B,aAAa,QAAQ,GAAG;IAC1B;IAGA,MAAM,UAAU,OAAO,WAAW;IAClC,MAAM,eAAe,OAAO,gBAAgB;IAE5C,IAAI,aAAa,QAAQ,EAAE;QACzB,IAAI,SAAS;YACX,MAAM,IAAI,MACR,4DACE;QAEN;QACA,IAAI,cAAc;YAChB,MAAM,IAAI,MACR,iEACE;QAEN;IACF,OAAO,IAAI,SAAS;QAKlB,aAAa,QAAQ,GAAG,eACpB,CAAA,EAAG,QAAO,CAAA,EAAI,aAAY,CAAE,GAC5B;IACN;IAEA,OAAO;AACT;AAEA,SAAS,uBAAuB,KAAa;IAG3C,MAAM,yBAAyB;IAC/B,IAAI,uBAAuB,IAAI,CAAC,QAAQ;QACtC,MAAM,eAAe,MAAM,KAAK,CAAC;QACjC,MAAM,IAAI,MACR,CAAA,0JAAA,EAA6J,aAAa,IAAI,CAC5K,MACD,6IAAA,CAA+I;IAEpJ;AACF"}},
    {"offset": {"line": 4383, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4388, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@apollo/server/src/errors/index.ts"],"sourcesContent":["import { GraphQLError } from 'graphql';\n\nexport enum ApolloServerErrorCode {\n  INTERNAL_SERVER_ERROR = 'INTERNAL_SERVER_ERROR',\n  GRAPHQL_PARSE_FAILED = 'GRAPHQL_PARSE_FAILED',\n  GRAPHQL_VALIDATION_FAILED = 'GRAPHQL_VALIDATION_FAILED',\n  PERSISTED_QUERY_NOT_FOUND = 'PERSISTED_QUERY_NOT_FOUND',\n  PERSISTED_QUERY_NOT_SUPPORTED = 'PERSISTED_QUERY_NOT_SUPPORTED',\n  BAD_USER_INPUT = 'BAD_USER_INPUT',\n  OPERATION_RESOLUTION_FAILURE = 'OPERATION_RESOLUTION_FAILURE',\n  BAD_REQUEST = 'BAD_REQUEST',\n}\n\nexport enum ApolloServerValidationErrorCode {\n  INTROSPECTION_DISABLED = 'INTROSPECTION_DISABLED',\n}\n\n/**\n * unwrapResolverError is a useful helper function for `formatError` hooks.\n * Errors thrown in resolvers are wrapped by graphql-js in a GraphQLError that\n * adds context such as the `path` to the field in the operation. If you'd like\n * to look directly at the original error thrown in the resolver (with whatever\n * data is on that error object, but without fields like `path`), you can use\n * this function. Note that other GraphQLErrors that contain `originalError`\n * (like parse errors) are not unwrapped by this function.\n */\nexport function unwrapResolverError(error: unknown): unknown {\n  if (error instanceof GraphQLError && error.path && error.originalError) {\n    return error.originalError;\n  }\n  return error;\n}\n"],"names":[],"mappings":";;;;;;;;AAEA,IAAY;AAAZ,CAAA,SAAY,qBAAqB;IAC/B,qBAAA,CAAA,wBAAA,GAAA;IACA,qBAAA,CAAA,uBAAA,GAAA;IACA,qBAAA,CAAA,4BAAA,GAAA;IACA,qBAAA,CAAA,4BAAA,GAAA;IACA,qBAAA,CAAA,gCAAA,GAAA;IACA,qBAAA,CAAA,iBAAA,GAAA;IACA,qBAAA,CAAA,+BAAA,GAAA;IACA,qBAAA,CAAA,cAAA,GAAA;AACF,CAAC,EATW,yBAAqB,CAArB,wBAAqB,CAAA,CAAA;AAWjC,IAAY;AAAZ,CAAA,SAAY,+BAA+B;IACzC,+BAAA,CAAA,yBAAA,GAAA;AACF,CAAC,EAFW,mCAA+B,CAA/B,kCAA+B,CAAA,CAAA;AAarC,SAAU,oBAAoB,KAAc;IAChD,IAAI,iBAAiB,mJAAA,CAAA,eAAY,IAAI,MAAM,IAAI,IAAI,MAAM,aAAa,EAAE;QACtE,OAAO,MAAM,aAAa;IAC5B;IACA,OAAO;AACT"}},
    {"offset": {"line": 4417, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4422, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@apollo/server/src/utils/HeaderMap.ts"],"sourcesContent":["export class HeaderMap extends Map<string, string> {\n  // In order for TypeScript to prevent a standard `Map` from being compatible\n  // with a `HeaderMap`, we need some additional property on the class.\n  // @ts-ignore (this is just unused)\n  private __identity = Symbol('HeaderMap');\n\n  override set(key: string, value: string): this {\n    return super.set(key.toLowerCase(), value);\n  }\n\n  override get(key: string) {\n    return super.get(key.toLowerCase());\n  }\n\n  override delete(key: string) {\n    return super.delete(key.toLowerCase());\n  }\n\n  override has(key: string) {\n    return super.has(key.toLowerCase());\n  }\n}\n"],"names":[],"mappings":";;;AAAM,MAAO,kBAAkB;IAA/B,aAAA;;QAIU,IAAA,CAAA,UAAU,GAAG,OAAO;IAiB9B;IAfW,IAAI,GAAW,EAAE,KAAa,EAAA;QACrC,OAAO,KAAK,CAAC,IAAI,IAAI,WAAW,IAAI;IACtC;IAES,IAAI,GAAW,EAAA;QACtB,OAAO,KAAK,CAAC,IAAI,IAAI,WAAW;IAClC;IAES,OAAO,GAAW,EAAA;QACzB,OAAO,KAAK,CAAC,OAAO,IAAI,WAAW;IACrC;IAES,IAAI,GAAW,EAAA;QACtB,OAAO,KAAK,CAAC,IAAI,IAAI,WAAW;IAClC"}},
    {"offset": {"line": 4443, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4448, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@apollo/server/src/internalErrorClasses.ts"],"sourcesContent":["import { GraphQLError, type GraphQLErrorOptions } from 'graphql';\nimport { ApolloServerErrorCode } from './errors/index.js';\nimport { newHTTPGraphQLHead } from './runHttpQuery.js';\nimport { HeaderMap } from './utils/HeaderMap.js';\n\n// These error classes are not part of Apollo Server's external API; the\n// ApolloServerErrorCode enum is (exported from `@apollo/server/errors`).\n\nclass GraphQLErrorWithCode extends GraphQLError {\n  constructor(\n    message: string,\n    code: ApolloServerErrorCode,\n    options?: GraphQLErrorOptions,\n  ) {\n    super(message, {\n      ...options,\n      extensions: { ...options?.extensions, code },\n    });\n    this.name = this.constructor.name;\n  }\n}\n\nexport class SyntaxError extends GraphQLErrorWithCode {\n  constructor(graphqlError: GraphQLError) {\n    super(graphqlError.message, ApolloServerErrorCode.GRAPHQL_PARSE_FAILED, {\n      source: graphqlError.source,\n      positions: graphqlError.positions,\n      extensions: { http: newHTTPGraphQLHead(400), ...graphqlError.extensions },\n      originalError: graphqlError,\n    });\n  }\n}\n\nexport class ValidationError extends GraphQLErrorWithCode {\n  constructor(graphqlError: GraphQLError) {\n    super(\n      graphqlError.message,\n      ApolloServerErrorCode.GRAPHQL_VALIDATION_FAILED,\n      {\n        nodes: graphqlError.nodes,\n        extensions: {\n          http: newHTTPGraphQLHead(400),\n          ...graphqlError.extensions,\n        },\n        originalError: graphqlError.originalError ?? graphqlError,\n      },\n    );\n  }\n}\n\n// Persisted query errors (especially \"not found\") need to be uncached, because\n// hopefully we're about to fill in the APQ cache and the same request will\n// succeed next time. We also want a 200 response to avoid any error handling\n// that may mask the contents of an error response. (Otherwise, the default\n// status code for a response with `errors` but no `data` (even null) is 400.)\nconst getPersistedQueryErrorHttp = () => ({\n  status: 200,\n  headers: new HeaderMap([\n    ['cache-control', 'private, no-cache, must-revalidate'],\n  ]),\n});\n\nexport class PersistedQueryNotFoundError extends GraphQLErrorWithCode {\n  constructor() {\n    super(\n      'PersistedQueryNotFound',\n      ApolloServerErrorCode.PERSISTED_QUERY_NOT_FOUND,\n      { extensions: { http: getPersistedQueryErrorHttp() } },\n    );\n  }\n}\n\nexport class PersistedQueryNotSupportedError extends GraphQLErrorWithCode {\n  constructor() {\n    super(\n      'PersistedQueryNotSupported',\n      ApolloServerErrorCode.PERSISTED_QUERY_NOT_SUPPORTED,\n      // Not super clear why we need this to be uncached (makes sense for\n      // PersistedQueryNotFoundError, because there we're about to fill the\n      // cache and make the next copy of the same request succeed) but we've\n      // been doing it for years so :shrug:\n      { extensions: { http: getPersistedQueryErrorHttp() } },\n    );\n  }\n}\n\nexport class UserInputError extends GraphQLErrorWithCode {\n  constructor(graphqlError: GraphQLError) {\n    super(graphqlError.message, ApolloServerErrorCode.BAD_USER_INPUT, {\n      nodes: graphqlError.nodes,\n      originalError: graphqlError.originalError ?? graphqlError,\n      extensions: graphqlError.extensions,\n    });\n  }\n}\n\nexport class OperationResolutionError extends GraphQLErrorWithCode {\n  constructor(graphqlError: GraphQLError) {\n    super(\n      graphqlError.message,\n      ApolloServerErrorCode.OPERATION_RESOLUTION_FAILURE,\n      {\n        nodes: graphqlError.nodes,\n        originalError: graphqlError.originalError ?? graphqlError,\n        extensions: {\n          http: newHTTPGraphQLHead(400),\n          ...graphqlError.extensions,\n        },\n      },\n    );\n  }\n}\n\nexport class BadRequestError extends GraphQLErrorWithCode {\n  constructor(message: string, options?: GraphQLErrorOptions) {\n    super(message, ApolloServerErrorCode.BAD_REQUEST, {\n      ...options,\n      // Default to 400 status code, but caller can override. (If caller just\n      // wants to override headers... well, they can't, sorry.)\n      extensions: { http: newHTTPGraphQLHead(400), ...options?.extensions },\n    });\n  }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAQA,MAAM,6BAA6B,mJAAA,CAAA,eAAY;IAC7C,YACE,OAAe,EACf,IAA2B,EAC3B,OAA6B,CAAA;QAE7B,KAAK,CAAC,SAAS;YACb,GAAG,OAAO;YACV,YAAY;gBAAE,GAAG,SAAS,UAAU;gBAAE;YAAI;;QAE5C,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,WAAW,CAAC,IAAI;IACnC;;AAGI,MAAO,oBAAoB;IAC/B,YAAY,YAA0B,CAAA;QACpC,KAAK,CAAC,aAAa,OAAO,EAAE,sKAAA,CAAA,wBAAqB,CAAC,oBAAoB,EAAE;YACtE,QAAQ,aAAa,MAAM;YAC3B,WAAW,aAAa,SAAS;YACjC,YAAY;gBAAE,MAAM,CAAA,GAAA,mKAAA,CAAA,qBAAkB,AAAlB,EAAmB;gBAAM,GAAG,aAAa,UAAU;YAAA;YACvE,eAAe;;IAEnB;;AAGI,MAAO,wBAAwB;IACnC,YAAY,YAA0B,CAAA;QACpC,KAAK,CACH,aAAa,OAAO,EACpB,sKAAA,CAAA,wBAAqB,CAAC,yBAAyB,EAC/C;YACE,OAAO,aAAa,KAAK;YACzB,YAAY;gBACV,MAAM,CAAA,GAAA,mKAAA,CAAA,qBAAkB,AAAlB,EAAmB;gBACzB,GAAG,aAAa,UAAU;;YAE5B,eAAe,aAAa,aAAa,IAAI;;IAGnD;;AAQF,MAAM,6BAA6B,IAAM,CAAC;QACxC,QAAQ;QACR,SAAS,IAAI,yKAAA,CAAA,YAAS,CAAC;YACrB;gBAAC;gBAAiB;aAAqC;SACxD;KACF;AAEK,MAAO,oCAAoC;IAC/C,aAAA;QACE,KAAK,CACH,0BACA,sKAAA,CAAA,wBAAqB,CAAC,yBAAyB,EAC/C;YAAE,YAAY;gBAAE,MAAM;YAA4B;QAAE;IAExD;;AAGI,MAAO,wCAAwC;IACnD,aAAA;QACE,KAAK,CACH,8BACA,sKAAA,CAAA,wBAAqB,CAAC,6BAA6B,EAKnD;YAAE,YAAY;gBAAE,MAAM;YAA4B;QAAE;IAExD;;AAGI,MAAO,uBAAuB;IAClC,YAAY,YAA0B,CAAA;QACpC,KAAK,CAAC,aAAa,OAAO,EAAE,sKAAA,CAAA,wBAAqB,CAAC,cAAc,EAAE;YAChE,OAAO,aAAa,KAAK;YACzB,eAAe,aAAa,aAAa,IAAI;YAC7C,YAAY,aAAa,UAAU;;IAEvC;;AAGI,MAAO,iCAAiC;IAC5C,YAAY,YAA0B,CAAA;QACpC,KAAK,CACH,aAAa,OAAO,EACpB,sKAAA,CAAA,wBAAqB,CAAC,4BAA4B,EAClD;YACE,OAAO,aAAa,KAAK;YACzB,eAAe,aAAa,aAAa,IAAI;YAC7C,YAAY;gBACV,MAAM,CAAA,GAAA,mKAAA,CAAA,qBAAkB,AAAlB,EAAmB;gBACzB,GAAG,aAAa,UAAU;;;IAIlC;;AAGI,MAAO,wBAAwB;IACnC,YAAY,OAAe,EAAE,OAA6B,CAAA;QACxD,KAAK,CAAC,SAAS,sKAAA,CAAA,wBAAqB,CAAC,WAAW,EAAE;YAChD,GAAG,OAAO;YAGV,YAAY;gBAAE,MAAM,CAAA,GAAA,mKAAA,CAAA,qBAAkB,AAAlB,EAAmB;gBAAM,GAAG,SAAS,UAAU;YAAA;;IAEvE"}},
    {"offset": {"line": 4562, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4567, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@apollo/server/src/runHttpQuery.ts"],"sourcesContent":["import type {\n  BaseContext,\n  GraphQLExperimentalFormattedIncrementalResult,\n  GraphQLExperimentalFormattedInitialIncrementalExecutionResult,\n  GraphQLExperimentalFormattedSubsequentIncrementalExecutionResult,\n  GraphQLRequest,\n  HTTPGraphQLHead,\n  HTTPGraphQLRequest,\n  HTTPGraphQLResponse,\n} from './externalTypes/index.js';\nimport {\n  type ApolloServer,\n  type ApolloServerInternals,\n  chooseContentTypeForSingleResultResponse,\n  internalExecuteOperation,\n  MEDIA_TYPES,\n  type SchemaDerivedData,\n} from './ApolloServer.js';\nimport { type FormattedExecutionResult, Kind } from 'graphql';\nimport { BadRequestError } from './internalErrorClasses.js';\nimport Negotiator from 'negotiator';\nimport { HeaderMap } from './utils/HeaderMap.js';\n\nfunction fieldIfString(\n  o: Record<string, unknown>,\n  fieldName: string,\n): string | undefined {\n  const value = o[fieldName];\n  if (typeof value === 'string') {\n    return value;\n  }\n  return undefined;\n}\n\nfunction searchParamIfSpecifiedOnce(\n  searchParams: URLSearchParams,\n  paramName: string,\n) {\n  const values = searchParams.getAll(paramName);\n  switch (values.length) {\n    case 0:\n      return undefined;\n    case 1:\n      return values[0];\n    default:\n      throw new BadRequestError(\n        `The '${paramName}' search parameter may only be specified once.`,\n      );\n  }\n}\n\nfunction jsonParsedSearchParamIfSpecifiedOnce(\n  searchParams: URLSearchParams,\n  fieldName: string,\n): Record<string, unknown> | undefined {\n  const value = searchParamIfSpecifiedOnce(searchParams, fieldName);\n  if (value === undefined) {\n    return undefined;\n  }\n  let hopefullyRecord;\n  try {\n    hopefullyRecord = JSON.parse(value);\n  } catch {\n    throw new BadRequestError(\n      `The ${fieldName} search parameter contains invalid JSON.`,\n    );\n  }\n  if (!isStringRecord(hopefullyRecord)) {\n    throw new BadRequestError(\n      `The ${fieldName} search parameter should contain a JSON-encoded object.`,\n    );\n  }\n  return hopefullyRecord;\n}\n\nfunction fieldIfRecord(\n  o: Record<string, unknown>,\n  fieldName: string,\n): Record<string, unknown> | undefined {\n  const value = o[fieldName];\n  if (isStringRecord(value)) {\n    return value;\n  }\n  return undefined;\n}\n\nfunction isStringRecord(o: unknown): o is Record<string, unknown> {\n  return (\n    !!o && typeof o === 'object' && !Buffer.isBuffer(o) && !Array.isArray(o)\n  );\n}\n\nfunction isNonEmptyStringRecord(o: unknown): o is Record<string, unknown> {\n  return isStringRecord(o) && Object.keys(o).length > 0;\n}\n\nfunction ensureQueryIsStringOrMissing(query: unknown) {\n  if (!query || typeof query === 'string') {\n    return;\n  }\n  // Check for a common error first.\n  if ((query as any).kind === Kind.DOCUMENT) {\n    throw new BadRequestError(\n      \"GraphQL queries must be strings. It looks like you're sending the \" +\n        'internal graphql-js representation of a parsed query in your ' +\n        'request instead of a request in the GraphQL query language. You ' +\n        'can convert an AST to a string using the `print` function from ' +\n        '`graphql`, or use a client like `apollo-client` which converts ' +\n        'the internal representation to a string for you.',\n    );\n  } else {\n    throw new BadRequestError('GraphQL queries must be strings.');\n  }\n}\n\nexport async function runHttpQuery<TContext extends BaseContext>({\n  server,\n  httpRequest,\n  contextValue,\n  schemaDerivedData,\n  internals,\n  sharedResponseHTTPGraphQLHead,\n}: {\n  server: ApolloServer<TContext>;\n  httpRequest: HTTPGraphQLRequest;\n  contextValue: TContext;\n  schemaDerivedData: SchemaDerivedData;\n  internals: ApolloServerInternals<TContext>;\n  sharedResponseHTTPGraphQLHead: HTTPGraphQLHead | null;\n}): Promise<HTTPGraphQLResponse> {\n  let graphQLRequest: GraphQLRequest;\n\n  switch (httpRequest.method) {\n    case 'POST': {\n      if (!isNonEmptyStringRecord(httpRequest.body)) {\n        throw new BadRequestError(\n          'POST body missing, invalid Content-Type, or JSON object has no keys.',\n        );\n      }\n\n      ensureQueryIsStringOrMissing(httpRequest.body.query);\n\n      if (typeof httpRequest.body.variables === 'string') {\n        throw new BadRequestError(\n          '`variables` in a POST body should be provided as an object, not a recursively JSON-encoded string.',\n        );\n      }\n\n      if (typeof httpRequest.body.extensions === 'string') {\n        throw new BadRequestError(\n          '`extensions` in a POST body should be provided as an object, not a recursively JSON-encoded string.',\n        );\n      }\n\n      if (\n        'extensions' in httpRequest.body &&\n        httpRequest.body.extensions !== null &&\n        !isStringRecord(httpRequest.body.extensions)\n      ) {\n        throw new BadRequestError(\n          '`extensions` in a POST body must be an object if provided.',\n        );\n      }\n\n      if (\n        'variables' in httpRequest.body &&\n        httpRequest.body.variables !== null &&\n        !isStringRecord(httpRequest.body.variables)\n      ) {\n        throw new BadRequestError(\n          '`variables` in a POST body must be an object if provided.',\n        );\n      }\n\n      if (\n        'operationName' in httpRequest.body &&\n        httpRequest.body.operationName !== null &&\n        typeof httpRequest.body.operationName !== 'string'\n      ) {\n        throw new BadRequestError(\n          '`operationName` in a POST body must be a string if provided.',\n        );\n      }\n\n      graphQLRequest = {\n        query: fieldIfString(httpRequest.body, 'query'),\n        operationName: fieldIfString(httpRequest.body, 'operationName'),\n        variables: fieldIfRecord(httpRequest.body, 'variables'),\n        extensions: fieldIfRecord(httpRequest.body, 'extensions'),\n        http: httpRequest,\n      };\n\n      break;\n    }\n\n    case 'GET': {\n      const searchParams = new URLSearchParams(httpRequest.search);\n\n      graphQLRequest = {\n        query: searchParamIfSpecifiedOnce(searchParams, 'query'),\n        operationName: searchParamIfSpecifiedOnce(\n          searchParams,\n          'operationName',\n        ),\n        variables: jsonParsedSearchParamIfSpecifiedOnce(\n          searchParams,\n          'variables',\n        ),\n        extensions: jsonParsedSearchParamIfSpecifiedOnce(\n          searchParams,\n          'extensions',\n        ),\n        http: httpRequest,\n      };\n\n      break;\n    }\n    default:\n      throw new BadRequestError(\n        'Apollo Server supports only GET/POST requests.',\n        {\n          extensions: {\n            http: {\n              status: 405,\n              headers: new HeaderMap([['allow', 'GET, POST']]),\n            },\n          },\n        },\n      );\n  }\n\n  const graphQLResponse = await internalExecuteOperation(\n    {\n      server,\n      graphQLRequest,\n      internals,\n      schemaDerivedData,\n      sharedResponseHTTPGraphQLHead,\n    },\n    { contextValue },\n  );\n\n  if (graphQLResponse.body.kind === 'single') {\n    if (!graphQLResponse.http.headers.get('content-type')) {\n      // If we haven't already set the content-type (via a plugin or something),\n      // decide which content-type to use based on the accept header.\n      const contentType = chooseContentTypeForSingleResultResponse(httpRequest);\n      if (contentType === null) {\n        throw new BadRequestError(\n          `An 'accept' header was provided for this request which does not accept ` +\n            `${MEDIA_TYPES.APPLICATION_JSON} or ${MEDIA_TYPES.APPLICATION_GRAPHQL_RESPONSE_JSON}`,\n          // Use 406 Not Accepted\n          { extensions: { http: { status: 406 } } },\n        );\n      }\n      graphQLResponse.http.headers.set('content-type', contentType);\n    }\n\n    return {\n      ...graphQLResponse.http,\n      body: {\n        kind: 'complete',\n        string: await internals.stringifyResult(\n          orderExecutionResultFields(graphQLResponse.body.singleResult),\n        ),\n      },\n    };\n  }\n\n  // Note that incremental delivery is not yet part of the official GraphQL\n  // spec. We are implementing a proposed version of the spec, and require\n  // clients to explicitly state `deferSpec=20220824`. Once incremental delivery\n  // has been added to the GraphQL spec, we will support `accept` headers\n  // without `deferSpec` as well (perhaps with slightly different behavior if\n  // anything has changed).\n  const acceptHeader = httpRequest.headers.get('accept');\n  if (\n    !(\n      acceptHeader &&\n      new Negotiator({\n        headers: { accept: httpRequest.headers.get('accept') },\n      }).mediaType([\n        // mediaType() will return the first one that matches, so if the client\n        // doesn't include the deferSpec parameter it will match this one here,\n        // which isn't good enough.\n        MEDIA_TYPES.MULTIPART_MIXED_NO_DEFER_SPEC,\n        MEDIA_TYPES.MULTIPART_MIXED_EXPERIMENTAL,\n      ]) === MEDIA_TYPES.MULTIPART_MIXED_EXPERIMENTAL\n    )\n  ) {\n    // The client ran an operation that would yield multiple parts, but didn't\n    // specify `accept: multipart/mixed`. We return an error.\n    throw new BadRequestError(\n      'Apollo server received an operation that uses incremental delivery ' +\n        '(@defer or @stream), but the client does not accept multipart/mixed ' +\n        'HTTP responses. To enable incremental delivery support, add the HTTP ' +\n        \"header 'Accept: multipart/mixed; deferSpec=20220824'.\",\n      // Use 406 Not Accepted\n      { extensions: { http: { status: 406 } } },\n    );\n  }\n\n  graphQLResponse.http.headers.set(\n    'content-type',\n    'multipart/mixed; boundary=\"-\"; deferSpec=20220824',\n  );\n  return {\n    ...graphQLResponse.http,\n    body: {\n      kind: 'chunked',\n      asyncIterator: writeMultipartBody(\n        graphQLResponse.body.initialResult,\n        graphQLResponse.body.subsequentResults,\n      ),\n    },\n  };\n}\n\nasync function* writeMultipartBody(\n  initialResult: GraphQLExperimentalFormattedInitialIncrementalExecutionResult,\n  subsequentResults: AsyncIterable<GraphQLExperimentalFormattedSubsequentIncrementalExecutionResult>,\n): AsyncGenerator<string> {\n  // Note: we assume in this function that every result other than the last has\n  // hasNext=true and the last has hasNext=false. That is, we choose which kind\n  // of delimiter to place at the end of each block based on the contents of the\n  // message, not the structure of the async iterator. This makes sense because\n  // we want to write the delimiter as soon as each block is done (so the client\n  // can parse it immediately) but we may not know whether a general async\n  // iterator is finished until we do async work.\n\n  yield `\\r\\n---\\r\\ncontent-type: application/json; charset=utf-8\\r\\n\\r\\n${JSON.stringify(\n    orderInitialIncrementalExecutionResultFields(initialResult),\n  )}\\r\\n---${initialResult.hasNext ? '' : '--'}\\r\\n`;\n\n  for await (const result of subsequentResults) {\n    yield `content-type: application/json; charset=utf-8\\r\\n\\r\\n${JSON.stringify(\n      orderSubsequentIncrementalExecutionResultFields(result),\n    )}\\r\\n---${result.hasNext ? '' : '--'}\\r\\n`;\n  }\n}\n\n// See https://github.com/facebook/graphql/pull/384 for why\n// errors comes first.\nfunction orderExecutionResultFields(\n  result: FormattedExecutionResult,\n): FormattedExecutionResult {\n  return {\n    errors: result.errors,\n    data: result.data,\n    extensions: result.extensions,\n  };\n}\nfunction orderInitialIncrementalExecutionResultFields(\n  result: GraphQLExperimentalFormattedInitialIncrementalExecutionResult,\n): GraphQLExperimentalFormattedInitialIncrementalExecutionResult {\n  return {\n    hasNext: result.hasNext,\n    errors: result.errors,\n    data: result.data,\n    incremental: orderIncrementalResultFields(result.incremental),\n    extensions: result.extensions,\n  };\n}\nfunction orderSubsequentIncrementalExecutionResultFields(\n  result: GraphQLExperimentalFormattedSubsequentIncrementalExecutionResult,\n): GraphQLExperimentalFormattedSubsequentIncrementalExecutionResult {\n  return {\n    hasNext: result.hasNext,\n    incremental: orderIncrementalResultFields(result.incremental),\n    extensions: result.extensions,\n  };\n}\n\nfunction orderIncrementalResultFields(\n  incremental?: readonly GraphQLExperimentalFormattedIncrementalResult[],\n): undefined | GraphQLExperimentalFormattedIncrementalResult[] {\n  return incremental?.map((i: any) => ({\n    hasNext: i.hasNext,\n    errors: i.errors,\n    path: i.path,\n    label: i.label,\n    data: i.data,\n    items: i.items,\n    extensions: i.extensions,\n  }));\n}\n\n// The result of a curl does not appear well in the terminal, so we add an extra new line\nexport function prettyJSONStringify(value: FormattedExecutionResult) {\n  return JSON.stringify(value) + '\\n';\n}\n\nexport function newHTTPGraphQLHead(status?: number): HTTPGraphQLHead {\n  return {\n    status,\n    headers: new HeaderMap(),\n  };\n}\n\n// Updates `target` with status code and headers from `source`. For now let's\n// consider it undefined what happens if both have a status code set or both set\n// the same header.\nexport function mergeHTTPGraphQLHead(\n  target: HTTPGraphQLHead,\n  source: HTTPGraphQLHead,\n) {\n  if (source.status) {\n    target.status = source.status;\n  }\n  if (source.headers) {\n    for (const [name, value] of source.headers) {\n      // If source.headers contains non-lowercase header names, this will\n      // catch that case as long as target.headers is a HeaderMap.\n      target.headers.set(name, value);\n    }\n  }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAuBA,SAAS,cACP,CAA0B,EAC1B,SAAiB;IAEjB,MAAM,QAAQ,CAAC,CAAC,UAAU;IAC1B,IAAI,OAAO,UAAU,UAAU;QAC7B,OAAO;IACT;IACA,OAAO;AACT;AAEA,SAAS,2BACP,YAA6B,EAC7B,SAAiB;IAEjB,MAAM,SAAS,aAAa,MAAM,CAAC;IACnC,OAAQ,OAAO,MAAM;QACnB,KAAK;YACH,OAAO;QACT,KAAK;YACH,OAAO,MAAM,CAAC,EAAE;QAClB;YACE,MAAM,IAAI,2KAAA,CAAA,kBAAe,CACvB,CAAA,KAAA,EAAQ,UAAS,8CAAA,CAAgD;IAEvE;AACF;AAEA,SAAS,qCACP,YAA6B,EAC7B,SAAiB;IAEjB,MAAM,QAAQ,2BAA2B,cAAc;IACvD,IAAI,UAAU,WAAW;QACvB,OAAO;IACT;IACA,IAAI;IACJ,IAAI;QACF,kBAAkB,KAAK,KAAK,CAAC;IAC/B,EAAE,OAAM;QACN,MAAM,IAAI,2KAAA,CAAA,kBAAe,CACvB,CAAA,IAAA,EAAO,UAAS,wCAAA,CAA0C;IAE9D;IACA,IAAI,CAAC,eAAe,kBAAkB;QACpC,MAAM,IAAI,2KAAA,CAAA,kBAAe,CACvB,CAAA,IAAA,EAAO,UAAS,uDAAA,CAAyD;IAE7E;IACA,OAAO;AACT;AAEA,SAAS,cACP,CAA0B,EAC1B,SAAiB;IAEjB,MAAM,QAAQ,CAAC,CAAC,UAAU;IAC1B,IAAI,eAAe,QAAQ;QACzB,OAAO;IACT;IACA,OAAO;AACT;AAEA,SAAS,eAAe,CAAU;IAChC,OACE,CAAC,CAAC,KAAK,OAAO,MAAM,YAAY,CAAC,OAAO,QAAQ,CAAC,MAAM,CAAC,MAAM,OAAO,CAAC;AAE1E;AAEA,SAAS,uBAAuB,CAAU;IACxC,OAAO,eAAe,MAAM,OAAO,IAAI,CAAC,GAAG,MAAM,GAAG;AACtD;AAEA,SAAS,6BAA6B,KAAc;IAClD,IAAI,CAAC,SAAS,OAAO,UAAU,UAAU;QACvC;IACF;IAEA,IAAK,MAAc,IAAI,KAAK,+IAAA,CAAA,OAAI,CAAC,QAAQ,EAAE;QACzC,MAAM,IAAI,2KAAA,CAAA,kBAAe,CACvB,uEACE,kEACA,qEACA,oEACA,oEACA;IAEN,OAAO;QACL,MAAM,IAAI,2KAAA,CAAA,kBAAe,CAAC;IAC5B;AACF;AAEO,eAAe,aAA2C,EAC/D,MAAM,EACN,WAAW,EACX,YAAY,EACZ,iBAAiB,EACjB,SAAS,EACT,6BAA6B,EAQ9B;IACC,IAAI;IAEJ,OAAQ,YAAY,MAAM;QACxB,KAAK;YAAQ;gBACX,IAAI,CAAC,uBAAuB,YAAY,IAAI,GAAG;oBAC7C,MAAM,IAAI,2KAAA,CAAA,kBAAe,CACvB;gBAEJ;gBAEA,6BAA6B,YAAY,IAAI,CAAC,KAAK;gBAEnD,IAAI,OAAO,YAAY,IAAI,CAAC,SAAS,KAAK,UAAU;oBAClD,MAAM,IAAI,2KAAA,CAAA,kBAAe,CACvB;gBAEJ;gBAEA,IAAI,OAAO,YAAY,IAAI,CAAC,UAAU,KAAK,UAAU;oBACnD,MAAM,IAAI,2KAAA,CAAA,kBAAe,CACvB;gBAEJ;gBAEA,IACE,gBAAgB,YAAY,IAAI,IAChC,YAAY,IAAI,CAAC,UAAU,KAAK,QAChC,CAAC,eAAe,YAAY,IAAI,CAAC,UAAU,GAC3C;oBACA,MAAM,IAAI,2KAAA,CAAA,kBAAe,CACvB;gBAEJ;gBAEA,IACE,eAAe,YAAY,IAAI,IAC/B,YAAY,IAAI,CAAC,SAAS,KAAK,QAC/B,CAAC,eAAe,YAAY,IAAI,CAAC,SAAS,GAC1C;oBACA,MAAM,IAAI,2KAAA,CAAA,kBAAe,CACvB;gBAEJ;gBAEA,IACE,mBAAmB,YAAY,IAAI,IACnC,YAAY,IAAI,CAAC,aAAa,KAAK,QACnC,OAAO,YAAY,IAAI,CAAC,aAAa,KAAK,UAC1C;oBACA,MAAM,IAAI,2KAAA,CAAA,kBAAe,CACvB;gBAEJ;gBAEA,iBAAiB;oBACf,OAAO,cAAc,YAAY,IAAI,EAAE;oBACvC,eAAe,cAAc,YAAY,IAAI,EAAE;oBAC/C,WAAW,cAAc,YAAY,IAAI,EAAE;oBAC3C,YAAY,cAAc,YAAY,IAAI,EAAE;oBAC5C,MAAM;;gBAGR;YACF;QAEA,KAAK;YAAO;gBACV,MAAM,eAAe,IAAI,gBAAgB,YAAY,MAAM;gBAE3D,iBAAiB;oBACf,OAAO,2BAA2B,cAAc;oBAChD,eAAe,2BACb,cACA;oBAEF,WAAW,qCACT,cACA;oBAEF,YAAY,qCACV,cACA;oBAEF,MAAM;;gBAGR;YACF;QACA;YACE,MAAM,IAAI,2KAAA,CAAA,kBAAe,CACvB,kDACA;gBACE,YAAY;oBACV,MAAM;wBACJ,QAAQ;wBACR,SAAS,IAAI,yKAAA,CAAA,YAAS,CAAC;4BAAC;gCAAC;gCAAS;6BAAY;yBAAC;;;;IAK3D;IAEA,MAAM,kBAAkB,MAAM,CAAA,GAAA,mKAAA,CAAA,2BAAwB,AAAxB,EAC5B;QACE;QACA;QACA;QACA;QACA;OAEF;QAAE;IAAY;IAGhB,IAAI,gBAAgB,IAAI,CAAC,IAAI,KAAK,UAAU;QAC1C,IAAI,CAAC,gBAAgB,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,iBAAiB;YAGrD,MAAM,cAAc,CAAA,GAAA,mKAAA,CAAA,2CAAwC,AAAxC,EAAyC;YAC7D,IAAI,gBAAgB,MAAM;gBACxB,MAAM,IAAI,2KAAA,CAAA,kBAAe,CACvB,CAAA,uEAAA,CAAyE,GACvE,CAAA,EAAG,mKAAA,CAAA,cAAW,CAAC,gBAAgB,CAAA,IAAA,EAAO,mKAAA,CAAA,cAAW,CAAC,iCAAiC,CAAA,CAAE,EAEvF;oBAAE,YAAY;wBAAE,MAAM;4BAAE,QAAQ;wBAAG;oBAAE;gBAAE;YAE3C;YACA,gBAAgB,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,gBAAgB;QACnD;QAEA,OAAO;YACL,GAAG,gBAAgB,IAAI;YACvB,MAAM;gBACJ,MAAM;gBACN,QAAQ,MAAM,UAAU,eAAe,CACrC,2BAA2B,gBAAgB,IAAI,CAAC,YAAY;;;IAIpE;IAQA,MAAM,eAAe,YAAY,OAAO,CAAC,GAAG,CAAC;IAC7C,IACE,CAAC,CACC,gBACA,IAAI,qIAAA,CAAA,UAAU,CAAC;QACb,SAAS;YAAE,QAAQ,YAAY,OAAO,CAAC,GAAG,CAAC;QAAS;OACnD,SAAS,CAAC;QAIX,mKAAA,CAAA,cAAW,CAAC,6BAA6B;QACzC,mKAAA,CAAA,cAAW,CAAC,4BAA4B;KACzC,MAAM,mKAAA,CAAA,cAAW,CAAC,4BAA4B,GAEjD;QAGA,MAAM,IAAI,2KAAA,CAAA,kBAAe,CACvB,wEACE,yEACA,0EACA,yDAEF;YAAE,YAAY;gBAAE,MAAM;oBAAE,QAAQ;gBAAG;YAAE;QAAE;IAE3C;IAEA,gBAAgB,IAAI,CAAC,OAAO,CAAC,GAAG,CAC9B,gBACA;IAEF,OAAO;QACL,GAAG,gBAAgB,IAAI;QACvB,MAAM;YACJ,MAAM;YACN,eAAe,mBACb,gBAAgB,IAAI,CAAC,aAAa,EAClC,gBAAgB,IAAI,CAAC,iBAAiB;;;AAI9C;AAEA,gBAAgB,mBACd,aAA4E,EAC5E,iBAAkG;IAUlG,MAAM,CAAA,gEAAA,EAAmE,KAAK,SAAS,CACrF,6CAA6C,gBAC9C,OAAA,EAAU,cAAc,OAAO,GAAG,KAAK,KAAI,IAAA,CAAM;IAElD,WAAW,MAAM,UAAU,kBAAmB;QAC5C,MAAM,CAAA,qDAAA,EAAwD,KAAK,SAAS,CAC1E,gDAAgD,SACjD,OAAA,EAAU,OAAO,OAAO,GAAG,KAAK,KAAI,IAAA,CAAM;IAC7C;AACF;AAIA,SAAS,2BACP,MAAgC;IAEhC,OAAO;QACL,QAAQ,OAAO,MAAM;QACrB,MAAM,OAAO,IAAI;QACjB,YAAY,OAAO,UAAU;;AAEjC;AACA,SAAS,6CACP,MAAqE;IAErE,OAAO;QACL,SAAS,OAAO,OAAO;QACvB,QAAQ,OAAO,MAAM;QACrB,MAAM,OAAO,IAAI;QACjB,aAAa,6BAA6B,OAAO,WAAW;QAC5D,YAAY,OAAO,UAAU;;AAEjC;AACA,SAAS,gDACP,MAAwE;IAExE,OAAO;QACL,SAAS,OAAO,OAAO;QACvB,aAAa,6BAA6B,OAAO,WAAW;QAC5D,YAAY,OAAO,UAAU;;AAEjC;AAEA,SAAS,6BACP,WAAsE;IAEtE,OAAO,aAAa,IAAI,CAAC,IAAW,CAAC;YACnC,SAAS,EAAE,OAAO;YAClB,QAAQ,EAAE,MAAM;YAChB,MAAM,EAAE,IAAI;YACZ,OAAO,EAAE,KAAK;YACd,MAAM,EAAE,IAAI;YACZ,OAAO,EAAE,KAAK;YACd,YAAY,EAAE,UAAU;SACzB;AACH;AAGM,SAAU,oBAAoB,KAA+B;IACjE,OAAO,KAAK,SAAS,CAAC,SAAS;AACjC;AAEM,SAAU,mBAAmB,MAAe;IAChD,OAAO;QACL;QACA,SAAS,IAAI,yKAAA,CAAA,YAAS;;AAE1B;AAKM,SAAU,qBACd,MAAuB,EACvB,MAAuB;IAEvB,IAAI,OAAO,MAAM,EAAE;QACjB,OAAO,MAAM,GAAG,OAAO,MAAM;IAC/B;IACA,IAAI,OAAO,OAAO,EAAE;QAClB,KAAK,MAAM,CAAC,MAAM,MAAM,IAAI,OAAO,OAAO,CAAE;YAG1C,OAAO,OAAO,CAAC,GAAG,CAAC,MAAM;QAC3B;IACF;AACF"}},
    {"offset": {"line": 4817, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4822, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@apollo/server/src/errorNormalize.ts"],"sourcesContent":["// The functions in this file are not part of Apollo Server's external API.\n\nimport {\n  GraphQLError,\n  type GraphQLErrorExtensions,\n  type GraphQLFormattedError,\n} from 'graphql';\nimport { ApolloServerErrorCode } from './errors/index.js';\nimport type { HTTPGraphQLHead } from './externalTypes/http.js';\nimport { mergeHTTPGraphQLHead, newHTTPGraphQLHead } from './runHttpQuery.js';\nimport { HeaderMap } from './utils/HeaderMap.js';\n\n// This function accepts any value that were thrown and convert it to GraphQLFormattedError.\n// It also add default extensions.code and copy stack trace onto an extension if requested.\n// Additionally, it returns an `HTTPGraphQLHead` created from combining the values of any\n// `HTTPGraphqlHead` objects found on `extensions.http` (the behavior when multiple errors\n// set a status code or set the same header should be treated as undefined); these extensions\n// are removed from the formatted error.\n//\n// This function should not throw.\nexport function normalizeAndFormatErrors(\n  errors: ReadonlyArray<unknown>,\n  options: {\n    formatError?: (\n      formattedError: GraphQLFormattedError,\n      error: unknown,\n    ) => GraphQLFormattedError;\n    includeStacktraceInErrorResponses?: boolean;\n  } = {},\n): {\n  formattedErrors: Array<GraphQLFormattedError>;\n  httpFromErrors: HTTPGraphQLHead;\n} {\n  const formatError = options.formatError ?? ((error) => error);\n  const httpFromErrors = newHTTPGraphQLHead();\n\n  return {\n    httpFromErrors,\n    formattedErrors: errors.map((error) => {\n      try {\n        return formatError(enrichError(error), error);\n      } catch (formattingError) {\n        if (options.includeStacktraceInErrorResponses) {\n          // includeStacktraceInErrorResponses is used in development\n          // so it will be helpful to show errors thrown by formatError hooks in that mode\n          return enrichError(formattingError);\n        } else {\n          // obscure error\n          return {\n            message: 'Internal server error',\n            extensions: { code: ApolloServerErrorCode.INTERNAL_SERVER_ERROR },\n          };\n        }\n      }\n    }),\n  };\n\n  function enrichError(maybeError: unknown): GraphQLFormattedError {\n    const graphqlError = ensureGraphQLError(maybeError);\n\n    const extensions: GraphQLErrorExtensions = {\n      ...graphqlError.extensions,\n      code:\n        graphqlError.extensions.code ??\n        ApolloServerErrorCode.INTERNAL_SERVER_ERROR,\n    };\n\n    if (isPartialHTTPGraphQLHead(extensions.http)) {\n      mergeHTTPGraphQLHead(httpFromErrors, {\n        headers: new HeaderMap(),\n        ...extensions.http,\n      });\n      delete extensions.http;\n    }\n\n    if (options.includeStacktraceInErrorResponses) {\n      // Note that if ensureGraphQLError created graphqlError from an\n      // originalError, graphqlError.stack will be the same as\n      // originalError.stack due to some special code in the GraphQLError\n      // constructor.\n      extensions.stacktrace = graphqlError.stack?.split('\\n');\n    }\n\n    return { ...graphqlError.toJSON(), extensions };\n  }\n}\n\nexport function ensureError(maybeError: unknown): Error {\n  return maybeError instanceof Error\n    ? maybeError\n    : new GraphQLError('Unexpected error value: ' + String(maybeError));\n}\n\nexport function ensureGraphQLError(\n  maybeError: unknown,\n  messagePrefixIfNotGraphQLError: string = '',\n): GraphQLError {\n  const error: Error = ensureError(maybeError);\n\n  return error instanceof GraphQLError\n    ? error\n    : new GraphQLError(messagePrefixIfNotGraphQLError + error.message, {\n        originalError: error,\n      });\n}\n\nfunction isPartialHTTPGraphQLHead(x: unknown): x is Partial<HTTPGraphQLHead> {\n  return (\n    !!x &&\n    typeof x === 'object' &&\n    (!('status' in x) || typeof (x as any).status === 'number') &&\n    (!('headers' in x) || (x as any).headers instanceof Map)\n  );\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;AAoBM,SAAU,yBACd,MAA8B,EAC9B,UAMI,CAAA,CAAE;IAKN,MAAM,cAAc,QAAQ,WAAW,IAAI,CAAC,CAAC,QAAU,KAAK;IAC5D,MAAM,iBAAiB,CAAA,GAAA,mKAAA,CAAA,qBAAkB,AAAlB;IAEvB,OAAO;QACL;QACA,iBAAiB,OAAO,GAAG,CAAC,CAAC;YAC3B,IAAI;gBACF,OAAO,YAAY,YAAY,QAAQ;YACzC,EAAE,OAAO,iBAAiB;gBACxB,IAAI,QAAQ,iCAAiC,EAAE;oBAG7C,OAAO,YAAY;gBACrB,OAAO;oBAEL,OAAO;wBACL,SAAS;wBACT,YAAY;4BAAE,MAAM,sKAAA,CAAA,wBAAqB,CAAC,qBAAqB;wBAAA;;gBAEnE;YACF;QACF;;IAGF,SAAS,YAAY,UAAmB;QACtC,MAAM,eAAe,mBAAmB;QAExC,MAAM,aAAqC;YACzC,GAAG,aAAa,UAAU;YAC1B,MACE,aAAa,UAAU,CAAC,IAAI,IAC5B,sKAAA,CAAA,wBAAqB,CAAC,qBAAqB;;QAG/C,IAAI,yBAAyB,WAAW,IAAI,GAAG;YAC7C,CAAA,GAAA,mKAAA,CAAA,uBAAoB,AAApB,EAAqB,gBAAgB;gBACnC,SAAS,IAAI,yKAAA,CAAA,YAAS;gBACtB,GAAG,WAAW,IAAI;;YAEpB,OAAO,WAAW,IAAI;QACxB;QAEA,IAAI,QAAQ,iCAAiC,EAAE;YAK7C,WAAW,UAAU,GAAG,aAAa,KAAK,EAAE,MAAM;QACpD;QAEA,OAAO;YAAE,GAAG,aAAa,MAAM,EAAE;YAAE;QAAU;IAC/C;AACF;AAEM,SAAU,YAAY,UAAmB;IAC7C,OAAO,sBAAsB,QACzB,aACA,IAAI,mJAAA,CAAA,eAAY,CAAC,6BAA6B,OAAO;AAC3D;AAEM,SAAU,mBACd,UAAmB,EACnB,iCAAyC,EAAE;IAE3C,MAAM,QAAe,YAAY;IAEjC,OAAO,iBAAiB,mJAAA,CAAA,eAAY,GAChC,QACA,IAAI,mJAAA,CAAA,eAAY,CAAC,iCAAiC,MAAM,OAAO,EAAE;QAC/D,eAAe;;AAEvB;AAEA,SAAS,yBAAyB,CAAU;IAC1C,OACE,CAAC,CAAC,KACF,OAAO,MAAM,YACb,CAAC,CAAC,CAAC,YAAY,CAAC,KAAK,OAAQ,EAAU,MAAM,KAAK,QAAQ,KAC1D,CAAC,CAAC,CAAC,aAAa,CAAC,KAAM,EAAU,OAAO,YAAY,GAAG;AAE3D"}},
    {"offset": {"line": 4892, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4897, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@apollo/server/src/httpBatching.ts"],"sourcesContent":["import type {\n  BaseContext,\n  HTTPGraphQLRequest,\n  HTTPGraphQLResponse,\n} from './externalTypes/index.js';\nimport type {\n  ApolloServer,\n  ApolloServerInternals,\n  SchemaDerivedData,\n} from './ApolloServer';\nimport { newHTTPGraphQLHead, runHttpQuery } from './runHttpQuery.js';\nimport { BadRequestError } from './internalErrorClasses.js';\n\nasync function runBatchedHttpQuery<TContext extends BaseContext>({\n  server,\n  batchRequest,\n  body,\n  contextValue,\n  schemaDerivedData,\n  internals,\n}: {\n  server: ApolloServer<TContext>;\n  batchRequest: HTTPGraphQLRequest;\n  body: unknown[];\n  contextValue: TContext;\n  schemaDerivedData: SchemaDerivedData;\n  internals: ApolloServerInternals<TContext>;\n}): Promise<HTTPGraphQLResponse> {\n  if (body.length === 0) {\n    throw new BadRequestError('No operations found in request.');\n  }\n\n  // This single HTTPGraphQLHead is shared across all the operations in the\n  // batch. This means that any changes to response headers or status code from\n  // one operation can be immediately seen by other operations. Plugins that set\n  // response headers or status code can then choose to combine the data they\n  // are setting with data that may already be there from another operation as\n  // they choose.\n  const sharedResponseHTTPGraphQLHead = newHTTPGraphQLHead();\n  const responseBodies = await Promise.all(\n    body.map(async (bodyPiece: unknown) => {\n      const singleRequest: HTTPGraphQLRequest = {\n        ...batchRequest,\n        body: bodyPiece,\n      };\n\n      const response = await runHttpQuery({\n        server,\n        httpRequest: singleRequest,\n        contextValue,\n        schemaDerivedData,\n        internals,\n        sharedResponseHTTPGraphQLHead,\n      });\n\n      if (response.body.kind === 'chunked') {\n        throw Error(\n          'Incremental delivery is not implemented for batch requests',\n        );\n      }\n      return response.body.string;\n    }),\n  );\n  return {\n    ...sharedResponseHTTPGraphQLHead,\n    body: { kind: 'complete', string: `[${responseBodies.join(',')}]` },\n  };\n}\n\nexport async function runPotentiallyBatchedHttpQuery<\n  TContext extends BaseContext,\n>(\n  server: ApolloServer<TContext>,\n  httpGraphQLRequest: HTTPGraphQLRequest,\n  contextValue: TContext,\n  schemaDerivedData: SchemaDerivedData,\n  internals: ApolloServerInternals<TContext>,\n): Promise<HTTPGraphQLResponse> {\n  if (\n    !(\n      httpGraphQLRequest.method === 'POST' &&\n      Array.isArray(httpGraphQLRequest.body)\n    )\n  ) {\n    return await runHttpQuery({\n      server,\n      httpRequest: httpGraphQLRequest,\n      contextValue,\n      schemaDerivedData,\n      internals,\n      sharedResponseHTTPGraphQLHead: null,\n    });\n  }\n  if (internals.allowBatchedHttpRequests) {\n    return await runBatchedHttpQuery({\n      server,\n      batchRequest: httpGraphQLRequest,\n      body: httpGraphQLRequest.body as unknown[],\n      contextValue,\n      schemaDerivedData,\n      internals,\n    });\n  }\n  throw new BadRequestError('Operation batching disabled.');\n}\n"],"names":[],"mappings":";;;;;;;;AAaA,eAAe,oBAAkD,EAC/D,MAAM,EACN,YAAY,EACZ,IAAI,EACJ,YAAY,EACZ,iBAAiB,EACjB,SAAS,EAQV;IACC,IAAI,KAAK,MAAM,KAAK,GAAG;QACrB,MAAM,IAAI,2KAAA,CAAA,kBAAe,CAAC;IAC5B;IAQA,MAAM,gCAAgC,CAAA,GAAA,mKAAA,CAAA,qBAAkB,AAAlB;IACtC,MAAM,iBAAiB,MAAM,QAAQ,GAAG,CACtC,KAAK,GAAG,CAAC,OAAO;QACd,MAAM,gBAAoC;YACxC,GAAG,YAAY;YACf,MAAM;;QAGR,MAAM,WAAW,MAAM,CAAA,GAAA,mKAAA,CAAA,eAAY,AAAZ,EAAa;YAClC;YACA,aAAa;YACb;YACA;YACA;YACA;;QAGF,IAAI,SAAS,IAAI,CAAC,IAAI,KAAK,WAAW;YACpC,MAAM,MACJ;QAEJ;QACA,OAAO,SAAS,IAAI,CAAC,MAAM;IAC7B;IAEF,OAAO;QACL,GAAG,6BAA6B;QAChC,MAAM;YAAE,MAAM;YAAY,QAAQ,CAAA,CAAA,EAAI,eAAe,IAAI,CAAC,KAAI,CAAA,CAAG;QAAA;;AAErE;AAEO,eAAe,+BAGpB,MAA8B,EAC9B,kBAAsC,EACtC,YAAsB,EACtB,iBAAoC,EACpC,SAA0C;IAE1C,IACE,CAAC,CACC,mBAAmB,MAAM,KAAK,UAC9B,MAAM,OAAO,CAAC,mBAAmB,IAAI,CAAC,GAExC;QACA,OAAO,MAAM,CAAA,GAAA,mKAAA,CAAA,eAAY,AAAZ,EAAa;YACxB;YACA,aAAa;YACb;YACA;YACA;YACA,+BAA+B;;IAEnC;IACA,IAAI,UAAU,wBAAwB,EAAE;QACtC,OAAO,MAAM,oBAAoB;YAC/B;YACA,cAAc;YACd,MAAM,mBAAmB,IAAiB;YAC1C;YACA;YACA;;IAEJ;IACA,MAAM,IAAI,2KAAA,CAAA,kBAAe,CAAC;AAC5B"}},
    {"offset": {"line": 4959, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4964, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@apollo/server/src/internalPlugin.ts"],"sourcesContent":["import type { BaseContext, ApolloServerPlugin } from './externalTypes/index.js';\n\n// This file's exports should not be exported from the overall\n// @apollo/server module.\n\n// The internal plugins implement this interface which\n// ApolloServer.ensurePluginInstantiation uses to figure out if the plugins have\n// already been installed (or explicitly disabled via the matching Disable\n// plugins).\nexport interface InternalApolloServerPlugin<TContext extends BaseContext>\n  extends ApolloServerPlugin<TContext> {\n  // Used to identify a few specific plugins that are instantiated\n  // by default if not explicitly used or disabled.\n  __internal_plugin_id__: InternalPluginId;\n  __is_disabled_plugin__: boolean;\n}\n\n// Helper function for writing internal plugins which lets you write an object\n// that is type-checked as InternalApolloServerPlugin but is still only of type\n// ApolloServerPlugin (as appropriate for externally-exported plugin-returning\n// functions).\nexport function internalPlugin<TContext extends BaseContext>(\n  p: InternalApolloServerPlugin<TContext>,\n): ApolloServerPlugin<TContext> {\n  return p;\n}\n\nexport type InternalPluginId =\n  | 'CacheControl'\n  | 'LandingPageDisabled'\n  | 'SchemaReporting'\n  | 'InlineTrace'\n  | 'UsageReporting';\n\nexport function pluginIsInternal<TContext extends BaseContext>(\n  plugin: ApolloServerPlugin<TContext>,\n): plugin is InternalApolloServerPlugin<TContext> {\n  // We could call the function and compare it to the list above, but this seems\n  // good enough.\n  return '__internal_plugin_id__' in plugin;\n}\n"],"names":[],"mappings":";;;;AAqBM,SAAU,eACd,CAAuC;IAEvC,OAAO;AACT;AASM,SAAU,iBACd,MAAoC;IAIpC,OAAO,4BAA4B;AACrC"}},
    {"offset": {"line": 4974, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4979, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@apollo/server/src/preventCsrf.ts"],"sourcesContent":["import MIMEType from 'whatwg-mimetype';\nimport { BadRequestError } from './internalErrorClasses.js';\nimport type { HeaderMap } from './utils/HeaderMap.js';\n\n// Our recommended set of CSRF prevention headers. Operations that do not\n// provide a content-type such as `application/json` (in practice, this\n// means GET operations) must include at least one of these headers.\n// Apollo Client Web's default behavior is to always sends a\n// `content-type` even for `GET`, and Apollo iOS and Apollo Kotlin always\n// send `x-apollo-operation-name`. So if you set\n// `csrfPreventionRequestHeaders: true` then any `GET` operation from these\n// three client projects and any `POST` operation at all should work\n// successfully; if you need `GET`s from another kind of client to work,\n// just add `apollo-require-preflight: true` to their requests.\nexport const recommendedCsrfPreventionRequestHeaders = [\n  'x-apollo-operation-name',\n  'apollo-require-preflight',\n];\n\n// See https://fetch.spec.whatwg.org/#cors-safelisted-request-header\nconst NON_PREFLIGHTED_CONTENT_TYPES = [\n  'application/x-www-form-urlencoded',\n  'multipart/form-data',\n  'text/plain',\n];\n\n// We don't want random websites to be able to execute actual GraphQL operations\n// from a user's browser unless our CORS policy supports it. It's not good\n// enough just to ensure that the browser can't read the response from the\n// operation; we also want to prevent CSRF, where the attacker can cause side\n// effects with an operation or can measure the timing of a read operation. Our\n// goal is to ensure that we don't run the context function or execute the\n// GraphQL operation until the browser has evaluated the CORS policy, which\n// means we want all operations to be pre-flighted. We can do that by only\n// processing operations that have at least one header set that appears to be\n// manually set by the JS code rather than by the browser automatically.\n//\n// POST requests generally have a content-type `application/json`, which is\n// sufficient to trigger preflighting. So we take extra care with requests that\n// specify no content-type or that specify one of the three non-preflighted\n// content types. For those operations, we require (if this feature is enabled)\n// one of a set of specific headers to be set. By ensuring that every operation\n// either has a custom content-type or sets one of these headers, we know we\n// won't execute operations at the request of origins who our CORS policy will\n// block.\nexport function preventCsrf(\n  headers: HeaderMap,\n  csrfPreventionRequestHeaders: string[],\n) {\n  const contentType = headers.get('content-type');\n\n  // We have to worry about CSRF if it looks like this may have been a\n  // non-preflighted request. If we see a content-type header that is not one of\n  // the three CORS-safelisted MIME types (see\n  // https://fetch.spec.whatwg.org/#cors-safelisted-request-header) then we know\n  // it was preflighted and we don't have to worry.\n  if (contentType !== undefined) {\n    const contentTypeParsed = MIMEType.parse(contentType);\n    if (contentTypeParsed === null) {\n      // If we got null, then parsing the content-type failed... which is\n      // actually *ok* because that would lead to a preflight. (For example, the\n      // header is empty, or doesn't have a slash, or has bad characters.) The\n      // scary CSRF case is only if there's *not* an error. So it is actually\n      // fine for us to just `return` here. (That said, it would also be\n      // reasonable to reject such requests with provided yet unparsable\n      // Content-Type here.)\n      return;\n    }\n    if (!NON_PREFLIGHTED_CONTENT_TYPES.includes(contentTypeParsed.essence)) {\n      // We managed to parse a MIME type that was not one of the\n      // CORS-safelisted ones. (Probably application/json!) That means that if\n      // the client is a browser, the browser must have applied CORS\n      // preflighting and we don't have to worry about CSRF.\n      return;\n    }\n  }\n\n  // Either there was no content-type, or the content-type parsed properly as\n  // one of the three CORS-safelisted values. Let's look for another header that\n  // (if this was a browser) must have been set by the user's code and would\n  // have caused a preflight.\n  if (\n    csrfPreventionRequestHeaders.some((header) => {\n      const value = headers.get(header);\n      return value !== undefined && value.length > 0;\n    })\n  ) {\n    return;\n  }\n\n  throw new BadRequestError(\n    `This operation has been blocked as a potential Cross-Site Request Forgery ` +\n      `(CSRF). Please either specify a 'content-type' header (with a type that ` +\n      `is not one of ${NON_PREFLIGHTED_CONTENT_TYPES.join(', ')}) or provide ` +\n      `a non-empty value for one of the following headers: ${csrfPreventionRequestHeaders.join(\n        ', ',\n      )}\\n`,\n  );\n}\n"],"names":[],"mappings":";;;;;;;;;AAcO,MAAM,0CAA0C;IACrD;IACA;CACD;AAGD,MAAM,gCAAgC;IACpC;IACA;IACA;CACD;AAqBK,SAAU,YACd,OAAkB,EAClB,4BAAsC;IAEtC,MAAM,cAAc,QAAQ,GAAG,CAAC;IAOhC,IAAI,gBAAgB,WAAW;QAC7B,MAAM,oBAAoB,2JAAA,CAAA,UAAQ,CAAC,KAAK,CAAC;QACzC,IAAI,sBAAsB,MAAM;YAQ9B;QACF;QACA,IAAI,CAAC,8BAA8B,QAAQ,CAAC,kBAAkB,OAAO,GAAG;YAKtE;QACF;IACF;IAMA,IACE,6BAA6B,IAAI,CAAC,CAAC;QACjC,MAAM,QAAQ,QAAQ,GAAG,CAAC;QAC1B,OAAO,UAAU,aAAa,MAAM,MAAM,GAAG;IAC/C,IACA;QACA;IACF;IAEA,MAAM,IAAI,2KAAA,CAAA,kBAAe,CACvB,CAAA,0EAAA,CAA4E,GAC1E,CAAA,wEAAA,CAA0E,GAC1E,CAAA,cAAA,EAAiB,8BAA8B,IAAI,CAAC,MAAK,aAAA,CAAe,GACxE,CAAA,oDAAA,EAAuD,6BAA6B,IAAI,CACtF,MACD,EAAA,CAAI;AAEX"}},
    {"offset": {"line": 5016, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5021, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@apollo/server/src/utils/schemaInstrumentation.ts"],"sourcesContent":["import {\n  type GraphQLSchema,\n  type GraphQLField,\n  getNamedType,\n  GraphQLObjectType,\n  type GraphQLFieldResolver,\n  defaultFieldResolver,\n} from 'graphql';\nimport type {\n  BaseContext,\n  GraphQLRequestExecutionListener,\n} from '../externalTypes/index.js';\n\nexport const symbolExecutionDispatcherWillResolveField = Symbol(\n  'apolloServerExecutionDispatcherWillResolveField',\n);\nexport const symbolUserFieldResolver = Symbol('apolloServerUserFieldResolver');\nconst symbolPluginsEnabled = Symbol('apolloServerPluginsEnabled');\n\nexport function enablePluginsForSchemaResolvers<TContext extends BaseContext>(\n  schema: GraphQLSchema & { [symbolPluginsEnabled]?: boolean },\n) {\n  if (pluginsEnabledForSchemaResolvers(schema)) {\n    return schema;\n  }\n  Object.defineProperty(schema, symbolPluginsEnabled, {\n    value: true,\n  });\n\n  const typeMap = schema.getTypeMap();\n  Object.values(typeMap).forEach((type) => {\n    if (\n      !getNamedType(type).name.startsWith('__') &&\n      type instanceof GraphQLObjectType\n    ) {\n      const fields = type.getFields();\n      Object.values(fields).forEach((field) => {\n        wrapField<TContext>(field);\n      });\n    }\n  });\n\n  return schema;\n}\n\nexport function pluginsEnabledForSchemaResolvers(\n  schema: GraphQLSchema & { [symbolPluginsEnabled]?: boolean },\n): boolean {\n  return !!schema[symbolPluginsEnabled];\n}\n\nfunction wrapField<TContext extends BaseContext>(\n  field: GraphQLField<any, any>,\n): void {\n  const originalFieldResolve = field.resolve;\n\n  field.resolve = (source, args, contextValue, info) => {\n    const willResolveField = contextValue?.[\n      symbolExecutionDispatcherWillResolveField\n    ] as\n      | GraphQLRequestExecutionListener<TContext>['willResolveField']\n      | undefined;\n\n    const userFieldResolver = contextValue?.[symbolUserFieldResolver] as\n      | GraphQLFieldResolver<any, any>\n      | undefined;\n\n    // The technique for implementing a  \"did resolve field\" is accomplished by\n    // returning a function from the `willResolveField` handler.  While there\n    // may be several callbacks, depending on the number of plugins which have\n    // implemented a `willResolveField` hook, this hook will call them all\n    // as dictated by the dispatcher.  We will call this when object\n    // resolution is complete.\n    const didResolveField =\n      typeof willResolveField === 'function' &&\n      willResolveField({ source, args, contextValue, info });\n\n    const fieldResolver =\n      originalFieldResolve || userFieldResolver || defaultFieldResolver;\n\n    try {\n      const result = fieldResolver(source, args, contextValue, info);\n\n      // Call the stack's handlers either immediately (if result is not a\n      // Promise) or once the Promise is done. Then return that same\n      // maybe-Promise value.\n      if (typeof didResolveField === 'function') {\n        whenResultIsFinished(result, didResolveField);\n      }\n      return result;\n    } catch (error) {\n      // Normally it's a bad sign to see an error both handled and\n      // re-thrown. But it is useful to allow extensions to track errors while\n      // still handling them in the normal GraphQL way.\n      if (typeof didResolveField === 'function') {\n        didResolveField(error as Error);\n      }\n      throw error;\n    }\n  };\n}\n\nfunction isPromise(x: any): boolean {\n  return x && typeof x.then === 'function';\n}\n\n// Given result (which may be a Promise or an array some of whose elements are\n// promises) Promises, set up 'callback' to be invoked when result is fully\n// resolved. (Unfortunately, this does not perfectly handle every possible\n// return value shape, such as arrays of arrays of Promises.)\nexport function whenResultIsFinished(\n  result: any,\n  callback: (err: Error | null, result?: any) => void,\n) {\n  if (isPromise(result)) {\n    result.then(\n      (r: any) => whenResultIsFinished(r, callback),\n      (err: Error) => callback(err),\n    );\n  } else if (Array.isArray(result)) {\n    if (result.some(isPromise)) {\n      Promise.all(result).then(\n        (r: any) => callback(null, r),\n        (err: Error) => callback(err),\n      );\n    } else {\n      callback(null, result);\n    }\n  } else {\n    callback(null, result);\n  }\n}\n"],"names":[],"mappings":";;;;;;;;;;;AAaO,MAAM,4CAA4C,OACvD;AAEK,MAAM,0BAA0B,OAAO;AAC9C,MAAM,uBAAuB,OAAO;AAE9B,SAAU,gCACd,MAA4D;IAE5D,IAAI,iCAAiC,SAAS;QAC5C,OAAO;IACT;IACA,OAAO,cAAc,CAAC,QAAQ,sBAAsB;QAClD,OAAO;;IAGT,MAAM,UAAU,OAAO,UAAU;IACjC,OAAO,MAAM,CAAC,SAAS,OAAO,CAAC,CAAC;QAC9B,IACE,CAAC,CAAA,GAAA,gJAAA,CAAA,eAAY,AAAZ,EAAa,MAAM,IAAI,CAAC,UAAU,CAAC,SACpC,gBAAgB,gJAAA,CAAA,oBAAiB,EACjC;YACA,MAAM,SAAS,KAAK,SAAS;YAC7B,OAAO,MAAM,CAAC,QAAQ,OAAO,CAAC,CAAC;gBAC7B,UAAoB;YACtB;QACF;IACF;IAEA,OAAO;AACT;AAEM,SAAU,iCACd,MAA4D;IAE5D,OAAO,CAAC,CAAC,MAAM,CAAC,qBAAqB;AACvC;AAEA,SAAS,UACP,KAA6B;IAE7B,MAAM,uBAAuB,MAAM,OAAO;IAE1C,MAAM,OAAO,GAAG,CAAC,QAAQ,MAAM,cAAc;QAC3C,MAAM,mBAAmB,cAAc,CACrC,0CAGW;QAEb,MAAM,oBAAoB,cAAc,CAAC,wBAE5B;QAQb,MAAM,kBACJ,OAAO,qBAAqB,cAC5B,iBAAiB;YAAE;YAAQ;YAAM;YAAc;QAAI;QAErD,MAAM,gBACJ,wBAAwB,qBAAqB,kJAAA,CAAA,uBAAoB;QAEnE,IAAI;YACF,MAAM,SAAS,cAAc,QAAQ,MAAM,cAAc;YAKzD,IAAI,OAAO,oBAAoB,YAAY;gBACzC,qBAAqB,QAAQ;YAC/B;YACA,OAAO;QACT,EAAE,OAAO,OAAO;YAId,IAAI,OAAO,oBAAoB,YAAY;gBACzC,gBAAgB;YAClB;YACA,MAAM;QACR;IACF;AACF;AAEA,SAAS,UAAU,CAAM;IACvB,OAAO,KAAK,OAAO,EAAE,IAAI,KAAK;AAChC;AAMM,SAAU,qBACd,MAAW,EACX,QAAmD;IAEnD,IAAI,UAAU,SAAS;QACrB,OAAO,IAAI,CACT,CAAC,IAAW,qBAAqB,GAAG,WACpC,CAAC,MAAe,SAAS;IAE7B,OAAO,IAAI,MAAM,OAAO,CAAC,SAAS;QAChC,IAAI,OAAO,IAAI,CAAC,YAAY;YAC1B,QAAQ,GAAG,CAAC,QAAQ,IAAI,CACtB,CAAC,IAAW,SAAS,MAAM,IAC3B,CAAC,MAAe,SAAS;QAE7B,OAAO;YACL,SAAS,MAAM;QACjB;IACF,OAAO;QACL,SAAS,MAAM;IACjB;AACF"}},
    {"offset": {"line": 5098, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5103, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@apollo/server/src/utils/isDefined.ts"],"sourcesContent":["export function isDefined<T>(t: T | undefined | null | void): t is T {\n  return t != null;\n}\n"],"names":[],"mappings":";;;AAAM,SAAU,UAAa,CAA8B;IACzD,OAAO,KAAK;AACd"}},
    {"offset": {"line": 5109, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5114, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@apollo/server/src/utils/invokeHooks.ts"],"sourcesContent":["import { isDefined } from './isDefined.js';\n\ntype AsyncDidEndHook<TArgs extends any[]> = (...args: TArgs) => Promise<void>;\ntype SyncDidEndHook<TArgs extends any[]> = (...args: TArgs) => void;\n\nexport async function invokeDidStartHook<T, TEndHookArgs extends unknown[]>(\n  targets: T[],\n  hook: (t: T) => Promise<AsyncDidEndHook<TEndHookArgs> | undefined | void>,\n): Promise<AsyncDidEndHook<TEndHookArgs>> {\n  const didEndHooks = (\n    await Promise.all(targets.map((target) => hook(target)))\n  ).filter(isDefined);\n\n  didEndHooks.reverse();\n\n  return async (...args: TEndHookArgs) => {\n    for (const didEndHook of didEndHooks) {\n      didEndHook(...args);\n    }\n  };\n}\n\n// Almost all hooks are async, but as a special case, willResolveField is sync\n// due to performance concerns.\nexport function invokeSyncDidStartHook<T, TEndHookArgs extends unknown[]>(\n  targets: T[],\n  hook: (t: T) => SyncDidEndHook<TEndHookArgs> | undefined | void,\n): SyncDidEndHook<TEndHookArgs> {\n  const didEndHooks: SyncDidEndHook<TEndHookArgs>[] = targets\n    .map((target) => hook(target))\n    .filter(isDefined);\n\n  didEndHooks.reverse();\n\n  return (...args: TEndHookArgs) => {\n    for (const didEndHook of didEndHooks) {\n      didEndHook(...args);\n    }\n  };\n}\n\nexport async function invokeHooksUntilDefinedAndNonNull<T, TOut>(\n  targets: T[],\n  hook: (t: T) => Promise<TOut | null | undefined>,\n): Promise<TOut | null> {\n  for (const target of targets) {\n    const value = await hook(target);\n    if (value != null) {\n      return value;\n    }\n  }\n  return null;\n}\n"],"names":[],"mappings":";;;;;;;;AAKO,eAAe,mBACpB,OAAY,EACZ,IAAyE;IAEzE,MAAM,cAAc,CAClB,MAAM,QAAQ,GAAG,CAAC,QAAQ,GAAG,CAAC,CAAC,SAAW,KAAK,SAAS,EACxD,MAAM,CAAC,yKAAA,CAAA,YAAS;IAElB,YAAY,OAAO;IAEnB,OAAO,OAAO,GAAG;QACf,KAAK,MAAM,cAAc,YAAa;YACpC,cAAc;QAChB;IACF;AACF;AAIM,SAAU,uBACd,OAAY,EACZ,IAA+D;IAE/D,MAAM,cAA8C,QACjD,GAAG,CAAC,CAAC,SAAW,KAAK,SACrB,MAAM,CAAC,yKAAA,CAAA,YAAS;IAEnB,YAAY,OAAO;IAEnB,OAAO,CAAC,GAAG;QACT,KAAK,MAAM,cAAc,YAAa;YACpC,cAAc;QAChB;IACF;AACF;AAEO,eAAe,kCACpB,OAAY,EACZ,IAAgD;IAEhD,KAAK,MAAM,UAAU,QAAS;QAC5B,MAAM,QAAQ,MAAM,KAAK;QACzB,IAAI,SAAS,MAAM;YACjB,OAAO;QACT;IACF;IACA,OAAO;AACT"}},
    {"offset": {"line": 5149, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5154, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@apollo/server/src/utils/makeGatewayGraphQLRequestContext.ts"],"sourcesContent":["import type {\n  GatewayGraphQLRequest,\n  GatewayGraphQLRequestContext,\n  GatewayGraphQLResponse,\n  GatewaySchemaHash,\n} from '@apollo/server-gateway-interface';\nimport type { FetcherHeaders } from '@apollo/utils.fetcher';\nimport type { ApolloServer, ApolloServerInternals } from '../ApolloServer';\nimport type {\n  BaseContext,\n  GraphQLRequestContextExecutionDidStart,\n} from '../externalTypes';\nimport type { HeaderMap } from './HeaderMap';\n\n// Apollo Gateway's API included `GraphQLRequestContext` from AS2/AS3.\n// Specifically, a request context is passed to the main executor method, which\n// it then exposes to user-configurable `GraphQLDataSource`s.\n// `GraphQLRequestContext` has changed in incompatible ways in AS4; for example,\n// we represent HTTP messages using our own data structures rather than Fetches,\n// and some fields have been removed because they relate to features that don't\n// exist any more.\n//\n// In general, the future of Apollo's development is in Apollo Router, not\n// Gateway. So rather than have a big transition where a new version of Gateway\n// supports AS4's GraphQLRequestContext instead of AS3's, we simply teach AS4\n// how to produce AS3-style GraphQLRequestContext objects specifically for use\n// by Gateway. We have changed Gateway to get its TS type definitions from a new\n// package rather than from AS3 itself, so that Gateway no longer needs to\n// depend on Apollo Server.\n//\n// This function turn an AS4 GraphQLRequestContext into a\n// GatewayGraphQLRequestContext (which is basically an AS3\n// GraphQLRequestContext).\n//\n// You might think that *after* invoking the executor, we would then need to\n// propagate any changes made by the gateway back onto the \"real\"\n// GraphQLRequestContext. It turns out that for each bit of data on the request\n// context, this is either unnecessary or impossible. (We don't need to support\n// use cases where people break type safe, eg by changing the values of readonly\n// fields.) Here's why:\n//\n// Many fields on GatewayGraphQLRequestContext are declared readonly and their\n// values are taken directly from the real GraphQLRequestContext. This means\n// that gateways should not change the field's value, and any mutations of the\n// object stored in the field (say, calling\n// `requestContext.overallCachePolicy.restrict`, as RemoteGraphQLDataSource\n// does) already take effect.\n//\n//  The only two fields not declared as readonly are `logger` and `debug`.\n//\n// Technically, a gateway implementation could set `requestContext.logger` to a\n// different Logger without breaking the TypeScript declarations. In AS4 we\n// don't actually have a requestContext.logger; we have `readonly\n// requestContext.server` and `readonly server.logger`. So there's not an easy\n// way for us to carry out this change: AS4 just doesn't let gateway or plugins\n// override the server's logger (and generally doesn't allow the logger to\n// change after the server is created), which seems like a simpler model. If it\n// turns out there is a real use case for the gateway to be able to change the\n// overall logger for the request as seen by plugins, we can fix that later.\n//\n// Similarly, it's not clear what the intended use case of mutating `debug` in\n// gateway would be. `debug` has now mostly changed into\n// `includeStacktraceInErrorResponses`. So perhaps this could be used to let you\n// decide whether or not to include the stacktrace on a per-operation basis...\n// but you can also use `formatError` or `didEncounterErrors` for this perhaps?\n// In any case, AS4 doesn't track `includeStacktraceInErrorResponses` on a\n// per-operation basis; if we find a use case for this we can add it later.\n//\n// So we'll just ignore changes to `logger` and `debug`.\n//\n// Next, there's `request`. We don't know of a use case for mutating the\n// *request* at execution time. If there was a real use case, we could add a\n// function that copies pieces back from the gateway `request` to the AS4\n// request, but we're not bothering to yet.\n//\n// Finally, there's `response`. Sure, the executor *could* mutate `response`.\n// But the main thing the executor is doing is *returning* a response, which\n// then semi-overwrites `requestContext.response` anyway. So it doesn't seem\n// like we need to support `executor` *also* overwriting response. Yet again, we\n// can fix this if it turns out it's necessary. (That said, the executor could\n// in theory write HTTP response headers or status, so we make sure to hook them\n// up directly to the appropriate data in the real GraphQLRequestContext.)\n//\n// So all in all, it looks like it's OK for this to be a \"one-way\" conversion.\nexport function makeGatewayGraphQLRequestContext<TContext extends BaseContext>(\n  as4RequestContext: GraphQLRequestContextExecutionDidStart<TContext>,\n  server: ApolloServer<TContext>,\n  internals: ApolloServerInternals<TContext>,\n): GatewayGraphQLRequestContext {\n  const request: GatewayGraphQLRequest = {};\n  if ('query' in as4RequestContext.request) {\n    request.query = as4RequestContext.request.query;\n  }\n  if ('operationName' in as4RequestContext.request) {\n    request.operationName = as4RequestContext.request.operationName;\n  }\n  if ('variables' in as4RequestContext.request) {\n    request.variables = as4RequestContext.request.variables;\n  }\n  if ('extensions' in as4RequestContext.request) {\n    request.extensions = as4RequestContext.request.extensions;\n  }\n  if (as4RequestContext.request.http) {\n    const as4http = as4RequestContext.request.http;\n    const needQuestion =\n      as4http.search !== '' && !as4http.search.startsWith('?');\n    request.http = {\n      method: as4http.method,\n      // As of AS4, we no longer attempt to track complete URLs (just the search\n      // parameters used in GET requests). So we have to fake them for Gateway.\n      url: `https://unknown-url.invalid/${needQuestion ? '?' : ''}${\n        as4http.search\n      }`,\n      headers: new FetcherHeadersForHeaderMap(as4http.headers),\n    };\n  }\n\n  const response: GatewayGraphQLResponse = {\n    http: {\n      headers: new FetcherHeadersForHeaderMap(\n        as4RequestContext.response.http.headers,\n      ),\n      get status() {\n        return as4RequestContext.response.http.status;\n      },\n      set status(newStatus) {\n        as4RequestContext.response.http.status = newStatus;\n      },\n    },\n    // We leave off `body` because it hasn't been set yet.\n  };\n\n  return {\n    request,\n    response,\n    logger: server.logger,\n    schema: as4RequestContext.schema,\n    // For the sake of typechecking, we still provide this field, but we don't\n    // calculate it. If somebody really needs it in their gateway\n    // implementation, they're welcome to copy\n    // https://github.com/apollographql/apollo-server/blob/3f218e78/packages/apollo-server-core/src/utils/schemaHash.ts\n    // into their code.\n    schemaHash:\n      'schemaHash no longer exists in Apollo Server 4' as GatewaySchemaHash,\n    context: as4RequestContext.contextValue,\n    cache: server.cache,\n    queryHash: as4RequestContext.queryHash,\n    document: as4RequestContext.document,\n    source: as4RequestContext.source,\n    operationName: as4RequestContext.operationName,\n    operation: as4RequestContext.operation,\n    errors: as4RequestContext.errors,\n    metrics: as4RequestContext.metrics,\n    debug: internals.includeStacktraceInErrorResponses,\n    overallCachePolicy: as4RequestContext.overallCachePolicy,\n    requestIsBatched: as4RequestContext.requestIsBatched,\n  };\n}\n\n// An implementation of the W3C-style headers class used by Gateway (and AS3),\n// backed by AS4's HeaderMap. Changes are written directly to the HeaderMap, so\n// any concurrent writes to the underlying HeaderMap (eg from a plugin) can be\n// seen immediately by the gateway and vice versa.\nclass FetcherHeadersForHeaderMap implements FetcherHeaders {\n  constructor(private map: HeaderMap) {}\n  append(name: string, value: string) {\n    if (this.map.has(name)) {\n      this.map.set(name, this.map.get(name) + ', ' + value);\n    } else {\n      this.map.set(name, value);\n    }\n  }\n  delete(name: string) {\n    this.map.delete(name);\n  }\n  get(name: string): string | null {\n    return this.map.get(name) ?? null;\n  }\n  has(name: string): boolean {\n    return this.map.has(name);\n  }\n  set(name: string, value: string) {\n    this.map.set(name, value);\n  }\n  entries(): Iterator<[string, string]> {\n    return this.map.entries();\n  }\n  keys(): Iterator<string> {\n    return this.map.keys();\n  }\n  values(): Iterator<string> {\n    return this.map.values();\n  }\n  [Symbol.iterator](): Iterator<[string, string]> {\n    return this.map.entries();\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 5247, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5252, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@apollo/server/src/incrementalDeliveryPolyfill.ts"],"sourcesContent":["import {\n  execute,\n  type ExecutionArgs,\n  type ExecutionResult,\n  type GraphQLError,\n} from 'graphql';\n\n// This file \"polyfills\" graphql@17's experimentalExecuteIncrementally (by\n// returning a function that does not understand incremental directives if\n// you're using graphql@16). The types defined in this file are largely copied\n// from graphql-js.\n\ninterface ObjMap<T> {\n  [key: string]: T;\n}\nexport interface GraphQLExperimentalInitialIncrementalExecutionResult<\n  TData = ObjMap<unknown>,\n  TExtensions = ObjMap<unknown>,\n> extends ExecutionResult<TData, TExtensions> {\n  hasNext: boolean;\n  incremental?: ReadonlyArray<\n    GraphQLExperimentalIncrementalResult<TData, TExtensions>\n  >;\n  extensions?: TExtensions;\n}\n\nexport interface GraphQLExperimentalSubsequentIncrementalExecutionResult<\n  TData = ObjMap<unknown>,\n  TExtensions = ObjMap<unknown>,\n> {\n  hasNext: boolean;\n  incremental?: ReadonlyArray<\n    GraphQLExperimentalIncrementalResult<TData, TExtensions>\n  >;\n  extensions?: TExtensions;\n}\n\ntype GraphQLExperimentalIncrementalResult<\n  TData = ObjMap<unknown>,\n  TExtensions = ObjMap<unknown>,\n> =\n  | GraphQLExperimentalIncrementalDeferResult<TData, TExtensions>\n  | GraphQLExperimentalIncrementalStreamResult<TData, TExtensions>;\n\ninterface GraphQLExperimentalIncrementalDeferResult<\n  TData = ObjMap<unknown>,\n  TExtensions = ObjMap<unknown>,\n> extends ExecutionResult<TData, TExtensions> {\n  path?: ReadonlyArray<string | number>;\n  label?: string;\n}\n\ninterface GraphQLExperimentalIncrementalStreamResult<\n  TData = Array<unknown>,\n  TExtensions = ObjMap<unknown>,\n> {\n  errors?: ReadonlyArray<GraphQLError>;\n  items?: TData | null;\n  path?: ReadonlyArray<string | number>;\n  label?: string;\n  extensions?: TExtensions;\n}\n\nexport interface GraphQLExperimentalIncrementalExecutionResults<\n  TData = ObjMap<unknown>,\n  TExtensions = ObjMap<unknown>,\n> {\n  initialResult: GraphQLExperimentalInitialIncrementalExecutionResult<\n    TData,\n    TExtensions\n  >;\n  subsequentResults: AsyncGenerator<\n    GraphQLExperimentalSubsequentIncrementalExecutionResult<TData, TExtensions>,\n    void,\n    void\n  >;\n}\n\ntype PromiseOrValue<T> = Promise<T> | T;\n\n// This starts as undefined and is set to a function or null by running\n// tryToLoadGraphQL17(). If graphql-js 17 is installed, it is set to the\n// experimentalExecuteIncrementally function from that package; otherwise it is\n// set to null.\nlet graphqlExperimentalExecuteIncrementally:\n  | ((\n      args: ExecutionArgs,\n    ) => PromiseOrValue<\n      ExecutionResult | GraphQLExperimentalIncrementalExecutionResults\n    >)\n  | null\n  | undefined = undefined;\n\nasync function tryToLoadGraphQL17() {\n  if (graphqlExperimentalExecuteIncrementally !== undefined) {\n    return;\n  }\n  const graphql = await import('graphql');\n  if ('experimentalExecuteIncrementally' in graphql) {\n    graphqlExperimentalExecuteIncrementally = (graphql as any)\n      .experimentalExecuteIncrementally;\n  } else {\n    graphqlExperimentalExecuteIncrementally = null;\n  }\n}\n\nexport async function executeIncrementally(\n  args: ExecutionArgs,\n): Promise<ExecutionResult | GraphQLExperimentalIncrementalExecutionResults> {\n  await tryToLoadGraphQL17();\n  if (graphqlExperimentalExecuteIncrementally) {\n    return graphqlExperimentalExecuteIncrementally(args);\n  }\n  return execute(args);\n}\n"],"names":[],"mappings":";;;;;;AAoFA,IAAI,0CAOY;AAEhB,eAAe;IACb,IAAI,4CAA4C,WAAW;QACzD;IACF;IACA,MAAM,UAAU;IAChB,IAAI,sCAAsC,SAAS;QACjD,0CAA2C,QACxC,gCAAgC;IACrC,OAAO;QACL,0CAA0C;IAC5C;AACF;AAEO,eAAe,qBACpB,IAAmB;IAEnB,MAAM;IACN,IAAI,yCAAyC;QAC3C,OAAO,wCAAwC;IACjD;IACA,OAAO,CAAA,GAAA,kJAAA,CAAA,UAAO,AAAP,EAAQ;AACjB"}},
    {"offset": {"line": 5277, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5282, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@apollo/server/src/requestPipeline.ts"],"sourcesContent":["import { createHash } from '@apollo/utils.createhash';\nimport {\n  specifiedRules,\n  getOperationAST,\n  GraphQLError,\n  validate,\n  parse,\n  Kind,\n  type ExecutionResult,\n} from 'graphql';\nimport {\n  symbolExecutionDispatcherWillResolveField,\n  enablePluginsForSchemaResolvers,\n  symbolUserFieldResolver,\n} from './utils/schemaInstrumentation.js';\nimport {\n  PersistedQueryNotSupportedError,\n  PersistedQueryNotFoundError,\n  UserInputError,\n  BadRequestError,\n  ValidationError,\n  SyntaxError,\n  OperationResolutionError,\n} from './internalErrorClasses.js';\nimport {\n  ensureError,\n  normalizeAndFormatErrors,\n  ensureGraphQLError,\n} from './errorNormalize.js';\nimport type {\n  GraphQLRequestContext,\n  GraphQLRequestContextDidResolveSource,\n  GraphQLRequestContextExecutionDidStart,\n  GraphQLRequestContextResponseForOperation,\n  GraphQLRequestContextDidResolveOperation,\n  GraphQLRequestContextParsingDidStart,\n  GraphQLRequestContextValidationDidStart,\n  GraphQLRequestContextWillSendResponse,\n  GraphQLRequestContextDidEncounterErrors,\n  GraphQLRequestExecutionListener,\n  BaseContext,\n  GraphQLResponse,\n  GraphQLExperimentalFormattedSubsequentIncrementalExecutionResult,\n} from './externalTypes/index.js';\n\nimport {\n  invokeDidStartHook,\n  invokeHooksUntilDefinedAndNonNull,\n  invokeSyncDidStartHook,\n} from './utils/invokeHooks.js';\n\nimport { makeGatewayGraphQLRequestContext } from './utils/makeGatewayGraphQLRequestContext.js';\n\nimport { mergeHTTPGraphQLHead, newHTTPGraphQLHead } from './runHttpQuery.js';\nimport type {\n  ApolloServer,\n  ApolloServerInternals,\n  SchemaDerivedData,\n} from './ApolloServer.js';\nimport { isDefined } from './utils/isDefined.js';\nimport type {\n  GraphQLRequestContextDidEncounterSubsequentErrors,\n  GraphQLRequestContextWillSendSubsequentPayload,\n} from './externalTypes/requestPipeline.js';\nimport {\n  executeIncrementally,\n  type GraphQLExperimentalInitialIncrementalExecutionResult,\n  type GraphQLExperimentalSubsequentIncrementalExecutionResult,\n} from './incrementalDeliveryPolyfill.js';\nimport { HeaderMap } from './utils/HeaderMap.js';\n\nexport const APQ_CACHE_PREFIX = 'apq:';\n\nfunction computeQueryHash(query: string) {\n  return createHash('sha256').update(query).digest('hex');\n}\n\ntype Mutable<T> = { -readonly [P in keyof T]: T[P] };\n\nfunction isBadUserInputGraphQLError(error: GraphQLError): boolean {\n  return (\n    error.nodes?.length === 1 &&\n    error.nodes[0].kind === Kind.VARIABLE_DEFINITION &&\n    (error.message.startsWith(\n      `Variable \"$${error.nodes[0].variable.name.value}\" got invalid value `,\n    ) ||\n      error.message.startsWith(\n        `Variable \"$${error.nodes[0].variable.name.value}\" of required type `,\n      ) ||\n      error.message.startsWith(\n        `Variable \"$${error.nodes[0].variable.name.value}\" of non-null type `,\n      ))\n  );\n}\n\n// This is \"semi-formatted\" because the initial result has not yet been\n// formatted but the subsequent results \"have been\" --- in the sense that they\n// are an async iterable that will format them as they come in.\ntype SemiFormattedExecuteIncrementallyResults =\n  | {\n      singleResult: ExecutionResult;\n    }\n  | {\n      initialResult: GraphQLExperimentalInitialIncrementalExecutionResult;\n      subsequentResults: AsyncIterable<GraphQLExperimentalFormattedSubsequentIncrementalExecutionResult>;\n    };\n\nexport async function processGraphQLRequest<TContext extends BaseContext>(\n  schemaDerivedData: SchemaDerivedData,\n  server: ApolloServer<TContext>,\n  internals: ApolloServerInternals<TContext>,\n  requestContext: Mutable<GraphQLRequestContext<TContext>>,\n): Promise<GraphQLResponse> {\n  const requestListeners = (\n    await Promise.all(\n      internals.plugins.map((p) => p.requestDidStart?.(requestContext)),\n    )\n  ).filter(isDefined);\n\n  const request = requestContext.request;\n\n  let { query, extensions } = request;\n\n  let queryHash: string;\n\n  requestContext.metrics.persistedQueryHit = false;\n  requestContext.metrics.persistedQueryRegister = false;\n\n  if (extensions?.persistedQuery) {\n    // It looks like we've received a persisted query. Check if we\n    // support them.\n    if (!internals.persistedQueries) {\n      return await sendErrorResponse([new PersistedQueryNotSupportedError()]);\n    } else if (extensions.persistedQuery.version !== 1) {\n      return await sendErrorResponse([\n        new GraphQLError('Unsupported persisted query version', {\n          extensions: { http: newHTTPGraphQLHead(400) },\n        }),\n      ]);\n    }\n\n    queryHash = extensions.persistedQuery.sha256Hash;\n\n    if (query === undefined) {\n      query = await internals.persistedQueries.cache.get(queryHash);\n      if (query) {\n        requestContext.metrics.persistedQueryHit = true;\n      } else {\n        return await sendErrorResponse([new PersistedQueryNotFoundError()]);\n      }\n    } else {\n      const computedQueryHash = computeQueryHash(query);\n\n      // The provided hash must exactly match the SHA-256 hash of\n      // the query string. This prevents hash hijacking, where a\n      // new and potentially malicious query is associated with\n      // an existing hash.\n      if (queryHash !== computedQueryHash) {\n        return await sendErrorResponse([\n          new GraphQLError('provided sha does not match query', {\n            extensions: { http: newHTTPGraphQLHead(400) },\n          }),\n        ]);\n      }\n\n      // We won't write to the persisted query cache until later.\n      // Deferring the writing gives plugins the ability to \"win\" from use of\n      // the cache, but also have their say in whether or not the cache is\n      // written to (by interrupting the request with an error).\n      requestContext.metrics.persistedQueryRegister = true;\n    }\n  } else if (query) {\n    queryHash = computeQueryHash(query);\n  } else {\n    return await sendErrorResponse([\n      new BadRequestError(\n        'GraphQL operations must contain a non-empty `query` or a `persistedQuery` extension.',\n      ),\n    ]);\n  }\n\n  requestContext.queryHash = queryHash;\n  requestContext.source = query;\n\n  // Let the plugins know that we now have a STRING of what we hope will\n  // parse and validate into a document we can execute on.  Unless we have\n  // retrieved this from our APQ cache, there's no guarantee that it is\n  // syntactically correct, so this string should not be trusted as a valid\n  // document until after it's parsed and validated.\n  await Promise.all(\n    requestListeners.map(\n      (l) =>\n        l.didResolveSource?.(\n          requestContext as GraphQLRequestContextDidResolveSource<TContext>,\n        ),\n    ),\n  );\n\n  // If we're configured with a document store (by default, we are), we'll\n  // utilize the operation's hash to lookup the AST from the previously\n  // parsed-and-validated operation.  Failure to retrieve anything from the\n  // cache just means we're committed to doing the parsing and validation.\n  if (schemaDerivedData.documentStore) {\n    try {\n      requestContext.document = await schemaDerivedData.documentStore.get(\n        schemaDerivedData.documentStoreKeyPrefix + queryHash,\n      );\n    } catch (err: unknown) {\n      server.logger.warn(\n        'An error occurred while attempting to read from the documentStore. ' +\n          ensureError(err).message,\n      );\n    }\n  }\n\n  // If we still don't have a document, we'll need to parse and validate it.\n  // With success, we'll attempt to save it into the store for future use.\n  if (!requestContext.document) {\n    const parsingDidEnd = await invokeDidStartHook(\n      requestListeners,\n      async (l) =>\n        l.parsingDidStart?.(\n          requestContext as GraphQLRequestContextParsingDidStart<TContext>,\n        ),\n    );\n\n    try {\n      requestContext.document = parse(query, internals.parseOptions);\n    } catch (syntaxMaybeError: unknown) {\n      const error = ensureError(syntaxMaybeError);\n      await parsingDidEnd(error);\n      return await sendErrorResponse([\n        new SyntaxError(ensureGraphQLError(error)),\n      ]);\n    }\n    await parsingDidEnd();\n\n    if (internals.dangerouslyDisableValidation !== true) {\n      const validationDidEnd = await invokeDidStartHook(\n        requestListeners,\n        async (l) =>\n          l.validationDidStart?.(\n            requestContext as GraphQLRequestContextValidationDidStart<TContext>,\n          ),\n      );\n\n      const validationErrors = validate(\n        schemaDerivedData.schema,\n        requestContext.document,\n        [...specifiedRules, ...internals.validationRules],\n      );\n\n      if (validationErrors.length === 0) {\n        await validationDidEnd();\n      } else {\n        await validationDidEnd(validationErrors);\n        return await sendErrorResponse(\n          validationErrors.map((error) => new ValidationError(error)),\n        );\n      }\n    }\n\n    if (schemaDerivedData.documentStore) {\n      // The underlying cache store behind the `documentStore` returns a\n      // `Promise` which is resolved (or rejected), eventually, based on the\n      // success or failure (respectively) of the cache save attempt.  While\n      // it's certainly possible to `await` this `Promise`, we don't care about\n      // whether or not it's successful at this point.  We'll instead proceed\n      // to serve the rest of the request and just hope that this works out.\n      // If it doesn't work, the next request will have another opportunity to\n      // try again.  Errors will surface as warnings, as appropriate.\n      //\n      // While it shouldn't normally be necessary to wrap this `Promise` in a\n      // `Promise.resolve` invocation, it seems that the underlying cache store\n      // is returning a non-native `Promise` (e.g. Bluebird, etc.).\n      Promise.resolve(\n        schemaDerivedData.documentStore.set(\n          schemaDerivedData.documentStoreKeyPrefix + queryHash,\n          requestContext.document,\n        ),\n      ).catch((err) =>\n        server.logger.warn(\n          'Could not store validated document. ' + err?.message || err,\n        ),\n      );\n    }\n  }\n\n  // TODO: If we want to guarantee an operation has been set when invoking\n  // `willExecuteOperation` and executionDidStart`, we need to throw an\n  // error here and not leave this to `buildExecutionContext` in\n  // `graphql-js`.\n  const operation = getOperationAST(\n    requestContext.document,\n    request.operationName,\n  );\n\n  requestContext.operation = operation || undefined;\n  // We'll set `operationName` to `null` for anonymous operations.\n  requestContext.operationName = operation?.name?.value || null;\n\n  // Special case: GET operations should only be queries (not mutations). We\n  // want to throw a particular HTTP error in that case. (This matters because\n  // it's generally how HTTP requests should work, and additionally it makes us\n  // less vulnerable to mutations running over CSRF, if you turn off our CSRF\n  // prevention feature.)\n  if (\n    request.http?.method === 'GET' &&\n    operation?.operation &&\n    operation.operation !== 'query'\n  ) {\n    return await sendErrorResponse([\n      new BadRequestError(\n        `GET requests only support query operations, not ${operation.operation} operations`,\n        {\n          extensions: {\n            http: { status: 405, headers: new HeaderMap([['allow', 'POST']]) },\n          },\n        },\n      ),\n    ]);\n  }\n\n  try {\n    await Promise.all(\n      requestListeners.map(\n        (l) =>\n          l.didResolveOperation?.(\n            requestContext as GraphQLRequestContextDidResolveOperation<TContext>,\n          ),\n      ),\n    );\n  } catch (err: unknown) {\n    // Note that we explicitly document throwing `GraphQLError`s from\n    // `didResolveOperation` as a good way to do validation that depends on the\n    // validated operation and the request context. (It will have status 500 by\n    // default.)\n    return await sendErrorResponse([ensureGraphQLError(err)]);\n  }\n\n  // Now that we've gone through the pre-execution phases of the request\n  // pipeline, and given plugins appropriate ability to object (by throwing\n  // an error) and not actually write, we'll write to the cache if it was\n  // determined earlier in the request pipeline that we should do so.\n  if (\n    requestContext.metrics.persistedQueryRegister &&\n    internals.persistedQueries\n  ) {\n    // While it shouldn't normally be necessary to wrap this `Promise` in a\n    // `Promise.resolve` invocation, it seems that the underlying cache store\n    // is returning a non-native `Promise` (e.g. Bluebird, etc.).\n    const ttl = internals.persistedQueries?.ttl;\n    Promise.resolve(\n      internals.persistedQueries.cache.set(\n        queryHash,\n        query,\n        // Explicitly checking for `undefined` which means \"not set\" vs 0 or\n        // null which means \"no TTL\".\n        ttl !== undefined\n          ? { ttl: internals.persistedQueries?.ttl }\n          : undefined,\n      ),\n    ).catch(server.logger.warn);\n  }\n\n  const responseFromPlugin = await invokeHooksUntilDefinedAndNonNull(\n    requestListeners,\n    async (l) =>\n      await l.responseForOperation?.(\n        requestContext as GraphQLRequestContextResponseForOperation<TContext>,\n      ),\n  );\n  if (responseFromPlugin !== null) {\n    requestContext.response.body = responseFromPlugin.body;\n    mergeHTTPGraphQLHead(requestContext.response.http, responseFromPlugin.http);\n  } else {\n    const executionListeners = (\n      await Promise.all(\n        requestListeners.map(\n          (l) =>\n            l.executionDidStart?.(\n              requestContext as GraphQLRequestContextExecutionDidStart<TContext>,\n            ),\n        ),\n      )\n    ).filter(isDefined);\n    executionListeners.reverse();\n\n    if (executionListeners.some((l) => l.willResolveField)) {\n      // Create a callback that will trigger the execution dispatcher's\n      // `willResolveField` hook.  We will attach this to the context on a\n      // symbol so it can be invoked by our `wrapField` method during execution.\n      const invokeWillResolveField: GraphQLRequestExecutionListener<TContext>['willResolveField'] =\n        (...args) =>\n          invokeSyncDidStartHook(\n            executionListeners,\n            (l) => l.willResolveField?.(...args),\n          );\n\n      Object.defineProperty(\n        requestContext.contextValue,\n        symbolExecutionDispatcherWillResolveField,\n        { value: invokeWillResolveField },\n      );\n\n      // If the user has provided a custom field resolver, we will attach\n      // it to the context so we can still invoke it after we've wrapped the\n      // fields with `wrapField` within `enablePluginsForSchemaResolvers` of\n      // the `schemaInstrumentation` module.\n      if (internals.fieldResolver) {\n        Object.defineProperty(\n          requestContext.contextValue,\n          symbolUserFieldResolver,\n          {\n            value: internals.fieldResolver,\n          },\n        );\n      }\n\n      // If the schema is already enabled, this is a no-op.  Otherwise, the\n      // schema will be augmented so it is able to invoke willResolveField. Note\n      // that if we never see a plugin with willResolveField then we will never\n      // need to instrument the schema, which might be a small performance gain.\n      // (For example, this can happen if you pass `fieldLevelInstrumentation:\n      // () => false` to the usage reporting plugin and disable the cache\n      // control plugin. We can consider changing the cache control plugin to\n      // have a \"static cache control only\" mode that doesn't use\n      // willResolveField too if this proves to be helpful in practice.)\n      enablePluginsForSchemaResolvers(schemaDerivedData.schema);\n    }\n\n    try {\n      const fullResult = await execute(\n        requestContext as GraphQLRequestContextExecutionDidStart<TContext>,\n      );\n      const result =\n        'singleResult' in fullResult\n          ? fullResult.singleResult\n          : fullResult.initialResult;\n\n      // If we don't have an operation, there's no reason to go further. We know\n      // `result` will consist of one error (returned by `graphql-js`'s\n      // `buildExecutionContext`).\n      if (!requestContext.operation) {\n        if (!result.errors?.length) {\n          throw new Error(\n            'Unexpected error: Apollo Server did not resolve an operation but execute did not return errors',\n          );\n        }\n        throw new OperationResolutionError(result.errors[0]);\n      }\n\n      // The first thing that execution does is coerce the request's variables\n      // to the types declared in the operation, which can lead to errors if\n      // they are of the wrong type. It also makes sure that all non-null\n      // variables are required and get non-null values. If any of these things\n      // lead to errors, we change them into UserInputError so that their code\n      // doesn't end up being INTERNAL_SERVER_ERROR, since these are client\n      // errors. (But if the error already has a code, perhaps because the\n      // original error was thrown from a custom scalar parseValue, we leave it\n      // alone. We check that here instead of as part of\n      // isBadUserInputGraphQLError since perhaps that function will one day be\n      // changed to something we can get directly from graphql-js, but the\n      // `code` check is AS-specific.)\n      //\n      // This is hacky! Hopefully graphql-js will give us a way to separate\n      // variable resolution from execution later; see\n      // https://github.com/graphql/graphql-js/issues/3169\n      const resultErrors = result.errors?.map((e) => {\n        if (isBadUserInputGraphQLError(e) && e.extensions?.code == null) {\n          return new UserInputError(e);\n        }\n        return e;\n      });\n\n      if (resultErrors) {\n        await didEncounterErrors(resultErrors);\n      }\n\n      const { formattedErrors, httpFromErrors } = resultErrors\n        ? formatErrors(resultErrors)\n        : { formattedErrors: undefined, httpFromErrors: newHTTPGraphQLHead() };\n\n      // TODO(AS5) This becomes the default behavior and the\n      // `status400ForVariableCoercionErrors` configuration option is removed /\n      // ignored.\n      if (\n        internals.status400ForVariableCoercionErrors &&\n        resultErrors?.length &&\n        result.data === undefined &&\n        !httpFromErrors.status\n      ) {\n        httpFromErrors.status = 400;\n      }\n\n      mergeHTTPGraphQLHead(requestContext.response.http, httpFromErrors);\n\n      if ('singleResult' in fullResult) {\n        requestContext.response.body = {\n          kind: 'single',\n          singleResult: {\n            ...result,\n            errors: formattedErrors,\n          },\n        };\n      } else {\n        requestContext.response.body = {\n          kind: 'incremental',\n          initialResult: {\n            ...fullResult.initialResult,\n            errors: formattedErrors,\n          },\n          subsequentResults: fullResult.subsequentResults,\n        };\n      }\n    } catch (executionMaybeError: unknown) {\n      const executionError = ensureError(executionMaybeError);\n      await Promise.all(\n        executionListeners.map((l) => l.executionDidEnd?.(executionError)),\n      );\n\n      return await sendErrorResponse([ensureGraphQLError(executionError)]);\n    }\n\n    await Promise.all(executionListeners.map((l) => l.executionDidEnd?.()));\n  }\n\n  await invokeWillSendResponse();\n  if (!requestContext.response.body) {\n    throw Error('got to end of processGraphQLRequest without setting body?');\n  }\n  return requestContext.response as GraphQLResponse; // cast checked on previous line\n\n  async function execute(\n    requestContext: GraphQLRequestContextExecutionDidStart<TContext>,\n  ): Promise<SemiFormattedExecuteIncrementallyResults> {\n    const { request, document } = requestContext;\n\n    if (internals.__testing_incrementalExecutionResults) {\n      return internals.__testing_incrementalExecutionResults;\n    } else if (internals.gatewayExecutor) {\n      const result = await internals.gatewayExecutor(\n        makeGatewayGraphQLRequestContext(requestContext, server, internals),\n      );\n      return { singleResult: result };\n    } else {\n      const resultOrResults = await executeIncrementally({\n        schema: schemaDerivedData.schema,\n        document,\n        rootValue:\n          typeof internals.rootValue === 'function'\n            ? internals.rootValue(document)\n            : internals.rootValue,\n        contextValue: requestContext.contextValue,\n        variableValues: request.variables,\n        operationName: request.operationName,\n        fieldResolver: internals.fieldResolver,\n      });\n      if ('initialResult' in resultOrResults) {\n        return {\n          initialResult: resultOrResults.initialResult,\n          subsequentResults: formatErrorsInSubsequentResults(\n            resultOrResults.subsequentResults,\n          ),\n        };\n      } else {\n        return { singleResult: resultOrResults };\n      }\n    }\n  }\n\n  async function* formatErrorsInSubsequentResults(\n    results: AsyncIterable<GraphQLExperimentalSubsequentIncrementalExecutionResult>,\n  ): AsyncIterable<GraphQLExperimentalFormattedSubsequentIncrementalExecutionResult> {\n    for await (const result of results) {\n      const payload: GraphQLExperimentalFormattedSubsequentIncrementalExecutionResult =\n        result.incremental\n          ? {\n              ...result,\n              incremental: await seriesAsyncMap(\n                result.incremental,\n                async (incrementalResult) => {\n                  const { errors } = incrementalResult;\n                  if (errors) {\n                    await Promise.all(\n                      requestListeners.map(\n                        (l) =>\n                          l.didEncounterSubsequentErrors?.(\n                            requestContext as GraphQLRequestContextDidEncounterSubsequentErrors<TContext>,\n                            errors,\n                          ),\n                      ),\n                    );\n\n                    return {\n                      ...incrementalResult,\n                      // Note that any `http` extensions in errors have no\n                      // effect, because we've already sent the status code\n                      // and response headers.\n                      errors: formatErrors(errors).formattedErrors,\n                    };\n                  }\n                  return incrementalResult;\n                },\n              ),\n            }\n          : result;\n\n      // Invoke hook, which is allowed to mutate payload if it really wants to.\n      await Promise.all(\n        requestListeners.map(\n          (l) =>\n            l.willSendSubsequentPayload?.(\n              requestContext as GraphQLRequestContextWillSendSubsequentPayload<TContext>,\n              payload,\n            ),\n        ),\n      );\n\n      yield payload;\n    }\n  }\n\n  async function invokeWillSendResponse() {\n    await Promise.all(\n      requestListeners.map(\n        (l) =>\n          l.willSendResponse?.(\n            requestContext as GraphQLRequestContextWillSendResponse<TContext>,\n          ),\n      ),\n    );\n  }\n\n  // Note that we ensure that all calls to didEncounterErrors are followed by\n  // calls to willSendResponse. (The usage reporting plugin depends on this.)\n  async function didEncounterErrors(errors: ReadonlyArray<GraphQLError>) {\n    requestContext.errors = errors;\n\n    return await Promise.all(\n      requestListeners.map(\n        (l) =>\n          l.didEncounterErrors?.(\n            requestContext as GraphQLRequestContextDidEncounterErrors<TContext>,\n          ),\n      ),\n    );\n  }\n\n  // This function \"sends\" a response that contains errors and no data (not even\n  // `data: null`) because the pipeline does not make it to a successful\n  // `execute` call. (It is *not* called for execution that happens to return\n  // some errors.) In this case \"send\" means \"update requestContext.response and\n  // invoke willSendResponse hooks\".\n  //\n  // If any errors have `extensions.http` set, it sets the response's status code\n  // and errors from them.\n  //\n  // Then, if the HTTP status code is not yet set, it sets it to 500.\n  async function sendErrorResponse(\n    errors: ReadonlyArray<GraphQLError>,\n  ): Promise<GraphQLResponse> {\n    await didEncounterErrors(errors);\n\n    const { formattedErrors, httpFromErrors } = formatErrors(errors);\n\n    requestContext.response.body = {\n      kind: 'single',\n      singleResult: {\n        errors: formattedErrors,\n      },\n    };\n\n    mergeHTTPGraphQLHead(requestContext.response.http, httpFromErrors);\n\n    if (!requestContext.response.http.status) {\n      requestContext.response.http.status = 500;\n    }\n\n    await invokeWillSendResponse();\n\n    // cast safe because we assigned to `body` above\n    return requestContext.response as GraphQLResponse;\n  }\n\n  function formatErrors(\n    errors: ReadonlyArray<GraphQLError>,\n  ): ReturnType<typeof normalizeAndFormatErrors> {\n    return normalizeAndFormatErrors(errors, {\n      formatError: internals.formatError,\n      includeStacktraceInErrorResponses:\n        internals.includeStacktraceInErrorResponses,\n    });\n  }\n}\n\nasync function seriesAsyncMap<T, U>(\n  ts: readonly T[],\n  fn: (value: T) => Promise<U>,\n): Promise<U[]> {\n  const us: U[] = [];\n  for (const t of ts) {\n    const u = await fn(t);\n    us.push(u);\n  }\n  return us;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 5610, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5615, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@apollo/server/src/utils/UnreachableCaseError.ts"],"sourcesContent":["/**\n * Throw this in places that should be unreachable (because all other cases have\n * been handled, reducing the type of the argument to `never`). TypeScript will\n * complain if in fact there is a valid type for the argument.\n */\nexport class UnreachableCaseError extends Error {\n  constructor(val: never) {\n    super(`Unreachable case: ${val}`);\n  }\n}\n"],"names":[],"mappings":";;;AAKM,MAAO,6BAA6B;IACxC,YAAY,GAAU,CAAA;QACpB,KAAK,CAAC,CAAA,kBAAA,EAAqB,IAAG,CAAE;IAClC"}},
    {"offset": {"line": 5623, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5628, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@apollo/server/src/utils/computeCoreSchemaHash.ts"],"sourcesContent":["import { createHash } from '@apollo/utils.createhash';\n\n// This hash function is used in both the schema reporting and usage reporting\n// plugins. Making sure we use the same hash function hypothetically allows the\n// two reporting features to work well together, though in practice nothing on\n// the Studio side currently correlates this ID across both features.\nexport function computeCoreSchemaHash(schema: string): string {\n  return createHash('sha256').update(schema).digest('hex');\n}\n"],"names":[],"mappings":";;;;;;AAMM,SAAU,sBAAsB,MAAc;IAClD,OAAO,CAAA,GAAA,kKAAA,CAAA,aAAU,AAAV,EAAW,UAAU,MAAM,CAAC,QAAQ,MAAM,CAAC;AACpD"}},
    {"offset": {"line": 5637, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5642, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@apollo/server/src/utils/schemaManager.ts"],"sourcesContent":["import type { Logger } from '@apollo/utils.logger';\nimport type { GraphQLSchema } from 'graphql';\nimport type {\n  GatewayExecutor,\n  GatewayInterface,\n  GatewayUnsubscriber,\n} from '@apollo/server-gateway-interface';\nimport type { SchemaDerivedData } from '../ApolloServer.js';\nimport type {\n  ApolloConfig,\n  GraphQLSchemaContext,\n} from '../externalTypes/index.js';\n\ntype SchemaDerivedDataProvider = (\n  apiSchema: GraphQLSchema,\n) => SchemaDerivedData;\n\n/**\n * An async-safe class for tracking changes in schemas and schema-derived data.\n *\n * Specifically, as long as start() is called (and completes) before stop() is\n * called, any set of executions of public methods is linearizable.\n *\n * Note that linearizability in Javascript is trivial if all public methods are\n * non-async, but increasingly difficult to guarantee if public methods become\n * async. Accordingly, if you believe a public method should be async, think\n * carefully on whether it's worth the mental overhead. (E.g. if you wished that\n * a callback was async, consider instead resolving a Promise in a non-async\n * callback and having your async code wait on the Promise in setTimeout().)\n */\nexport class SchemaManager {\n  private readonly logger: Logger;\n  private readonly schemaDerivedDataProvider: SchemaDerivedDataProvider;\n  private readonly onSchemaLoadOrUpdateListeners = new Set<\n    (schemaContext: GraphQLSchemaContext) => void\n  >();\n  private isStopped = false;\n  private schemaDerivedData?: SchemaDerivedData;\n  private schemaContext?: GraphQLSchemaContext;\n\n  // For state that's specific to the mode of operation.\n  private readonly modeSpecificState:\n    | {\n        readonly mode: 'gateway';\n        readonly gateway: GatewayInterface;\n        readonly apolloConfig: ApolloConfig;\n        unsubscribeFromGateway?: GatewayUnsubscriber;\n      }\n    | {\n        readonly mode: 'schema';\n        readonly apiSchema: GraphQLSchema;\n        readonly schemaDerivedData: SchemaDerivedData;\n      };\n\n  constructor(\n    options: (\n      | { gateway: GatewayInterface; apolloConfig: ApolloConfig }\n      | { apiSchema: GraphQLSchema }\n    ) & {\n      logger: Logger;\n      schemaDerivedDataProvider: SchemaDerivedDataProvider;\n    },\n  ) {\n    this.logger = options.logger;\n    this.schemaDerivedDataProvider = options.schemaDerivedDataProvider;\n    if ('gateway' in options) {\n      this.modeSpecificState = {\n        mode: 'gateway',\n        gateway: options.gateway,\n        apolloConfig: options.apolloConfig,\n      };\n    } else {\n      this.modeSpecificState = {\n        mode: 'schema',\n        apiSchema: options.apiSchema,\n        // The caller of the constructor expects us to fail early if the schema\n        // given is invalid/has errors, so we call the provider here. We also\n        // pass the result to start(), as the provider can be expensive to call.\n        schemaDerivedData: options.schemaDerivedDataProvider(options.apiSchema),\n      };\n    }\n  }\n\n  /**\n   * Calling start() will:\n   * - Start gateway schema fetching (if a gateway was provided).\n   * - Initialize schema-derived data.\n   * - Synchronously notify onSchemaLoadOrUpdate() listeners of schema load, and\n   *   asynchronously notify them of schema updates.\n   * - If we started a gateway, returns the gateway's executor; otherwise null.\n   */\n  public async start(): Promise<GatewayExecutor | null> {\n    if (this.modeSpecificState.mode === 'gateway') {\n      const gateway = this.modeSpecificState.gateway;\n      if (gateway.onSchemaLoadOrUpdate) {\n        // Use onSchemaLoadOrUpdate, as it reports the core supergraph SDL and\n        // always reports the initial schema load.\n        this.modeSpecificState.unsubscribeFromGateway =\n          gateway.onSchemaLoadOrUpdate((schemaContext) => {\n            this.processSchemaLoadOrUpdateEvent(schemaContext);\n          });\n      } else {\n        throw new Error(\n          \"Unexpectedly couldn't find onSchemaLoadOrUpdate on gateway\",\n        );\n      }\n\n      const config = await this.modeSpecificState.gateway.load({\n        apollo: this.modeSpecificState.apolloConfig,\n      });\n\n      return config.executor;\n    } else {\n      this.processSchemaLoadOrUpdateEvent(\n        {\n          apiSchema: this.modeSpecificState.apiSchema,\n        },\n        this.modeSpecificState.schemaDerivedData,\n      );\n      return null;\n    }\n  }\n\n  /**\n   * Registers a listener for schema load/update events. Note that the latest\n   * event is buffered, i.e.\n   * - If registered before start(), this method will throw. (We have no need\n   *   for registration before start(), but this is easy enough to change.)\n   * - If registered after start() but before stop(), the callback will be first\n   *   called in this method (for whatever the current schema is), and then\n   *   later for updates.\n   * - If registered after stop(), the callback will never be called.\n   *\n   * For gateways, a core supergraph SDL will be provided to the callback.\n   *\n   * @param callback The listener to execute on schema load/updates.\n   */\n  public onSchemaLoadOrUpdate(\n    callback: (schemaContext: GraphQLSchemaContext) => void,\n  ): GatewayUnsubscriber {\n    if (!this.schemaContext) {\n      throw new Error('You must call start() before onSchemaLoadOrUpdate()');\n    }\n    if (!this.isStopped) {\n      try {\n        callback(this.schemaContext);\n      } catch (e) {\n        // Note that onSchemaLoadOrUpdate() is currently only called from\n        // ApolloServer._start(), so we throw here to alert the user early\n        // that their callback is failing.\n        throw new Error(\n          `An error was thrown from an 'onSchemaLoadOrUpdate' listener: ${\n            (e as Error).message\n          }`,\n        );\n      }\n    }\n    this.onSchemaLoadOrUpdateListeners.add(callback);\n\n    return () => {\n      this.onSchemaLoadOrUpdateListeners.delete(callback);\n    };\n  }\n\n  /**\n   * Get the schema-derived state for the current schema. This throws if called\n   * before start() is called.\n   */\n  public getSchemaDerivedData(): SchemaDerivedData {\n    if (!this.schemaDerivedData) {\n      throw new Error('You must call start() before getSchemaDerivedData()');\n    }\n    return this.schemaDerivedData;\n  }\n\n  /**\n   * Calling stop() will:\n   * - Stop gateway schema fetching (if a gateway was provided).\n   *   - Note that this specific step may not succeed if gateway is old.\n   * - Stop updating schema-derived data.\n   * - Stop notifying onSchemaLoadOrUpdate() listeners.\n   */\n  public async stop(): Promise<void> {\n    this.isStopped = true;\n    if (this.modeSpecificState.mode === 'gateway') {\n      this.modeSpecificState.unsubscribeFromGateway?.();\n      await this.modeSpecificState.gateway.stop?.();\n    }\n  }\n\n  private processSchemaLoadOrUpdateEvent(\n    schemaContext: GraphQLSchemaContext,\n    schemaDerivedData?: SchemaDerivedData,\n  ): void {\n    if (!this.isStopped) {\n      this.schemaDerivedData =\n        schemaDerivedData ??\n        this.schemaDerivedDataProvider(schemaContext.apiSchema);\n      this.schemaContext = schemaContext;\n      this.onSchemaLoadOrUpdateListeners.forEach((listener) => {\n        try {\n          listener(schemaContext);\n        } catch (e) {\n          this.logger.error(\n            \"An error was thrown from an 'onSchemaLoadOrUpdate' listener\",\n          );\n          this.logger.error(e);\n        }\n      });\n    }\n  }\n}\n"],"names":[],"mappings":";;;AA8BM,MAAO;IAwBX,YACE,OAMC,CAAA;QA5Bc,IAAA,CAAA,6BAA6B,GAAG,IAAI;QAG7C,IAAA,CAAA,SAAS,GAAG;QA2BlB,IAAI,CAAC,MAAM,GAAG,QAAQ,MAAM;QAC5B,IAAI,CAAC,yBAAyB,GAAG,QAAQ,yBAAyB;QAClE,IAAI,aAAa,SAAS;YACxB,IAAI,CAAC,iBAAiB,GAAG;gBACvB,MAAM;gBACN,SAAS,QAAQ,OAAO;gBACxB,cAAc,QAAQ,YAAY;;QAEtC,OAAO;YACL,IAAI,CAAC,iBAAiB,GAAG;gBACvB,MAAM;gBACN,WAAW,QAAQ,SAAS;gBAI5B,mBAAmB,QAAQ,yBAAyB,CAAC,QAAQ,SAAS;;QAE1E;IACF;IAUO,MAAM,QAAK;QAChB,IAAI,IAAI,CAAC,iBAAiB,CAAC,IAAI,KAAK,WAAW;YAC7C,MAAM,UAAU,IAAI,CAAC,iBAAiB,CAAC,OAAO;YAC9C,IAAI,QAAQ,oBAAoB,EAAE;gBAGhC,IAAI,CAAC,iBAAiB,CAAC,sBAAsB,GAC3C,QAAQ,oBAAoB,CAAC,CAAC;oBAC5B,IAAI,CAAC,8BAA8B,CAAC;gBACtC;YACJ,OAAO;gBACL,MAAM,IAAI,MACR;YAEJ;YAEA,MAAM,SAAS,MAAM,IAAI,CAAC,iBAAiB,CAAC,OAAO,CAAC,IAAI,CAAC;gBACvD,QAAQ,IAAI,CAAC,iBAAiB,CAAC,YAAY;;YAG7C,OAAO,OAAO,QAAQ;QACxB,OAAO;YACL,IAAI,CAAC,8BAA8B,CACjC;gBACE,WAAW,IAAI,CAAC,iBAAiB,CAAC,SAAS;eAE7C,IAAI,CAAC,iBAAiB,CAAC,iBAAiB;YAE1C,OAAO;QACT;IACF;IAgBO,qBACL,QAAuD,EAAA;QAEvD,IAAI,CAAC,IAAI,CAAC,aAAa,EAAE;YACvB,MAAM,IAAI,MAAM;QAClB;QACA,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE;YACnB,IAAI;gBACF,SAAS,IAAI,CAAC,aAAa;YAC7B,EAAE,OAAO,GAAG;gBAIV,MAAM,IAAI,MACR,CAAA,6DAAA,EACG,EAAY,OACf,CAAA,CAAE;YAEN;QACF;QACA,IAAI,CAAC,6BAA6B,CAAC,GAAG,CAAC;QAEvC,OAAO;YACL,IAAI,CAAC,6BAA6B,CAAC,MAAM,CAAC;QAC5C;IACF;IAMO,uBAAoB;QACzB,IAAI,CAAC,IAAI,CAAC,iBAAiB,EAAE;YAC3B,MAAM,IAAI,MAAM;QAClB;QACA,OAAO,IAAI,CAAC,iBAAiB;IAC/B;IASO,MAAM,OAAI;QACf,IAAI,CAAC,SAAS,GAAG;QACjB,IAAI,IAAI,CAAC,iBAAiB,CAAC,IAAI,KAAK,WAAW;YAC7C,IAAI,CAAC,iBAAiB,CAAC,sBAAsB;YAC7C,MAAM,IAAI,CAAC,iBAAiB,CAAC,OAAO,CAAC,IAAI;QAC3C;IACF;IAEQ,+BACN,aAAmC,EACnC,iBAAqC,EAAA;QAErC,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE;YACnB,IAAI,CAAC,iBAAiB,GACpB,qBACA,IAAI,CAAC,yBAAyB,CAAC,cAAc,SAAS;YACxD,IAAI,CAAC,aAAa,GAAG;YACrB,IAAI,CAAC,6BAA6B,CAAC,OAAO,CAAC,CAAC;gBAC1C,IAAI;oBACF,SAAS;gBACX,EAAE,OAAO,GAAG;oBACV,IAAI,CAAC,MAAM,CAAC,KAAK,CACf;oBAEF,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC;gBACpB;YACF;QACF;IACF"}},
    {"offset": {"line": 5730, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5735, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@apollo/server/src/ApolloServer.ts"],"sourcesContent":["import type { GatewayExecutor } from '@apollo/server-gateway-interface';\nimport { isNodeLike } from '@apollo/utils.isnodelike';\nimport {\n  InMemoryLRUCache,\n  PrefixingKeyValueCache,\n  type KeyValueCache,\n} from '@apollo/utils.keyvaluecache';\nimport type { Logger } from '@apollo/utils.logger';\nimport type { WithRequired } from '@apollo/utils.withrequired';\nimport { makeExecutableSchema } from '@graphql-tools/schema';\nimport resolvable, { type Resolvable } from '@josephg/resolvable';\nimport {\n  GraphQLError,\n  assertValidSchema,\n  print,\n  printSchema,\n  type DocumentNode,\n  type FormattedExecutionResult,\n  type GraphQLFieldResolver,\n  type GraphQLFormattedError,\n  type GraphQLSchema,\n  type ParseOptions,\n  type TypedQueryDocumentNode,\n  type ValidationContext,\n  type ValidationRule,\n} from 'graphql';\nimport loglevel from 'loglevel';\nimport Negotiator from 'negotiator';\nimport { newCachePolicy } from './cachePolicy.js';\nimport { determineApolloConfig } from './determineApolloConfig.js';\nimport {\n  ensureError,\n  ensureGraphQLError,\n  normalizeAndFormatErrors,\n} from './errorNormalize.js';\nimport {\n  ApolloServerErrorCode,\n  ApolloServerValidationErrorCode,\n} from './errors/index.js';\nimport type { ApolloServerOptionsWithStaticSchema } from './externalTypes/constructor.js';\nimport type {\n  ExecuteOperationOptions,\n  VariableValues,\n} from './externalTypes/graphql.js';\nimport type {\n  ApolloConfig,\n  ApolloServerOptions,\n  ApolloServerPlugin,\n  BaseContext,\n  ContextThunk,\n  DocumentStore,\n  GraphQLRequest,\n  GraphQLRequestContext,\n  GraphQLResponse,\n  GraphQLServerContext,\n  GraphQLServerListener,\n  HTTPGraphQLHead,\n  HTTPGraphQLRequest,\n  HTTPGraphQLResponse,\n  LandingPage,\n  PersistedQueryOptions,\n} from './externalTypes/index.js';\nimport { runPotentiallyBatchedHttpQuery } from './httpBatching.js';\nimport type { GraphQLExperimentalIncrementalExecutionResults } from './incrementalDeliveryPolyfill.js';\nimport { pluginIsInternal, type InternalPluginId } from './internalPlugin.js';\nimport {\n  preventCsrf,\n  recommendedCsrfPreventionRequestHeaders,\n} from './preventCsrf.js';\nimport { APQ_CACHE_PREFIX, processGraphQLRequest } from './requestPipeline.js';\nimport { newHTTPGraphQLHead, prettyJSONStringify } from './runHttpQuery.js';\nimport { HeaderMap } from './utils/HeaderMap.js';\nimport { UnreachableCaseError } from './utils/UnreachableCaseError.js';\nimport { computeCoreSchemaHash } from './utils/computeCoreSchemaHash.js';\nimport { isDefined } from './utils/isDefined.js';\nimport { SchemaManager } from './utils/schemaManager.js';\n\nconst NoIntrospection: ValidationRule = (context: ValidationContext) => ({\n  Field(node) {\n    if (node.name.value === '__schema' || node.name.value === '__type') {\n      context.reportError(\n        new GraphQLError(\n          'GraphQL introspection is not allowed by Apollo Server, but the query contained __schema or __type. To enable introspection, pass introspection: true to ApolloServer in production',\n          {\n            nodes: [node],\n            extensions: {\n              validationErrorCode:\n                ApolloServerValidationErrorCode.INTROSPECTION_DISABLED,\n            },\n          },\n        ),\n      );\n    }\n  },\n});\n\nexport type SchemaDerivedData = {\n  schema: GraphQLSchema;\n  // A store that, when enabled (default), will store the parsed and validated\n  // versions of operations in-memory, allowing subsequent parses/validates\n  // on the same operation to be executed immediately.\n  documentStore: DocumentStore | null;\n  // Prefix for keys in the DocumentStore if a custom one is provided (to\n  // separate the cache for different schema versions). This is vital to\n  // security so we do it explicitly so that\n  // PrefixingKeyValueCache.cacheDangerouslyDoesNotNeedPrefixesForIsolation\n  // doesn't affect it.\n  documentStoreKeyPrefix: string;\n};\n\ntype RunningServerState = {\n  schemaManager: SchemaManager;\n  landingPage: LandingPage | null;\n};\n\ntype ServerState =\n  | {\n      phase: 'initialized';\n      schemaManager: SchemaManager;\n    }\n  | {\n      phase: 'starting';\n      barrier: Resolvable<void>;\n      schemaManager: SchemaManager;\n      // This is set to true if you called\n      // startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests\n      // instead of start. The main purpose is that assertStarted allows you to\n      // still be in the starting phase if this is set. (This is the serverless\n      // use case.)\n      startedInBackground: boolean;\n    }\n  | {\n      phase: 'failed to start';\n      error: Error;\n    }\n  | ({\n      phase: 'started';\n      drainServers: (() => Promise<void>) | null;\n      toDispose: (() => Promise<void>)[];\n      toDisposeLast: (() => Promise<void>)[];\n    } & RunningServerState)\n  | ({\n      phase: 'draining';\n      barrier: Resolvable<void>;\n    } & RunningServerState)\n  | {\n      phase: 'stopping';\n      barrier: Resolvable<void>;\n    }\n  | {\n      phase: 'stopped';\n      stopError: Error | null;\n    };\n\nexport interface ApolloServerInternals<TContext extends BaseContext> {\n  state: ServerState;\n  gatewayExecutor: GatewayExecutor | null;\n  dangerouslyDisableValidation?: boolean;\n  formatError?: (\n    formattedError: GraphQLFormattedError,\n    error: unknown,\n  ) => GraphQLFormattedError;\n  includeStacktraceInErrorResponses: boolean;\n  persistedQueries?: WithRequired<PersistedQueryOptions, 'cache'>;\n  nodeEnv: string;\n  allowBatchedHttpRequests: boolean;\n  apolloConfig: ApolloConfig;\n  plugins: ApolloServerPlugin<TContext>[];\n  parseOptions: ParseOptions;\n  // `undefined` means we figure out what to do during _start (because\n  // the default depends on whether or not we used the background version\n  // of start).\n  stopOnTerminationSignals: boolean | undefined;\n  csrfPreventionRequestHeaders: string[] | null;\n\n  rootValue?: ((parsedQuery: DocumentNode) => unknown) | unknown;\n  validationRules: Array<ValidationRule>;\n  fieldResolver?: GraphQLFieldResolver<any, TContext>;\n  // TODO(AS5): remove OR warn + ignore with this option set, ignore option and\n  // flip default behavior.\n  status400ForVariableCoercionErrors?: boolean;\n  __testing_incrementalExecutionResults?: GraphQLExperimentalIncrementalExecutionResults;\n  stringifyResult: (\n    value: FormattedExecutionResult,\n  ) => string | Promise<string>;\n}\n\nfunction defaultLogger(): Logger {\n  const loglevelLogger = loglevel.getLogger('apollo-server');\n  loglevelLogger.setLevel(loglevel.levels.INFO);\n  return loglevelLogger;\n}\n\n// We really want to prevent this from being legal:\n//\n//     const s: ApolloServer<{}> =\n//       new ApolloServer<{importantContextField: boolean}>({ ... });\n//     s.executeOperation({query}, {contextValue: {}});\n//\n// ie, if you declare an ApolloServer whose context values must be of a certain\n// type, you can't assign it to a variable whose context values are less\n// constrained and then pass in a context value missing important fields.\n//\n// We also want this to be illegal:\n//\n//     const sBase = new ApolloServer<{}>({ ... });\n//     const s: ApolloServer<{importantContextField: boolean}> = sBase;\n//     s.addPlugin({async requestDidStart({contextValue: {importantContextField}}) { ... }})\n//     sBase.executeOperation({query}, {contextValue: {}});\n//\n// so you shouldn't be able to assign an ApolloServer to a variable whose\n// context values are more constrained, either. So we want to declare that\n// ApolloServer is *invariant* in TContext, which we do with `in out` (a\n// TypeScript 4.7 feature).\nexport class ApolloServer<in out TContext extends BaseContext = BaseContext> {\n  private internals: ApolloServerInternals<TContext>;\n\n  public readonly cache: KeyValueCache<string>;\n  public readonly logger: Logger;\n\n  constructor(config: ApolloServerOptions<TContext>) {\n    const nodeEnv = config.nodeEnv ?? process.env.NODE_ENV ?? '';\n\n    this.logger = config.logger ?? defaultLogger();\n\n    const apolloConfig = determineApolloConfig(config.apollo, this.logger);\n\n    const isDev = nodeEnv !== 'production';\n\n    if (\n      config.cache &&\n      config.cache !== 'bounded' &&\n      PrefixingKeyValueCache.prefixesAreUnnecessaryForIsolation(config.cache)\n    ) {\n      throw new Error(\n        'You cannot pass a cache returned from ' +\n          '`PrefixingKeyValueCache.cacheDangerouslyDoesNotNeedPrefixesForIsolation`' +\n          'to `new ApolloServer({ cache })`, because Apollo Server may use it for ' +\n          'multiple features whose cache keys must be distinct from each other.',\n      );\n    }\n\n    const state: ServerState = config.gateway\n      ? // ApolloServer has been initialized but we have not yet tried to load the\n        // schema from the gateway. That will wait until `start()` or\n        // `startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests()`\n        // is called. (These may be called by other helpers; for example,\n        // `standaloneServer` calls `start` for you inside its `listen` method,\n        // and a serverless framework integration would call\n        // startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests\n        // for you.)\n        {\n          phase: 'initialized',\n          schemaManager: new SchemaManager({\n            gateway: config.gateway,\n            apolloConfig,\n            schemaDerivedDataProvider: (schema) =>\n              ApolloServer.generateSchemaDerivedData(\n                schema,\n                config.documentStore,\n              ),\n            logger: this.logger,\n          }),\n        }\n      : // We construct the schema synchronously so that we can fail fast if the\n        // schema can't be constructed. (This used to be more important because we\n        // used to have a 'schema' field that was publicly accessible immediately\n        // after construction, though that field never actually worked with\n        // gateways.)\n        {\n          phase: 'initialized',\n          schemaManager: new SchemaManager({\n            apiSchema: ApolloServer.constructSchema(config),\n            schemaDerivedDataProvider: (schema) =>\n              ApolloServer.generateSchemaDerivedData(\n                schema,\n                config.documentStore,\n              ),\n            logger: this.logger,\n          }),\n        };\n\n    const introspectionEnabled = config.introspection ?? isDev;\n\n    // We continue to allow 'bounded' for backwards-compatibility with the AS3.9\n    // API.\n    this.cache =\n      config.cache === undefined || config.cache === 'bounded'\n        ? new InMemoryLRUCache()\n        : config.cache;\n\n    // Note that we avoid calling methods on `this` before `this.internals` is assigned\n    // (thus a bunch of things being static methods above).\n    this.internals = {\n      formatError: config.formatError,\n      rootValue: config.rootValue,\n      validationRules: [\n        ...(config.validationRules ?? []),\n        ...(introspectionEnabled ? [] : [NoIntrospection]),\n      ],\n      dangerouslyDisableValidation:\n        config.dangerouslyDisableValidation ?? false,\n      fieldResolver: config.fieldResolver,\n      includeStacktraceInErrorResponses:\n        config.includeStacktraceInErrorResponses ??\n        (nodeEnv !== 'production' && nodeEnv !== 'test'),\n      persistedQueries:\n        config.persistedQueries === false\n          ? undefined\n          : {\n              ...config.persistedQueries,\n              cache: new PrefixingKeyValueCache(\n                config.persistedQueries?.cache ?? this.cache,\n                APQ_CACHE_PREFIX,\n              ),\n            },\n      nodeEnv,\n      allowBatchedHttpRequests: config.allowBatchedHttpRequests ?? false,\n      apolloConfig,\n      // Note that more plugins can be added before `start()` with `addPlugin()`\n      // (eg, plugins that want to take this ApolloServer as an argument), and\n      // `start()` will call `addDefaultPlugins` to add default plugins.\n      plugins: config.plugins ?? [],\n      parseOptions: config.parseOptions ?? {},\n      state,\n      stopOnTerminationSignals: config.stopOnTerminationSignals,\n\n      gatewayExecutor: null, // set by _start\n\n      csrfPreventionRequestHeaders:\n        config.csrfPrevention === true || config.csrfPrevention === undefined\n          ? recommendedCsrfPreventionRequestHeaders\n          : config.csrfPrevention === false\n            ? null\n            : config.csrfPrevention.requestHeaders ??\n              recommendedCsrfPreventionRequestHeaders,\n      status400ForVariableCoercionErrors:\n        config.status400ForVariableCoercionErrors ?? false,\n      __testing_incrementalExecutionResults:\n        config.__testing_incrementalExecutionResults,\n      stringifyResult: config.stringifyResult ?? prettyJSONStringify,\n    };\n  }\n\n  // Awaiting a call to `start` ensures that a schema has been loaded and that\n  // all plugin `serverWillStart` hooks have been called. If either of these\n  // processes throw, `start` will (async) throw as well.\n  //\n  // If you're using `standaloneServer`, you don't need to call `start` yourself\n  // (in fact, it will throw if you do so); its `listen` method takes care of\n  // that for you.\n  //\n  // If instead you're using an integration package for a non-serverless\n  // framework (like Express), you must await a call to `start` immediately\n  // after creating your `ApolloServer`, before attaching it to your web\n  // framework and starting to accept requests. `start` should only be called\n  // once; if it throws and you'd like to retry, just create another\n  // `ApolloServer`. (Calling `start` was optional in Apollo Server 2, but in\n  // Apollo Server 3+ the functions like `expressMiddleware` use `assertStarted`\n  // to throw if `start` hasn't successfully completed.)\n  //\n  // Serverless integrations like Lambda do not support calling `start()`,\n  // because their lifecycle doesn't allow you to wait before assigning a\n  // handler or allowing the handler to be called. So they call\n  // `startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests()`\n  // instead, and don't really differentiate between startup failures and\n  // request failures. This is hopefully appropriate for a \"serverless\"\n  // framework. Serverless startup failures result in returning a redacted error\n  // to the end user and logging the more detailed error.\n  public async start(): Promise<void> {\n    return await this._start(false);\n  }\n\n  public startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests(): void {\n    this._start(true).catch((e) => this.logStartupError(e));\n  }\n\n  private async _start(startedInBackground: boolean): Promise<void> {\n    if (this.internals.state.phase !== 'initialized') {\n      // If we wanted we could make this error detectable and change\n      // `standaloneServer` to change the message to say not to call start() at\n      // all.\n      throw new Error(\n        `You should only call 'start()' or ` +\n          `'startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests()' ` +\n          `once on your ApolloServer.`,\n      );\n    }\n    const schemaManager = this.internals.state.schemaManager;\n    const barrier = resolvable();\n    this.internals.state = {\n      phase: 'starting',\n      barrier,\n      schemaManager,\n      startedInBackground,\n    };\n    try {\n      // Now that you can't call addPlugin any more, add default plugins like\n      // usage reporting if they're not already added.\n      await this.addDefaultPlugins();\n\n      const toDispose: (() => Promise<void>)[] = [];\n      const executor = await schemaManager.start();\n      if (executor) {\n        this.internals.gatewayExecutor = executor;\n      }\n      toDispose.push(async () => {\n        await schemaManager.stop();\n      });\n\n      const schemaDerivedData = schemaManager.getSchemaDerivedData();\n      const service: GraphQLServerContext = {\n        logger: this.logger,\n        cache: this.cache,\n        schema: schemaDerivedData.schema,\n        apollo: this.internals.apolloConfig,\n        startedInBackground,\n      };\n\n      const taggedServerListeners = (\n        await Promise.all(\n          this.internals.plugins.map(async (plugin) => ({\n            serverListener:\n              plugin.serverWillStart && (await plugin.serverWillStart(service)),\n            installedImplicitly:\n              isImplicitlyInstallablePlugin(plugin) &&\n              plugin.__internal_installed_implicitly__,\n          })),\n        )\n      ).filter(\n        (\n          maybeTaggedServerListener,\n        ): maybeTaggedServerListener is {\n          serverListener: GraphQLServerListener;\n          installedImplicitly: boolean;\n        } => typeof maybeTaggedServerListener.serverListener === 'object',\n      );\n\n      taggedServerListeners.forEach(\n        ({ serverListener: { schemaDidLoadOrUpdate } }) => {\n          if (schemaDidLoadOrUpdate) {\n            schemaManager.onSchemaLoadOrUpdate(schemaDidLoadOrUpdate);\n          }\n        },\n      );\n\n      const serverWillStops = taggedServerListeners\n        .map((l) => l.serverListener.serverWillStop)\n        .filter(isDefined);\n      if (serverWillStops.length) {\n        toDispose.push(async () => {\n          await Promise.all(\n            serverWillStops.map((serverWillStop) => serverWillStop()),\n          );\n        });\n      }\n\n      const drainServerCallbacks = taggedServerListeners\n        .map((l) => l.serverListener.drainServer)\n        .filter(isDefined);\n      const drainServers = drainServerCallbacks.length\n        ? async () => {\n            await Promise.all(\n              drainServerCallbacks.map((drainServer) => drainServer()),\n            );\n          }\n        : null;\n\n      // Find the renderLandingPage callback, if one is provided. If the user\n      // installed ApolloServerPluginLandingPageDisabled then there may be none\n      // found. On the other hand, if the user installed a landingPage plugin,\n      // then both the implicit installation of\n      // ApolloServerPluginLandingPage*Default and the other plugin will be\n      // found; we skip the implicit plugin.\n      let taggedServerListenersWithRenderLandingPage =\n        taggedServerListeners.filter((l) => l.serverListener.renderLandingPage);\n      if (taggedServerListenersWithRenderLandingPage.length > 1) {\n        taggedServerListenersWithRenderLandingPage =\n          taggedServerListenersWithRenderLandingPage.filter(\n            (l) => !l.installedImplicitly,\n          );\n      }\n      let landingPage: LandingPage | null = null;\n      if (taggedServerListenersWithRenderLandingPage.length > 1) {\n        throw Error('Only one plugin can implement renderLandingPage.');\n      } else if (taggedServerListenersWithRenderLandingPage.length) {\n        landingPage =\n          await taggedServerListenersWithRenderLandingPage[0].serverListener\n            .renderLandingPage!();\n      }\n\n      const toDisposeLast = this.maybeRegisterTerminationSignalHandlers(\n        ['SIGINT', 'SIGTERM'],\n        startedInBackground,\n      );\n\n      this.internals.state = {\n        phase: 'started',\n        schemaManager,\n        drainServers,\n        landingPage,\n        toDispose,\n        toDisposeLast,\n      };\n    } catch (maybeError: unknown) {\n      const error = ensureError(maybeError);\n\n      try {\n        await Promise.all(\n          this.internals.plugins.map(\n            async (plugin) => plugin.startupDidFail?.({ error }),\n          ),\n        );\n      } catch (pluginError) {\n        this.logger.error(`startupDidFail hook threw: ${pluginError}`);\n      }\n\n      this.internals.state = {\n        phase: 'failed to start',\n        error,\n      };\n      throw error;\n    } finally {\n      barrier.resolve();\n    }\n  }\n\n  private maybeRegisterTerminationSignalHandlers(\n    signals: NodeJS.Signals[],\n    startedInBackground: boolean,\n  ): (() => Promise<void>)[] {\n    const toDisposeLast: (() => Promise<void>)[] = [];\n\n    // We handle signals if it was explicitly requested\n    // (stopOnTerminationSignals === true), or if we're in Node, not in a test,\n    // not in a serverless framework (which we guess based on whether they\n    // called\n    // startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests),\n    // and it wasn't explicitly turned off. (We only actually register the\n    // signal handlers once we've successfully started up, because there's\n    // nothing to stop otherwise.)\n    if (\n      this.internals.stopOnTerminationSignals === false ||\n      (this.internals.stopOnTerminationSignals === undefined &&\n        !(\n          isNodeLike &&\n          this.internals.nodeEnv !== 'test' &&\n          !startedInBackground\n        ))\n    ) {\n      return toDisposeLast;\n    }\n\n    let receivedSignal = false;\n    const signalHandler: NodeJS.SignalsListener = async (signal) => {\n      if (receivedSignal) {\n        // If we receive another SIGINT or SIGTERM while we're waiting\n        // for the server to stop, just ignore it.\n        return;\n      }\n      receivedSignal = true;\n      try {\n        await this.stop();\n      } catch (e) {\n        this.logger.error(`stop() threw during ${signal} shutdown`);\n        this.logger.error(e);\n        // Can't rely on the signal handlers being removed.\n        process.exit(1);\n      }\n      // Note: this.stop will call the toDisposeLast handlers below, so at\n      // this point this handler will have been removed and we can re-kill\n      // ourself to die with the appropriate signal exit status. this.stop\n      // takes care to call toDisposeLast last, so the signal handler isn't\n      // removed until after the rest of shutdown happens.\n      process.kill(process.pid, signal);\n    };\n\n    signals.forEach((signal) => {\n      process.on(signal, signalHandler);\n      toDisposeLast.push(async () => {\n        process.removeListener(signal, signalHandler);\n      });\n    });\n    return toDisposeLast;\n  }\n\n  // This method is called at the beginning of each GraphQL request by\n  // `executeHTTPGraphQLRequest` and `executeOperation`. Most of its logic is\n  // only helpful if you started the server in the background (ie, for\n  // serverless frameworks): unless you're in a serverless framework, you should\n  // have called `await server.start()` before the server got to the point of\n  // running GraphQL requests (`assertStarted` calls in the framework\n  // integrations verify that) and so the only cases for non-serverless\n  // frameworks that this should hit are 'started', 'stopping', and 'stopped'.\n  // But if you started the server in the background (with\n  // startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests), this\n  // lets the server wait until fully started before serving operations.\n  private async _ensureStarted(): Promise<RunningServerState> {\n    while (true) {\n      switch (this.internals.state.phase) {\n        case 'initialized':\n          // This error probably won't happen: serverless framework integrations\n          // should call\n          // `startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests`\n          // for you, and other frameworks call `assertStarted` before setting\n          // things up enough to make calling this function possible.\n          throw new Error(\n            'You need to call `server.start()` before using your Apollo Server.',\n          );\n        case 'starting':\n          await this.internals.state.barrier;\n          // continue the while loop\n          break;\n        case 'failed to start':\n          // First we log the error that prevented startup (which means it will\n          // get logged once for every GraphQL operation).\n          this.logStartupError(this.internals.state.error);\n          // Now make the operation itself fail.\n          // We intentionally do not re-throw actual startup error as it may contain\n          // implementation details and this error will propagate to the client.\n          throw new Error(\n            'This data graph is missing a valid configuration. More details may be available in the server logs.',\n          );\n        case 'started':\n        case 'draining': // We continue to run operations while draining.\n          return this.internals.state;\n        case 'stopping':\n        case 'stopped':\n          this.logger.warn(\n            'A GraphQL operation was received during server shutdown. The ' +\n              'operation will fail. Consider draining the HTTP server on shutdown; ' +\n              'see https://go.apollo.dev/s/drain for details.',\n          );\n          throw new Error(\n            `Cannot execute GraphQL operations ${\n              this.internals.state.phase === 'stopping'\n                ? 'while the server is stopping'\n                : 'after the server has stopped'\n            }.'`,\n          );\n        default:\n          throw new UnreachableCaseError(this.internals.state);\n      }\n    }\n  }\n\n  // Framework integrations should call this to ensure that you've properly\n  // started your server before you get anywhere close to actually listening for\n  // incoming requests.\n  //\n  // There's a special case that if you called\n  // `startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests` and\n  // it hasn't finished starting up yet, this works too. This is intended for\n  // cases like a serverless integration (say, Google Cloud Functions) that\n  // calls\n  // `startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests` for\n  // you and then immediately sets up an integration based on another middleware\n  // like `expressMiddleware` which calls this function. We'd like this to be\n  // OK, but we still want normal Express users to start their ApolloServer\n  // before setting up their HTTP server unless they know what they are doing\n  // well enough to call the function with the long name themselves.\n  public assertStarted(expressionForError: string) {\n    if (\n      this.internals.state.phase !== 'started' &&\n      this.internals.state.phase !== 'draining' &&\n      !(\n        this.internals.state.phase === 'starting' &&\n        this.internals.state.startedInBackground\n      )\n    ) {\n      throw new Error(\n        'You must `await server.start()` before calling `' +\n          expressionForError +\n          '`',\n      );\n    }\n  }\n\n  // Given an error that occurred during Apollo Server startup, log it with a\n  // helpful message. This should happen when you call\n  // `startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests` (ie,\n  // in serverless frameworks); with other frameworks, you must `await\n  // server.start()` which will throw the startup error directly instead of\n  // logging. This gets called both immediately when the startup error happens,\n  // and on all subsequent requests.\n  private logStartupError(err: Error) {\n    this.logger.error(\n      'An error occurred during Apollo Server startup. All GraphQL requests ' +\n        'will now fail. The startup error was: ' +\n        (err?.message || err),\n    );\n  }\n\n  private static constructSchema<TContext extends BaseContext>(\n    config: ApolloServerOptionsWithStaticSchema<TContext>,\n  ): GraphQLSchema {\n    if (config.schema) {\n      return config.schema;\n    }\n\n    const { typeDefs, resolvers } = config;\n    const augmentedTypeDefs = Array.isArray(typeDefs) ? typeDefs : [typeDefs];\n\n    // For convenience, we allow you to pass a few options that we pass through\n    // to a particular version of `@graphql-tools/schema`'s\n    // `makeExecutableSchema`. If you want to use more of this function's\n    // features or have more control over the version of the packages used, just\n    // call it yourself like `new ApolloServer({schema:\n    // makeExecutableSchema(...)})`.\n    return makeExecutableSchema({\n      typeDefs: augmentedTypeDefs,\n      resolvers,\n    });\n  }\n\n  private static generateSchemaDerivedData(\n    schema: GraphQLSchema,\n    // null means don't use a documentStore at all.\n    // missing/undefined means use the default (creating a new one each\n    // time).\n    // defined means wrap this one in a random prefix for each new schema.\n    providedDocumentStore: DocumentStore | null | undefined,\n  ): SchemaDerivedData {\n    // Instead of waiting for the first operation execution against the schema\n    // to find out if it's a valid schema or not, check right now. In the\n    // non-gateway case, if this throws then the `new ApolloServer` call will\n    // throw. In the gateway case if this throws then it will log a message and\n    // just not update the schema (although oddly the message will claim that\n    // the schema is updating).\n    assertValidSchema(schema);\n\n    return {\n      schema,\n      // The DocumentStore is schema-derived because we put documents in it\n      // after checking that they pass GraphQL validation against the schema and\n      // use this to skip validation as well as parsing. So we can't reuse the\n      // same DocumentStore for different schemas because that might make us\n      // treat invalid operations as valid. If we're using the default\n      // DocumentStore, then we just create it from scratch each time we get a\n      // new schema. If we're using a user-provided DocumentStore, then we use\n      // the schema hash as a prefix.\n      documentStore:\n        providedDocumentStore === undefined\n          ? new InMemoryLRUCache<DocumentNode>()\n          : providedDocumentStore,\n      documentStoreKeyPrefix: providedDocumentStore\n        ? `${computeCoreSchemaHash(printSchema(schema))}:`\n        : '',\n    };\n  }\n\n  public async stop() {\n    switch (this.internals.state.phase) {\n      case 'initialized':\n      case 'starting':\n      case 'failed to start':\n        throw Error(\n          'apolloServer.stop() should only be called after `await apolloServer.start()` has succeeded',\n        );\n\n      // Calling stop more than once should have the same result as the first time.\n      case 'stopped':\n        if (this.internals.state.stopError) {\n          throw this.internals.state.stopError;\n        }\n        return;\n\n      // Two parallel calls to stop; just wait for the other one to finish and\n      // do whatever it did.\n      case 'stopping':\n      case 'draining': {\n        await this.internals.state.barrier;\n        // The cast here is because TS doesn't understand that this.state can\n        // change during the await\n        // (https://github.com/microsoft/TypeScript/issues/9998).\n        const state = this.internals.state as ServerState;\n        if (state.phase !== 'stopped') {\n          throw Error(`Surprising post-stopping state ${state.phase}`);\n        }\n        if (state.stopError) {\n          throw state.stopError;\n        }\n        return;\n      }\n\n      case 'started':\n        // This is handled by the rest of the function.\n        break;\n\n      default:\n        throw new UnreachableCaseError(this.internals.state);\n    }\n\n    const barrier = resolvable();\n\n    const {\n      schemaManager,\n      drainServers,\n      landingPage,\n      toDispose,\n      toDisposeLast,\n    } = this.internals.state;\n\n    // Commit to stopping and start draining servers.\n    this.internals.state = {\n      phase: 'draining',\n      barrier,\n      schemaManager,\n      landingPage,\n    };\n\n    try {\n      await drainServers?.();\n\n      // Servers are drained. Prevent further operations from starting and call\n      // stop handlers.\n      this.internals.state = { phase: 'stopping', barrier };\n\n      // We run shutdown handlers in two phases because we don't want to turn\n      // off our signal listeners (ie, allow signals to kill the process) until\n      // we've done the important parts of shutdown like running serverWillStop\n      // handlers. (We can make this more generic later if it's helpful.)\n      await Promise.all([...toDispose].map((dispose) => dispose()));\n      await Promise.all([...toDisposeLast].map((dispose) => dispose()));\n    } catch (stopError) {\n      this.internals.state = {\n        phase: 'stopped',\n        stopError: stopError as Error,\n      };\n      barrier.resolve();\n      throw stopError;\n    }\n    this.internals.state = { phase: 'stopped', stopError: null };\n  }\n\n  private async addDefaultPlugins() {\n    const { plugins, apolloConfig, nodeEnv } = this.internals;\n    const isDev = nodeEnv !== 'production';\n\n    const alreadyHavePluginWithInternalId = (id: InternalPluginId) =>\n      plugins.some(\n        (p) => pluginIsInternal(p) && p.__internal_plugin_id__ === id,\n      );\n\n    // Make sure we're not trying to explicitly enable and disable the same\n    // feature. (Be careful: we are not trying to stop people from installing\n    // the same plugin twice if they have a use case for it, like two usage\n    // reporting plugins for different variants.)\n    //\n    // Note that this check doesn't work for the landing page plugin, because\n    // users can write their own landing page plugins and we don't know if a\n    // given plugin is a landing page plugin until the server has started.\n    const pluginsByInternalID = new Map<\n      InternalPluginId,\n      { sawDisabled: boolean; sawNonDisabled: boolean }\n    >();\n    for (const p of plugins) {\n      if (pluginIsInternal(p)) {\n        const id = p.__internal_plugin_id__;\n        if (!pluginsByInternalID.has(id)) {\n          pluginsByInternalID.set(id, {\n            sawDisabled: false,\n            sawNonDisabled: false,\n          });\n        }\n        const seen = pluginsByInternalID.get(id)!;\n        if (p.__is_disabled_plugin__) {\n          seen.sawDisabled = true;\n        } else {\n          seen.sawNonDisabled = true;\n        }\n\n        if (seen.sawDisabled && seen.sawNonDisabled) {\n          throw new Error(\n            `You have tried to install both ApolloServerPlugin${id} and ` +\n              `ApolloServerPlugin${id}Disabled in your server. Please choose ` +\n              `whether or not you want to disable the feature and install the ` +\n              `appropriate plugin for your use case.`,\n          );\n        }\n      }\n    }\n\n    // Special case: cache control is on unless you explicitly disable it.\n    {\n      if (!alreadyHavePluginWithInternalId('CacheControl')) {\n        const { ApolloServerPluginCacheControl } = await import(\n          './plugin/cacheControl/index.js'\n        );\n        plugins.push(ApolloServerPluginCacheControl());\n      }\n    }\n\n    // Special case: usage reporting is on by default (and first!) if you\n    // configure an API key.\n    {\n      const alreadyHavePlugin =\n        alreadyHavePluginWithInternalId('UsageReporting');\n      if (!alreadyHavePlugin && apolloConfig.key) {\n        if (apolloConfig.graphRef) {\n          // Keep this plugin first so it wraps everything. (Unfortunately despite\n          // the fact that the person who wrote this line also was the original\n          // author of the comment above in #1105, they don't quite understand why this was important.)\n          const { ApolloServerPluginUsageReporting } = await import(\n            './plugin/usageReporting/index.js'\n          );\n          plugins.unshift(\n            ApolloServerPluginUsageReporting({\n              __onlyIfSchemaIsNotSubgraph: true,\n            }),\n          );\n        } else {\n          this.logger.warn(\n            'You have specified an Apollo key but have not specified a graph ref; usage ' +\n              'reporting is disabled. To enable usage reporting, set the `APOLLO_GRAPH_REF` ' +\n              'environment variable to `your-graph-id@your-graph-variant`. To disable this ' +\n              'warning, install `ApolloServerPluginUsageReportingDisabled`.',\n          );\n        }\n      }\n    }\n\n    // Special case: schema reporting can be turned on via environment variable.\n    {\n      const alreadyHavePlugin =\n        alreadyHavePluginWithInternalId('SchemaReporting');\n      const enabledViaEnvVar = process.env.APOLLO_SCHEMA_REPORTING === 'true';\n      if (!alreadyHavePlugin && enabledViaEnvVar) {\n        if (apolloConfig.key) {\n          const { ApolloServerPluginSchemaReporting } = await import(\n            './plugin/schemaReporting/index.js'\n          );\n          plugins.push(ApolloServerPluginSchemaReporting());\n        } else {\n          throw new Error(\n            \"You've enabled schema reporting by setting the APOLLO_SCHEMA_REPORTING \" +\n              'environment variable to true, but you also need to provide your ' +\n              'Apollo API key, via the APOLLO_KEY environment ' +\n              'variable or via `new ApolloServer({apollo: {key})',\n          );\n        }\n      }\n    }\n\n    // Special case: inline tracing is on by default for federated schemas.\n    {\n      const alreadyHavePlugin = alreadyHavePluginWithInternalId('InlineTrace');\n      if (!alreadyHavePlugin) {\n        // If we haven't explicitly disabled inline tracing via\n        // ApolloServerPluginInlineTraceDisabled or explicitly installed our own\n        // ApolloServerPluginInlineTrace, we set up inline tracing in \"only if\n        // federated\" mode.  (This is slightly different than the\n        // pre-ApolloServerPluginInlineTrace where we would also avoid doing\n        // this if an API key was configured and log a warning.)\n        const { ApolloServerPluginInlineTrace } = await import(\n          './plugin/inlineTrace/index.js'\n        );\n        plugins.push(\n          ApolloServerPluginInlineTrace({ __onlyIfSchemaIsSubgraph: true }),\n        );\n      }\n    }\n\n    // Special case: If we're not in production, show our default landing page.\n    //\n    // This works a bit differently from the other implicitly installed plugins,\n    // which rely entirely on the __internal_plugin_id__ to decide whether the\n    // plugin takes effect. That's because we want third-party plugins to be\n    // able to provide a landing page that overrides the default landing page,\n    // without them having to know about __internal_plugin_id__. So unless we\n    // actively disable the default landing page with\n    // ApolloServerPluginLandingPageDisabled, we install the default landing\n    // page, but with a special flag that _start() uses to ignore it if some\n    // other plugin defines a renderLandingPage callback. (We can't just look\n    // now to see if the plugin defines renderLandingPage because we haven't run\n    // serverWillStart yet.)\n    const alreadyHavePlugin = alreadyHavePluginWithInternalId(\n      'LandingPageDisabled',\n    );\n    if (!alreadyHavePlugin) {\n      const {\n        ApolloServerPluginLandingPageLocalDefault,\n        ApolloServerPluginLandingPageProductionDefault,\n      } = await import('./plugin/landingPage/default/index.js');\n      const plugin: ApolloServerPlugin<TContext> = isDev\n        ? ApolloServerPluginLandingPageLocalDefault()\n        : ApolloServerPluginLandingPageProductionDefault();\n      if (!isImplicitlyInstallablePlugin(plugin)) {\n        throw Error(\n          'default landing page plugin should be implicitly installable?',\n        );\n      }\n      plugin.__internal_installed_implicitly__ = true;\n      plugins.push(plugin);\n    }\n  }\n\n  public addPlugin(plugin: ApolloServerPlugin<TContext>) {\n    if (this.internals.state.phase !== 'initialized') {\n      throw new Error(\"Can't add plugins after the server has started\");\n    }\n    this.internals.plugins.push(plugin);\n  }\n\n  public async executeHTTPGraphQLRequest({\n    httpGraphQLRequest,\n    context,\n  }: {\n    httpGraphQLRequest: HTTPGraphQLRequest;\n    context: ContextThunk<TContext>;\n  }): Promise<HTTPGraphQLResponse> {\n    try {\n      let runningServerState;\n      try {\n        runningServerState = await this._ensureStarted();\n      } catch (error: unknown) {\n        // This is typically either the masked error from when background startup\n        // failed, or related to invoking this function before startup or\n        // during/after shutdown (due to lack of draining).\n        return await this.errorResponse(error, httpGraphQLRequest);\n      }\n\n      if (\n        runningServerState.landingPage &&\n        this.prefersHTML(httpGraphQLRequest)\n      ) {\n        let renderedHtml;\n        if (typeof runningServerState.landingPage.html === 'string') {\n          renderedHtml = runningServerState.landingPage.html;\n        } else {\n          try {\n            renderedHtml = await runningServerState.landingPage.html();\n          } catch (maybeError: unknown) {\n            const error = ensureError(maybeError);\n            this.logger.error(`Landing page \\`html\\` function threw: ${error}`);\n            return await this.errorResponse(error, httpGraphQLRequest);\n          }\n        }\n\n        return {\n          headers: new HeaderMap([['content-type', 'text/html']]),\n          body: {\n            kind: 'complete',\n            string: renderedHtml,\n          },\n        };\n      }\n\n      // If enabled, check to ensure that this request was preflighted before doing\n      // anything real (such as running the context function).\n      if (this.internals.csrfPreventionRequestHeaders) {\n        preventCsrf(\n          httpGraphQLRequest.headers,\n          this.internals.csrfPreventionRequestHeaders,\n        );\n      }\n\n      let contextValue: TContext;\n      try {\n        contextValue = await context();\n      } catch (maybeError: unknown) {\n        const error = ensureError(maybeError);\n        try {\n          await Promise.all(\n            this.internals.plugins.map(\n              async (plugin) =>\n                plugin.contextCreationDidFail?.({\n                  error,\n                }),\n            ),\n          );\n        } catch (pluginError) {\n          this.logger.error(\n            `contextCreationDidFail hook threw: ${pluginError}`,\n          );\n        }\n\n        // If some random function threw, add a helpful prefix when converting\n        // to GraphQLError. If it was already a GraphQLError, trust that the\n        // message was chosen thoughtfully and leave off the prefix.\n        return await this.errorResponse(\n          ensureGraphQLError(error, 'Context creation failed: '),\n          httpGraphQLRequest,\n        );\n      }\n\n      return await runPotentiallyBatchedHttpQuery(\n        this,\n        httpGraphQLRequest,\n        contextValue,\n        runningServerState.schemaManager.getSchemaDerivedData(),\n        this.internals,\n      );\n    } catch (maybeError_: unknown) {\n      const maybeError = maybeError_; // fixes inference because catch vars are not const\n      if (\n        maybeError instanceof GraphQLError &&\n        maybeError.extensions.code === ApolloServerErrorCode.BAD_REQUEST\n      ) {\n        try {\n          await Promise.all(\n            this.internals.plugins.map(\n              async (plugin) =>\n                plugin.invalidRequestWasReceived?.({ error: maybeError }),\n            ),\n          );\n        } catch (pluginError) {\n          this.logger.error(\n            `invalidRequestWasReceived hook threw: ${pluginError}`,\n          );\n        }\n      }\n      return await this.errorResponse(maybeError, httpGraphQLRequest);\n    }\n  }\n\n  private async errorResponse(\n    error: unknown,\n    requestHead: HTTPGraphQLHead,\n  ): Promise<HTTPGraphQLResponse> {\n    const { formattedErrors, httpFromErrors } = normalizeAndFormatErrors(\n      [error],\n      {\n        includeStacktraceInErrorResponses:\n          this.internals.includeStacktraceInErrorResponses,\n        formatError: this.internals.formatError,\n      },\n    );\n\n    return {\n      status: httpFromErrors.status ?? 500,\n      headers: new HeaderMap([\n        ...httpFromErrors.headers,\n        [\n          'content-type',\n          // Note that we may change the default to\n          // 'application/graphql-response+json' by 2025 as encouraged by the\n          // graphql-over-http spec. It's maybe a bit bad for us to provide\n          // an application/json response if they send `accept: foo/bar`,\n          // but we're already providing some sort of bad request error, and\n          // it's probably more useful for them to fix the other error before\n          // they deal with the `accept` header.\n          chooseContentTypeForSingleResultResponse(requestHead) ??\n            MEDIA_TYPES.APPLICATION_JSON,\n        ],\n      ]),\n      body: {\n        kind: 'complete',\n        string: await this.internals.stringifyResult({\n          errors: formattedErrors,\n        }),\n      },\n    };\n  }\n\n  private prefersHTML(request: HTTPGraphQLRequest): boolean {\n    const acceptHeader = request.headers.get('accept');\n    return (\n      request.method === 'GET' &&\n      !!acceptHeader &&\n      new Negotiator({\n        headers: { accept: acceptHeader },\n      }).mediaType([\n        // We need it to actively prefer text/html over less browser-y types;\n        // eg, `accept: */*' should still go for JSON. Negotiator does tiebreak\n        // by the order in the list we provide, so we put text/html last.\n        MEDIA_TYPES.APPLICATION_JSON,\n        MEDIA_TYPES.APPLICATION_GRAPHQL_RESPONSE_JSON,\n        MEDIA_TYPES.MULTIPART_MIXED_EXPERIMENTAL,\n        MEDIA_TYPES.MULTIPART_MIXED_NO_DEFER_SPEC,\n        MEDIA_TYPES.TEXT_HTML,\n      ]) === MEDIA_TYPES.TEXT_HTML\n    );\n  }\n\n  /**\n   * This method is primarily meant for testing: it allows you to execute a\n   * GraphQL operation via the request pipeline without going through the HTTP\n   * layer. Note that this means that any handling you do in your server at the\n   * HTTP level will not affect this call!\n   *\n   * For convenience, you can provide `request.query` either as a string or a\n   * DocumentNode, in case you choose to use the gql tag in your tests. This is\n   * just a convenience, not an optimization (we convert provided ASTs back into\n   * string).\n   *\n   * The second object is an optional options object which includes the optional\n   * `contextValue` object available in resolvers.\n   *\n   * You may specify the TData and TVariables generic types when calling this\n   * method; Apollo Server does not validate that the returned data actually\n   * matches the structure of TData. (Typically these types are created by a\n   * code generation tool.) Note that this does not enforce that `variables` is\n   * provided at all, just that it has the right type if provided.\n   */\n  public async executeOperation<\n    TData = Record<string, unknown>,\n    TVariables extends VariableValues = VariableValues,\n  >(\n    this: ApolloServer<BaseContext>,\n    request: Omit<GraphQLRequest<TVariables>, 'query'> & {\n      query?: string | DocumentNode | TypedQueryDocumentNode<TData, TVariables>;\n    },\n  ): Promise<GraphQLResponse<TData>>;\n  public async executeOperation<\n    TData = Record<string, unknown>,\n    TVariables extends VariableValues = VariableValues,\n  >(\n    request: Omit<GraphQLRequest<TVariables>, 'query'> & {\n      query?: string | DocumentNode | TypedQueryDocumentNode<TData, TVariables>;\n    },\n    options?: ExecuteOperationOptions<TContext>,\n  ): Promise<GraphQLResponse<TData>>;\n\n  async executeOperation<\n    TData = Record<string, unknown>,\n    TVariables extends VariableValues = VariableValues,\n  >(\n    request: Omit<GraphQLRequest<TVariables>, 'query'> & {\n      // We should consider supporting TypedDocumentNode from\n      // `@graphql-typed-document-node/core` as well, as it is more popular than\n      // the newer built-in type.\n      query?: string | DocumentNode | TypedQueryDocumentNode<TData, TVariables>;\n    },\n    options: ExecuteOperationOptions<TContext> = {},\n  ): Promise<GraphQLResponse<TData>> {\n    // Since this function is mostly for testing, you don't need to explicitly\n    // start your server before calling it. (That also means you can use it with\n    // `apollo-server` which doesn't support `start()`.)\n    if (this.internals.state.phase === 'initialized') {\n      await this.start();\n    }\n\n    const schemaDerivedData = (\n      await this._ensureStarted()\n    ).schemaManager.getSchemaDerivedData();\n\n    // For convenience, this function lets you pass either a string or an AST,\n    // but we normalize to string.\n    const graphQLRequest: GraphQLRequest = {\n      ...request,\n      query:\n        request.query && typeof request.query !== 'string'\n          ? print(request.query)\n          : request.query,\n    };\n\n    const response: GraphQLResponse = await internalExecuteOperation(\n      {\n        server: this,\n        graphQLRequest,\n        internals: this.internals,\n        schemaDerivedData,\n        sharedResponseHTTPGraphQLHead: null,\n      },\n      options,\n    );\n\n    // It's your job to set an appropriate TData (perhaps using codegen); we\n    // don't validate it.\n    return response as GraphQLResponse<TData>;\n  }\n}\n\n// Shared code between runHttpQuery (ie executeHTTPGraphQLRequest) and\n// executeOperation to set up a request context and invoke the request pipeline.\nexport async function internalExecuteOperation<TContext extends BaseContext>(\n  {\n    server,\n    graphQLRequest,\n    internals,\n    schemaDerivedData,\n    sharedResponseHTTPGraphQLHead,\n  }: {\n    server: ApolloServer<TContext>;\n    graphQLRequest: GraphQLRequest;\n    internals: ApolloServerInternals<TContext>;\n    schemaDerivedData: SchemaDerivedData;\n    sharedResponseHTTPGraphQLHead: HTTPGraphQLHead | null;\n  },\n  options: ExecuteOperationOptions<TContext>,\n): Promise<GraphQLResponse> {\n  const requestContext: GraphQLRequestContext<TContext> = {\n    logger: server.logger,\n    cache: server.cache,\n    schema: schemaDerivedData.schema,\n    request: graphQLRequest,\n    response: {\n      http: sharedResponseHTTPGraphQLHead ?? newHTTPGraphQLHead(),\n    },\n    // We clone the context because there are some assumptions that every operation\n    // execution has a brand new context object; specifically, in order to implement\n    // willResolveField we put a Symbol on the context that is specific to a particular\n    // request pipeline execution. We could avoid this if we had a better way of\n    // instrumenting execution.\n    //\n    // We don't want to do a deep clone here, because one of the main advantages of\n    // using batched HTTP requests is to share context across operations for a\n    // single request.\n    //\n    // The typecast here is safe, because the only way `contextValue` can be\n    // null-ish is if we used the `contextValue?: BaseContext` override, in\n    // which case TContext is BaseContext and {} is ok. (This does depend on\n    // the fact we've hackily forced the class to be contravariant in\n    // TContext.)\n    contextValue: cloneObject(options?.contextValue ?? ({} as TContext)),\n    metrics: {},\n    overallCachePolicy: newCachePolicy(),\n    requestIsBatched: sharedResponseHTTPGraphQLHead !== null,\n  };\n\n  try {\n    return await processGraphQLRequest(\n      schemaDerivedData,\n      server,\n      internals,\n      requestContext,\n    );\n  } catch (maybeError: unknown) {\n    // processGraphQLRequest throwing usually means that either there's a bug in\n    // Apollo Server or some plugin hook threw unexpectedly.\n    const error = ensureError(maybeError);\n    // If *these* hooks throw then we'll still get a 500 but won't mask its\n    // error.\n    await Promise.all(\n      internals.plugins.map(\n        async (plugin) =>\n          plugin.unexpectedErrorProcessingRequest?.({\n            requestContext,\n            error,\n          }),\n      ),\n    );\n    // Mask unexpected error externally.\n    server.logger.error(`Unexpected error processing request: ${error}`);\n    throw new Error('Internal server error');\n  }\n}\n\n// Unlike InternalPlugins (where we can decide whether to install the default\n// plugin based on looking at which plugins are installed),\n// ImplicitlyInstallablePlugins (ie the default landing page plugin) can't\n// determine if they're needed until later in startup. Specifically, we can't\n// know if we've defined our own landing page until after serverWillStart\n// plugins have run.\nexport type ImplicitlyInstallablePlugin<TContext extends BaseContext> =\n  ApolloServerPlugin<TContext> & {\n    __internal_installed_implicitly__: boolean;\n  };\n\nexport function isImplicitlyInstallablePlugin<TContext extends BaseContext>(\n  p: ApolloServerPlugin<TContext>,\n): p is ImplicitlyInstallablePlugin<TContext> {\n  return '__internal_installed_implicitly__' in p;\n}\n\nexport const MEDIA_TYPES = {\n  APPLICATION_JSON: 'application/json; charset=utf-8',\n  APPLICATION_JSON_GRAPHQL_CALLBACK:\n    'application/json; callbackSpec=1.0; charset=utf-8',\n  APPLICATION_GRAPHQL_RESPONSE_JSON:\n    'application/graphql-response+json; charset=utf-8',\n  // We do *not* currently support this content-type; we will once incremental\n  // delivery is part of the official GraphQL spec.\n  MULTIPART_MIXED_NO_DEFER_SPEC: 'multipart/mixed',\n  MULTIPART_MIXED_EXPERIMENTAL: 'multipart/mixed; deferSpec=20220824',\n  TEXT_HTML: 'text/html',\n};\n\nexport function chooseContentTypeForSingleResultResponse(\n  head: HTTPGraphQLHead,\n): string | null {\n  const acceptHeader = head.headers.get('accept');\n  if (!acceptHeader) {\n    // Note that we may change the default to\n    // 'application/graphql-response+json' by 2025 as encouraged by the\n    // graphql-over-http spec.\n    return MEDIA_TYPES.APPLICATION_JSON;\n  } else {\n    const preferred = new Negotiator({\n      headers: { accept: head.headers.get('accept') },\n    }).mediaType([\n      MEDIA_TYPES.APPLICATION_JSON,\n      MEDIA_TYPES.APPLICATION_GRAPHQL_RESPONSE_JSON,\n      MEDIA_TYPES.APPLICATION_JSON_GRAPHQL_CALLBACK,\n    ]);\n    if (preferred) {\n      return preferred;\n    } else {\n      return null;\n    }\n  }\n}\n\nfunction cloneObject<T extends Object>(object: T): T {\n  return Object.assign(Object.create(Object.getPrototypeOf(object)), object);\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 6367, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6372, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@apollo/server/src/externalTypes/index.ts"],"sourcesContent":["/**\n * This file represents the external type definitions needed by end users,\n * integration implementors, and plugin implementors. Everything from this file\n * is re-exported by the root (via * export), so add exports to this file with\n * intention (it's public API).\n */\nexport type { BaseContext, ContextFunction, ContextThunk } from './context.js';\nexport type { GraphQLRequest, GraphQLResponse } from './graphql.js';\nexport type {\n  HTTPGraphQLRequest,\n  HTTPGraphQLResponse,\n  HTTPGraphQLHead,\n} from './http.js';\nexport type {\n  ApolloServerPlugin,\n  GraphQLFieldResolverParams,\n  GraphQLRequestExecutionListener,\n  GraphQLRequestListener,\n  GraphQLRequestListenerDidResolveField,\n  GraphQLRequestListenerExecutionDidEnd,\n  GraphQLRequestListenerParsingDidEnd,\n  GraphQLRequestListenerValidationDidEnd,\n  GraphQLSchemaContext,\n  GraphQLServerListener,\n  GraphQLServerContext,\n  LandingPage,\n} from './plugins.js';\nexport type {\n  GraphQLRequestContext,\n  GraphQLRequestMetrics,\n  GraphQLRequestContextDidEncounterErrors,\n  GraphQLRequestContextDidResolveOperation,\n  GraphQLRequestContextDidResolveSource,\n  GraphQLRequestContextExecutionDidStart,\n  GraphQLRequestContextParsingDidStart,\n  GraphQLRequestContextResponseForOperation,\n  GraphQLRequestContextValidationDidStart,\n  GraphQLRequestContextWillSendResponse,\n} from './requestPipeline.js';\nexport type {\n  DocumentStore,\n  ApolloConfigInput,\n  ApolloConfig,\n  PersistedQueryOptions,\n  CSRFPreventionOptions,\n  ApolloServerOptionsWithSchema,\n  ApolloServerOptionsWithTypeDefs,\n  ApolloServerOptionsWithStaticSchema,\n  ApolloServerOptionsWithGateway,\n  ApolloServerOptions,\n} from './constructor.js';\n\nexport type {\n  GraphQLExperimentalFormattedInitialIncrementalExecutionResult,\n  GraphQLExperimentalFormattedSubsequentIncrementalExecutionResult,\n  GraphQLExperimentalFormattedIncrementalResult,\n  GraphQLExperimentalFormattedIncrementalDeferResult,\n  GraphQLExperimentalFormattedIncrementalStreamResult,\n} from './incrementalDeliveryPolyfill.js';\n"],"names":[],"mappings":""}},
    {"offset": {"line": 6375, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6380, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@apollo/server/src/index.ts"],"sourcesContent":["export { ApolloServer } from './ApolloServer.js';\nexport { HeaderMap } from './utils/HeaderMap.js';\n// Note that this is purely a type export.\nexport * from './externalTypes/index.js';\n"],"names":[],"mappings":""}},
    {"offset": {"line": 6385, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}